{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  constructor(module, importedNames) {\n    let weak = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;\n    // TODO webpack 5: make it a getter\n    this.module = module; // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n\n\n  static sort(array) {\n    /** @type {WeakMap<DependencyReference, number>} */\n    const originalOrder = new WeakMap();\n    let i = 0;\n\n    for (const ref of array) {\n      originalOrder.set(ref, i++);\n    }\n\n    return array.sort((a, b) => {\n      const aOrder = a.order;\n      const bOrder = b.order;\n\n      if (isNaN(aOrder)) {\n        if (!isNaN(bOrder)) {\n          return 1;\n        }\n      } else {\n        if (isNaN(bOrder)) {\n          return -1;\n        }\n\n        if (aOrder !== bOrder) {\n          return aOrder - bOrder;\n        }\n      }\n\n      const aOrg = originalOrder.get(a);\n      const bOrg = originalOrder.get(b);\n      return aOrg - bOrg;\n    });\n  }\n\n}\n\nmodule.exports = DependencyReference;","map":{"version":3,"names":["DependencyReference","constructor","module","importedNames","weak","order","NaN","sort","array","originalOrder","WeakMap","i","ref","set","a","b","aOrder","bOrder","isNaN","aOrg","get","bOrg","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/dependencies/DependencyReference.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n\t// TODO webpack 5: module must be dynamic, you must pass a function returning a module\n\t// This is needed to remove the hack in ConcatenatedModule\n\t// The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {string[] | boolean} importedNames imported named from the module\n\t * @param {boolean=} weak if this is a weak reference\n\t * @param {number} order the order information or NaN if don't care\n\t */\n\tconstructor(module, importedNames, weak = false, order = NaN) {\n\t\t// TODO webpack 5: make it a getter\n\t\tthis.module = module;\n\t\t// true: full object\n\t\t// false: only sideeffects/no export\n\t\t// array of strings: the exports with this names\n\t\tthis.importedNames = importedNames;\n\t\tthis.weak = !!weak;\n\t\tthis.order = order;\n\t}\n\n\t/**\n\t * @param {DependencyReference[]} array an array (will be modified)\n\t * @returns {DependencyReference[]} the array again\n\t */\n\tstatic sort(array) {\n\t\t/** @type {WeakMap<DependencyReference, number>} */\n\t\tconst originalOrder = new WeakMap();\n\t\tlet i = 0;\n\t\tfor (const ref of array) {\n\t\t\toriginalOrder.set(ref, i++);\n\t\t}\n\t\treturn array.sort((a, b) => {\n\t\t\tconst aOrder = a.order;\n\t\t\tconst bOrder = b.order;\n\t\t\tif (isNaN(aOrder)) {\n\t\t\t\tif (!isNaN(bOrder)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isNaN(bOrder)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (aOrder !== bOrder) {\n\t\t\t\t\treturn aOrder - bOrder;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst aOrg = originalOrder.get(a);\n\t\t\tconst bOrg = originalOrder.get(b);\n\t\t\treturn aOrg - bOrg;\n\t\t});\n\t}\n}\n\nmodule.exports = DependencyReference;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,mBAAN,CAA0B;EACzB;EACA;EACA;;EACA;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAW,CAACC,MAAD,EAASC,aAAT,EAAmD;IAAA,IAA3BC,IAA2B,uEAApB,KAAoB;IAAA,IAAbC,KAAa,uEAALC,GAAK;IAC7D;IACA,KAAKJ,MAAL,GAAcA,MAAd,CAF6D,CAG7D;IACA;IACA;;IACA,KAAKC,aAAL,GAAqBA,aAArB;IACA,KAAKC,IAAL,GAAY,CAAC,CAACA,IAAd;IACA,KAAKC,KAAL,GAAaA,KAAb;EACA;EAED;AACD;AACA;AACA;;;EACY,OAAJE,IAAI,CAACC,KAAD,EAAQ;IAClB;IACA,MAAMC,aAAa,GAAG,IAAIC,OAAJ,EAAtB;IACA,IAAIC,CAAC,GAAG,CAAR;;IACA,KAAK,MAAMC,GAAX,IAAkBJ,KAAlB,EAAyB;MACxBC,aAAa,CAACI,GAAd,CAAkBD,GAAlB,EAAuBD,CAAC,EAAxB;IACA;;IACD,OAAOH,KAAK,CAACD,IAAN,CAAW,CAACO,CAAD,EAAIC,CAAJ,KAAU;MAC3B,MAAMC,MAAM,GAAGF,CAAC,CAACT,KAAjB;MACA,MAAMY,MAAM,GAAGF,CAAC,CAACV,KAAjB;;MACA,IAAIa,KAAK,CAACF,MAAD,CAAT,EAAmB;QAClB,IAAI,CAACE,KAAK,CAACD,MAAD,CAAV,EAAoB;UACnB,OAAO,CAAP;QACA;MACD,CAJD,MAIO;QACN,IAAIC,KAAK,CAACD,MAAD,CAAT,EAAmB;UAClB,OAAO,CAAC,CAAR;QACA;;QACD,IAAID,MAAM,KAAKC,MAAf,EAAuB;UACtB,OAAOD,MAAM,GAAGC,MAAhB;QACA;MACD;;MACD,MAAME,IAAI,GAAGV,aAAa,CAACW,GAAd,CAAkBN,CAAlB,CAAb;MACA,MAAMO,IAAI,GAAGZ,aAAa,CAACW,GAAd,CAAkBL,CAAlB,CAAb;MACA,OAAOI,IAAI,GAAGE,IAAd;IACA,CAlBM,CAAP;EAmBA;;AApDwB;;AAuD1BnB,MAAM,CAACoB,OAAP,GAAiBtB,mBAAjB"},"metadata":{},"sourceType":"script"}