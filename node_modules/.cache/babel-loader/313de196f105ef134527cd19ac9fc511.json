{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n  const chunks = [];\n  const stack = new Set(currentChunk.parentsIterable);\n\n  for (const chunk of stack) {\n    if (chunk.containsModule(module)) {\n      chunks.push(chunk);\n    } else {\n      for (const parent of chunk.parentsIterable) {\n        stack.add(parent);\n      }\n    }\n  }\n\n  return chunks;\n};\n\nclass RemoveParentModulesPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n\n                for (const chunk of parent.chunks) {\n                  for (const m of chunk.modulesIterable) {\n                    availableModules.add(m);\n                  }\n                }\n\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!parent.containsModule(m) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        } // now we have available modules for every chunk\n\n\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunk.getNumberOfModules();\n          const toRemove = new Set();\n\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunk.modulesIterable) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunk.containsModule(m)) {\n                toRemove.add(m);\n              }\n            }\n          }\n\n          for (const module of toRemove) {\n            module.rewriteChunkInReasons(chunk, getParentChunksWithModule(chunk, module));\n            chunk.removeModule(module);\n          }\n        }\n      };\n\n      compilation.hooks.optimizeChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n      compilation.hooks.optimizeExtractedChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"names":["Queue","require","intersect","getParentChunksWithModule","currentChunk","module","chunks","stack","Set","parentsIterable","chunk","containsModule","push","parent","add","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunkGroups","queue","availableModulesMap","WeakMap","chunkGroup","entrypoints","values","set","child","childrenIterable","enqueue","length","dequeue","availableModules","get","changed","availableModulesInParent","undefined","m","modulesIterable","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfModules","toRemove","size","rewriteChunkInReasons","removeModule","optimizeChunksBasic","optimizeExtractedChunksBasic","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n\tconst chunks = [];\n\tconst stack = new Set(currentChunk.parentsIterable);\n\n\tfor (const chunk of stack) {\n\t\tif (chunk.containsModule(module)) {\n\t\t\tchunks.push(chunk);\n\t\t} else {\n\t\t\tfor (const parent of chunk.parentsIterable) {\n\t\t\t\tstack.add(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chunks;\n};\n\nclass RemoveParentModulesPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!parent.containsModule(m) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunk.getNumberOfModules();\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunk.containsModule(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tmodule.rewriteChunkInReasons(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgetParentChunksWithModule(chunk, module)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t\tcompilation.hooks.optimizeExtractedChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}