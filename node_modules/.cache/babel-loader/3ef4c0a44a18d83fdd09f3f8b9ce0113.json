{"ast":null,"code":"import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}","map":{"version":3,"names":["encodeU32","getSectionMetadata","traverse","shiftSection","overrideBytesInBuffer","resizeSectionByteSize","ast","uint8Buffer","section","deltaBytes","sectionMetadata","Error","size","loc","start","column","end","newSectionSize","value","newBytes","oldu32EncodedLen","newu32EncodedLen","length","deltaInSizeEncoding","vectorOfSize","encounteredSection","SectionMetadata","path","node","resizeSectionVecSize","deltaElements","newValue"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/@webassemblyjs/helper-wasm-section/esm/resize.js"],"sourcesContent":["import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}