{"ast":null,"code":"'use strict';\n\nconst DEFAULT_OPTIONS = {\n  workerOptions: {},\n  maxCallsPerWorker: Infinity,\n  maxConcurrentWorkers: (require('os').cpus() || {\n    length: 1\n  }).length,\n  maxConcurrentCallsPerWorker: 10,\n  maxConcurrentCalls: Infinity,\n  maxCallTime: Infinity // exceed this and the whole worker is terminated\n  ,\n  maxRetries: Infinity,\n  forcedKillTime: 100,\n  autoStart: false,\n  onChild: function () {}\n};\n\nconst fork = require('./fork'),\n      TimeoutError = require('errno').create('TimeoutError'),\n      ProcessTerminatedError = require('errno').create('ProcessTerminatedError'),\n      MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError');\n\nfunction Farm(options, path) {\n  this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  this.path = path;\n  this.activeCalls = 0;\n} // make a handle to pass back in the form of an external API\n\n\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')');\n      if (typeof args[args.length - 1] == 'function') return process.nextTick(args[args.length - 1].bind(null, err));\n      throw err;\n    }\n\n    this.addCall({\n      method: method,\n      callback: args.pop(),\n      args: args,\n      retries: 0\n    });\n  }.bind(this);\n}; // a constructor of sorts\n\n\nFarm.prototype.setup = function (methods) {\n  let iface;\n\n  if (!methods) {\n    // single-function export\n    iface = this.mkhandle();\n  } else {\n    // multiple functions on the export\n    iface = {};\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m);\n    }.bind(this));\n  }\n\n  this.searchStart = -1;\n  this.childId = -1;\n  this.children = {};\n  this.activeChildren = 0;\n  this.callQueue = [];\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n  }\n\n  return iface;\n}; // when a child exits, check if there are any outstanding jobs and requeue them\n\n\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false;\n\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return;else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n            idx: i,\n            child: childId,\n            args: [new ProcessTerminatedError('cancel after ' + call.retries + ' retries!')]\n          });\n        } else {\n          call.retries++;\n          this.callQueue.unshift(call);\n          doQueue = true;\n        }\n      }.bind(this));\n    }\n\n    this.stopChild(childId);\n    doQueue && this.processQueue();\n  }.bind(this), 10);\n}; // start a new worker\n\n\nFarm.prototype.startChild = function () {\n  this.childId++;\n  let forked = fork(this.path, this.options.workerOptions),\n      id = this.childId,\n      c = {\n    send: forked.send,\n    child: forked.child,\n    calls: [],\n    activeCalls: 0,\n    exitCode: null\n  };\n  this.options.onChild(forked.child);\n  forked.child.on('message', function (data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n\n    this.receive(data);\n  }.bind(this));\n  forked.child.once('exit', function (code) {\n    c.exitCode = code;\n    this.onExit(id);\n  }.bind(this));\n  this.activeChildren++;\n  this.children[id] = c;\n}; // stop a worker, identified by id\n\n\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId];\n\n  if (child) {\n    child.send({\n      owner: 'farm',\n      event: 'die'\n    });\n    setTimeout(function () {\n      if (child.exitCode === null) child.child.kill('SIGKILL');\n    }, this.options.forcedKillTime).unref();\n    delete this.children[childId];\n    this.activeChildren--;\n  }\n}; // called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\n\n\nFarm.prototype.receive = function (data) {\n  let idx = data.idx,\n      childId = data.child,\n      args = data.args,\n      child = this.children[childId],\n      call;\n\n  if (!child) {\n    return console.error('Worker Farm: Received message for unknown child. ' + 'This is likely as a result of premature child death, ' + 'the operation will have been re-queued.');\n  }\n\n  call = child.calls[idx];\n\n  if (!call) {\n    return console.error('Worker Farm: Received message for unknown index for existing child. ' + 'This should not happen!');\n  }\n\n  if (this.options.maxCallTime !== Infinity) clearTimeout(call.timer);\n\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0];\n\n    switch (e.type) {\n      case 'TypeError':\n        args[0] = new TypeError(e.message);\n        break;\n\n      case 'RangeError':\n        args[0] = new RangeError(e.message);\n        break;\n\n      case 'EvalError':\n        args[0] = new EvalError(e.message);\n        break;\n\n      case 'ReferenceError':\n        args[0] = new ReferenceError(e.message);\n        break;\n\n      case 'SyntaxError':\n        args[0] = new SyntaxError(e.message);\n        break;\n\n      case 'URIError':\n        args[0] = new URIError(e.message);\n        break;\n\n      default:\n        args[0] = new Error(e.message);\n    }\n\n    args[0].type = e.type;\n    args[0].stack = e.stack; // Copy any custom properties to pass it on.\n\n    Object.keys(e).forEach(function (key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args);\n  });\n  delete child.calls[idx];\n  child.activeCalls--;\n  this.activeCalls--;\n\n  if (child.calls.length >= this.options.maxCallsPerWorker && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId);\n  } // allow any outstanding calls to be processed\n\n\n  this.processQueue();\n};\n\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId],\n      i;\n  if (!child) return;\n\n  for (i in child.calls) {\n    this.receive({\n      idx: i,\n      child: childId,\n      args: [new TimeoutError('worker call timed out!')]\n    });\n  }\n\n  this.stopChild(childId);\n}; // send a call to a worker, identified by id\n\n\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId],\n      idx = child.calls.length;\n  child.calls.push(call);\n  child.activeCalls++;\n  this.activeCalls++;\n  child.send({\n    owner: 'farm',\n    idx: idx,\n    child: childId,\n    method: call.method,\n    args: call.args\n  });\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer = setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime);\n  }\n}; // a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\n\n\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children),\n      cks;\n  if (this.searchStart >= cka.length - 1) this.searchStart = 0;else this.searchStart++;\n  cks = cka.splice(0, this.searchStart);\n  return cka.concat(cks);\n}; // Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\n\n\nFarm.prototype.processQueue = function () {\n  let cka,\n      i = 0,\n      childId;\n  if (!this.callQueue.length) return this.ending && this.end();\n  if (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i];\n\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n      this.send(childId, this.callQueue.shift());\n      if (!this.callQueue.length) return this.ending && this.end();\n    }\n    /*else {\n    console.log(\n      , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n      , this.children[childId].calls.length < this.options.maxCallsPerWorker\n      , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n\n  }\n\n  if (this.ending) this.end();\n}; // add a new call to the call queue, then trigger a process of the queue\n\n\nFarm.prototype.addCall = function (call) {\n  if (this.ending) return this.end(); // don't add anything new to the queue\n\n  this.callQueue.push(call);\n  this.processQueue();\n}; // kills child workers when they're all done\n\n\nFarm.prototype.end = function (callback) {\n  let complete = true;\n  if (this.ending === false) return;\n  if (callback) this.ending = callback;else if (this.ending == null) this.ending = true;\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child]) return;\n    if (!this.children[child].activeCalls) this.stopChild(child);else complete = false;\n  }.bind(this));\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending();\n      this.ending = false;\n    }.bind(this));\n  }\n};\n\nmodule.exports = Farm;\nmodule.exports.TimeoutError = TimeoutError;","map":{"version":3,"names":["DEFAULT_OPTIONS","workerOptions","maxCallsPerWorker","Infinity","maxConcurrentWorkers","require","cpus","length","maxConcurrentCallsPerWorker","maxConcurrentCalls","maxCallTime","maxRetries","forcedKillTime","autoStart","onChild","fork","TimeoutError","create","ProcessTerminatedError","MaxConcurrentCallsError","Farm","options","path","Object","assign","activeCalls","prototype","mkhandle","method","args","Array","slice","call","arguments","callQueue","err","process","nextTick","bind","addCall","callback","pop","retries","setup","methods","iface","forEach","m","searchStart","childId","children","activeChildren","startChild","onExit","setTimeout","doQueue","calls","i","receive","idx","child","unshift","stopChild","processQueue","forked","id","c","send","exitCode","on","data","owner","once","code","event","kill","unref","console","error","clearTimeout","timer","$error","e","type","TypeError","message","RangeError","EvalError","ReferenceError","SyntaxError","URIError","Error","stack","keys","key","apply","childTimeout","push","childKeys","cka","cks","splice","concat","ending","end","shift","complete","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/worker-farm/lib/farm.js"],"sourcesContent":["'use strict'\n\nconst DEFAULT_OPTIONS = {\n          workerOptions               : {}\n        , maxCallsPerWorker           : Infinity\n        , maxConcurrentWorkers        : (require('os').cpus() || { length: 1 }).length\n        , maxConcurrentCallsPerWorker : 10\n        , maxConcurrentCalls          : Infinity\n        , maxCallTime                 : Infinity // exceed this and the whole worker is terminated\n        , maxRetries                  : Infinity\n        , forcedKillTime              : 100\n        , autoStart                   : false\n        , onChild                     : function() {}\n      }\n\nconst fork                    = require('./fork')\n    , TimeoutError            = require('errno').create('TimeoutError')\n    , ProcessTerminatedError  = require('errno').create('ProcessTerminatedError')\n    , MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError')\n\n\nfunction Farm (options, path) {\n  this.options     = Object.assign({}, DEFAULT_OPTIONS, options)\n  this.path        = path\n  this.activeCalls = 0\n}\n\n\n// make a handle to pass back in the form of an external API\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments)\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')')\n      if (typeof args[args.length - 1] == 'function')\n        return process.nextTick(args[args.length - 1].bind(null, err))\n      throw err\n    }\n    this.addCall({\n        method   : method\n      , callback : args.pop()\n      , args     : args\n      , retries  : 0\n    })\n  }.bind(this)\n}\n\n\n// a constructor of sorts\nFarm.prototype.setup = function (methods) {\n  let iface\n  if (!methods) { // single-function export\n    iface = this.mkhandle()\n  } else { // multiple functions on the export\n    iface = {}\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m)\n    }.bind(this))\n  }\n\n  this.searchStart    = -1\n  this.childId        = -1\n  this.children       = {}\n  this.activeChildren = 0\n  this.callQueue      = []\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers)\n      this.startChild()\n  }\n\n  return iface\n}\n\n\n// when a child exits, check if there are any outstanding jobs and requeue them\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return\n        else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n              idx   : i\n            , child : childId\n            , args  : [ new ProcessTerminatedError('cancel after ' + call.retries + ' retries!') ]\n          })\n        } else {\n          call.retries++\n          this.callQueue.unshift(call)\n          doQueue = true\n        }\n      }.bind(this))\n    }\n    this.stopChild(childId)\n    doQueue && this.processQueue()\n  }.bind(this), 10)\n}\n\n\n// start a new worker\nFarm.prototype.startChild = function () {\n  this.childId++\n\n  let forked = fork(this.path, this.options.workerOptions)\n    , id     = this.childId\n    , c      = {\n          send        : forked.send\n        , child       : forked.child\n        , calls       : []\n        , activeCalls : 0\n        , exitCode    : null\n      }\n\n  this.options.onChild(forked.child);\n\n  forked.child.on('message', function(data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n    this.receive(data);\n  }.bind(this))\n  forked.child.once('exit', function (code) {\n    c.exitCode = code\n    this.onExit(id)\n  }.bind(this))\n\n  this.activeChildren++\n  this.children[id] = c\n}\n\n\n// stop a worker, identified by id\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId]\n  if (child) {\n    child.send({owner: 'farm', event: 'die'})\n    setTimeout(function () {\n      if (child.exitCode === null)\n        child.child.kill('SIGKILL')\n    }, this.options.forcedKillTime).unref()\n    ;delete this.children[childId]\n    this.activeChildren--\n  }\n}\n\n\n// called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\nFarm.prototype.receive = function (data) {\n  let idx     = data.idx\n    , childId = data.child\n    , args    = data.args\n    , child   = this.children[childId]\n    , call\n\n  if (!child) {\n    return console.error(\n        'Worker Farm: Received message for unknown child. '\n      + 'This is likely as a result of premature child death, '\n      + 'the operation will have been re-queued.'\n    )\n  }\n\n  call = child.calls[idx]\n  if (!call) {\n    return console.error(\n        'Worker Farm: Received message for unknown index for existing child. '\n      + 'This should not happen!'\n    )\n  }\n\n  if (this.options.maxCallTime !== Infinity)\n    clearTimeout(call.timer)\n\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0]\n    switch (e.type) {\n      case 'TypeError': args[0] = new TypeError(e.message); break\n      case 'RangeError': args[0] = new RangeError(e.message); break\n      case 'EvalError': args[0] = new EvalError(e.message); break\n      case 'ReferenceError': args[0] = new ReferenceError(e.message); break\n      case 'SyntaxError': args[0] = new SyntaxError(e.message); break\n      case 'URIError': args[0] = new URIError(e.message); break\n      default: args[0] = new Error(e.message)\n    }\n    args[0].type = e.type\n    args[0].stack = e.stack\n\n    // Copy any custom properties to pass it on.\n    Object.keys(e).forEach(function(key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args)\n  })\n\n  ;delete child.calls[idx]\n  child.activeCalls--\n  this.activeCalls--\n\n  if (child.calls.length >= this.options.maxCallsPerWorker\n      && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId)\n  }\n\n  // allow any outstanding calls to be processed\n  this.processQueue()\n}\n\n\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId]\n    , i\n\n  if (!child)\n    return\n\n  for (i in child.calls) {\n    this.receive({\n        idx   : i\n      , child : childId\n      , args  : [ new TimeoutError('worker call timed out!') ]\n    })\n  }\n  this.stopChild(childId)\n}\n\n\n// send a call to a worker, identified by id\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId]\n    , idx   = child.calls.length\n\n  child.calls.push(call)\n  child.activeCalls++\n  this.activeCalls++\n\n  child.send({\n      owner  : 'farm'\n    , idx    : idx\n    , child  : childId\n    , method : call.method\n    , args   : call.args\n  })\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer =\n      setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime)\n  }\n}\n\n\n// a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children)\n    , cks\n\n  if (this.searchStart >= cka.length - 1)\n    this.searchStart = 0\n  else\n    this.searchStart++\n\n  cks = cka.splice(0, this.searchStart)\n\n  return cka.concat(cks)\n}\n\n\n// Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\nFarm.prototype.processQueue = function () {\n  let cka, i = 0, childId\n\n  if (!this.callQueue.length)\n    return this.ending && this.end()\n\n  if (this.activeChildren < this.options.maxConcurrentWorkers)\n    this.startChild()\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i]\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n\n      this.send(childId, this.callQueue.shift())\n      if (!this.callQueue.length)\n        return this.ending && this.end()\n    } /*else {\n      console.log(\n        , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        , this.children[childId].calls.length < this.options.maxCallsPerWorker\n        , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n  }\n\n  if (this.ending)\n    this.end()\n}\n\n\n// add a new call to the call queue, then trigger a process of the queue\nFarm.prototype.addCall = function (call) {\n  if (this.ending)\n    return this.end() // don't add anything new to the queue\n  this.callQueue.push(call)\n  this.processQueue()\n}\n\n\n// kills child workers when they're all done\nFarm.prototype.end = function (callback) {\n  let complete = true\n  if (this.ending === false)\n    return\n  if (callback)\n    this.ending = callback\n  else if (this.ending == null)\n    this.ending = true\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child])\n      return\n    if (!this.children[child].activeCalls)\n      this.stopChild(child)\n    else\n      complete = false\n  }.bind(this))\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending()\n      this.ending = false\n    }.bind(this))\n  }\n}\n\n\nmodule.exports              = Farm\nmodule.exports.TimeoutError = TimeoutError\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}