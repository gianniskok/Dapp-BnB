{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}","map":{"version":3,"names":["extract","buffer","bitIndex","bitLength","defaultBit","Error","undefined","defaultByte","result","lastBit","startByte","Math","floor","startBit","endByte","endBit","get","index","inject","value","lastByte","length","atByte","atBit","getSign","highOrder","bit","fullyWrongByte","byteToCheck","i"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/@webassemblyjs/leb128/esm/bits.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}