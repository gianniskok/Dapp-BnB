{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\"use strict\";\n\nconst notMatcher = matcher => {\n  return str => {\n    return !matcher(str);\n  };\n};\n\nconst orMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (items[i](str)) return true;\n    }\n\n    return false;\n  };\n};\n\nconst andMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i](str)) return false;\n    }\n\n    return true;\n  };\n};\n\nmodule.exports = class RuleSet {\n  constructor(rules) {\n    this.references = Object.create(null);\n    this.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n  }\n\n  static normalizeRules(rules, refs, ident) {\n    if (Array.isArray(rules)) {\n      return rules.map((rule, idx) => {\n        return RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n      });\n    } else if (rules) {\n      return [RuleSet.normalizeRule(rules, refs, ident)];\n    } else {\n      return [];\n    }\n  }\n\n  static normalizeRule(rule, refs, ident) {\n    if (typeof rule === \"string\") {\n      return {\n        use: [{\n          loader: rule\n        }]\n      };\n    }\n\n    if (!rule) {\n      throw new Error(\"Unexcepted null when object was expected as rule\");\n    }\n\n    if (typeof rule !== \"object\") {\n      throw new Error(\"Unexcepted \" + typeof rule + \" when object was expected as rule (\" + rule + \")\");\n    }\n\n    const newRule = {};\n    let useSource;\n    let resourceSource;\n    let condition;\n\n    const checkUseSource = newSource => {\n      if (useSource && useSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one result source (provided \" + newSource + \" and \" + useSource + \")\")));\n      }\n\n      useSource = newSource;\n    };\n\n    const checkResourceSource = newSource => {\n      if (resourceSource && resourceSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one resource source (provided \" + newSource + \" and \" + resourceSource + \")\")));\n      }\n\n      resourceSource = newSource;\n    };\n\n    if (rule.test || rule.include || rule.exclude) {\n      checkResourceSource(\"test + include + exclude\");\n      condition = {\n        test: rule.test,\n        include: rule.include,\n        exclude: rule.exclude\n      };\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(condition);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(condition, error));\n      }\n    }\n\n    if (rule.resource) {\n      checkResourceSource(\"resource\");\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(rule.resource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resource, error));\n      }\n    }\n\n    if (rule.realResource) {\n      try {\n        newRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n      }\n    }\n\n    if (rule.resourceQuery) {\n      try {\n        newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n      }\n    }\n\n    if (rule.compiler) {\n      try {\n        newRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n      }\n    }\n\n    if (rule.issuer) {\n      try {\n        newRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n      }\n    }\n\n    if (rule.loader && rule.loaders) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Provided loader and loaders for rule (use only one of them)\")));\n    }\n\n    const loader = rule.loaders || rule.loader;\n\n    if (typeof loader === \"string\" && !rule.options && !rule.query) {\n      checkUseSource(\"loader\");\n      newRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n    } else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n      checkUseSource(\"loader + options/query\");\n      newRule.use = RuleSet.normalizeUse({\n        loader: loader,\n        options: rule.options,\n        query: rule.query\n      }, ident);\n    } else if (loader && (rule.options || rule.query)) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query cannot be used with loaders (use options for each array item)\")));\n    } else if (loader) {\n      checkUseSource(\"loaders\");\n      newRule.use = RuleSet.normalizeUse(loader, ident);\n    } else if (rule.options || rule.query) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query provided without loader (use loader + options)\")));\n    }\n\n    if (rule.use) {\n      checkUseSource(\"use\");\n      newRule.use = RuleSet.normalizeUse(rule.use, ident);\n    }\n\n    if (rule.rules) {\n      newRule.rules = RuleSet.normalizeRules(rule.rules, refs, `${ident}-rules`);\n    }\n\n    if (rule.oneOf) {\n      newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, `${ident}-oneOf`);\n    }\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"resourceQuery\", \"compiler\", \"test\", \"include\", \"exclude\", \"issuer\", \"loader\", \"options\", \"query\", \"loaders\", \"use\", \"rules\", \"oneOf\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newRule[key] = rule[key];\n    }\n\n    if (Array.isArray(newRule.use)) {\n      for (const item of newRule.use) {\n        if (item.ident) {\n          refs[item.ident] = item.options;\n        }\n      }\n    }\n\n    return newRule;\n  }\n\n  static buildErrorMessage(condition, error) {\n    const conditionAsText = JSON.stringify(condition, (key, value) => {\n      return value === undefined ? \"undefined\" : value;\n    }, 2);\n    return error.message + \" in \" + conditionAsText;\n  }\n\n  static normalizeUse(use, ident) {\n    if (typeof use === \"function\") {\n      return data => RuleSet.normalizeUse(use(data), ident);\n    }\n\n    if (Array.isArray(use)) {\n      return use.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`)).reduce((arr, items) => arr.concat(items), []);\n    }\n\n    return [RuleSet.normalizeUseItem(use, ident)];\n  }\n\n  static normalizeUseItemString(useItemString) {\n    const idx = useItemString.indexOf(\"?\");\n\n    if (idx >= 0) {\n      return {\n        loader: useItemString.substr(0, idx),\n        options: useItemString.substr(idx + 1)\n      };\n    }\n\n    return {\n      loader: useItemString,\n      options: undefined\n    };\n  }\n\n  static normalizeUseItem(item, ident) {\n    if (typeof item === \"string\") {\n      return RuleSet.normalizeUseItemString(item);\n    }\n\n    const newItem = {};\n\n    if (item.options && item.query) {\n      throw new Error(\"Provided options and query in use\");\n    }\n\n    if (!item.loader) {\n      throw new Error(\"No loader specified\");\n    }\n\n    newItem.options = item.options || item.query;\n\n    if (typeof newItem.options === \"object\" && newItem.options) {\n      if (newItem.options.ident) {\n        newItem.ident = newItem.options.ident;\n      } else {\n        newItem.ident = ident;\n      }\n    }\n\n    const keys = Object.keys(item).filter(function (key) {\n      return ![\"options\", \"query\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newItem[key] = item[key];\n    }\n\n    return newItem;\n  }\n\n  static normalizeCondition(condition) {\n    if (!condition) throw new Error(\"Expected condition but got falsy value\");\n\n    if (typeof condition === \"string\") {\n      return str => str.indexOf(condition) === 0;\n    }\n\n    if (typeof condition === \"function\") {\n      return condition;\n    }\n\n    if (condition instanceof RegExp) {\n      return condition.test.bind(condition);\n    }\n\n    if (Array.isArray(condition)) {\n      const items = condition.map(c => RuleSet.normalizeCondition(c));\n      return orMatcher(items);\n    }\n\n    if (typeof condition !== \"object\") {\n      throw Error(\"Unexcepted \" + typeof condition + \" when condition was expected (\" + condition + \")\");\n    }\n\n    const matchers = [];\n    Object.keys(condition).forEach(key => {\n      const value = condition[key];\n\n      switch (key) {\n        case \"or\":\n        case \"include\":\n        case \"test\":\n          if (value) matchers.push(RuleSet.normalizeCondition(value));\n          break;\n\n        case \"and\":\n          if (value) {\n            const items = value.map(c => RuleSet.normalizeCondition(c));\n            matchers.push(andMatcher(items));\n          }\n\n          break;\n\n        case \"not\":\n        case \"exclude\":\n          if (value) {\n            const matcher = RuleSet.normalizeCondition(value);\n            matchers.push(notMatcher(matcher));\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unexcepted property \" + key + \" in condition\");\n      }\n    });\n\n    if (matchers.length === 0) {\n      throw new Error(\"Excepted condition but got \" + condition);\n    }\n\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return andMatcher(matchers);\n  }\n\n  exec(data) {\n    const result = [];\n\n    this._run(data, {\n      rules: this.rules\n    }, result);\n\n    return result;\n  }\n\n  _run(data, rule, result) {\n    // test conditions\n    if (rule.resource && !data.resource) return false;\n    if (rule.realResource && !data.realResource) return false;\n    if (rule.resourceQuery && !data.resourceQuery) return false;\n    if (rule.compiler && !data.compiler) return false;\n    if (rule.issuer && !data.issuer) return false;\n    if (rule.resource && !rule.resource(data.resource)) return false;\n    if (rule.realResource && !rule.realResource(data.realResource)) return false;\n    if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\n    if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {\n      return false;\n    }\n\n    if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n      return false;\n    } // apply\n\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"realResource\", \"resourceQuery\", \"compiler\", \"issuer\", \"rules\", \"oneOf\", \"use\", \"enforce\"].includes(key);\n    });\n\n    for (const key of keys) {\n      result.push({\n        type: key,\n        value: rule[key]\n      });\n    }\n\n    if (rule.use) {\n      const process = use => {\n        if (typeof use === \"function\") {\n          process(use(data));\n        } else if (Array.isArray(use)) {\n          use.forEach(process);\n        } else {\n          result.push({\n            type: \"use\",\n            value: use,\n            enforce: rule.enforce\n          });\n        }\n      };\n\n      process(rule.use);\n    }\n\n    if (rule.rules) {\n      for (let i = 0; i < rule.rules.length; i++) {\n        this._run(data, rule.rules[i], result);\n      }\n    }\n\n    if (rule.oneOf) {\n      for (let i = 0; i < rule.oneOf.length; i++) {\n        if (this._run(data, rule.oneOf[i], result)) break;\n      }\n    }\n\n    return true;\n  }\n\n  findOptionsByIdent(ident) {\n    const options = this.references[ident];\n\n    if (!options) {\n      throw new Error(\"Can't find options with ident '\" + ident + \"'\");\n    }\n\n    return options;\n  }\n\n};","map":{"version":3,"names":["notMatcher","matcher","str","orMatcher","items","i","length","andMatcher","module","exports","RuleSet","constructor","rules","references","Object","create","normalizeRules","refs","ident","Array","isArray","map","rule","idx","normalizeRule","use","loader","Error","newRule","useSource","resourceSource","condition","checkUseSource","newSource","buildErrorMessage","checkResourceSource","test","include","exclude","resource","normalizeCondition","error","realResource","resourceQuery","compiler","issuer","loaders","options","query","normalizeUse","split","oneOf","keys","filter","key","includes","item","conditionAsText","JSON","stringify","value","undefined","message","data","reduce","arr","concat","normalizeUseItem","normalizeUseItemString","useItemString","indexOf","substr","newItem","RegExp","bind","c","matchers","forEach","push","exec","result","_run","type","process","enforce","findOptionsByIdent"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/RuleSet.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\n\"use strict\";\n\nconst notMatcher = matcher => {\n\treturn str => {\n\t\treturn !matcher(str);\n\t};\n};\n\nconst orMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (items[i](str)) return true;\n\t\t}\n\t\treturn false;\n\t};\n};\n\nconst andMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (!items[i](str)) return false;\n\t\t}\n\t\treturn true;\n\t};\n};\n\nmodule.exports = class RuleSet {\n\tconstructor(rules) {\n\t\tthis.references = Object.create(null);\n\t\tthis.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n\t}\n\n\tstatic normalizeRules(rules, refs, ident) {\n\t\tif (Array.isArray(rules)) {\n\t\t\treturn rules.map((rule, idx) => {\n\t\t\t\treturn RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n\t\t\t});\n\t\t} else if (rules) {\n\t\t\treturn [RuleSet.normalizeRule(rules, refs, ident)];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tstatic normalizeRule(rule, refs, ident) {\n\t\tif (typeof rule === \"string\") {\n\t\t\treturn {\n\t\t\t\tuse: [\n\t\t\t\t\t{\n\t\t\t\t\t\tloader: rule\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t\tif (!rule) {\n\t\t\tthrow new Error(\"Unexcepted null when object was expected as rule\");\n\t\t}\n\t\tif (typeof rule !== \"object\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof rule +\n\t\t\t\t\t\" when object was expected as rule (\" +\n\t\t\t\t\trule +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst newRule = {};\n\t\tlet useSource;\n\t\tlet resourceSource;\n\t\tlet condition;\n\n\t\tconst checkUseSource = newSource => {\n\t\t\tif (useSource && useSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one result source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tuseSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tuseSource = newSource;\n\t\t};\n\n\t\tconst checkResourceSource = newSource => {\n\t\t\tif (resourceSource && resourceSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one resource source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tresourceSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tresourceSource = newSource;\n\t\t};\n\n\t\tif (rule.test || rule.include || rule.exclude) {\n\t\t\tcheckResourceSource(\"test + include + exclude\");\n\t\t\tcondition = {\n\t\t\t\ttest: rule.test,\n\t\t\t\tinclude: rule.include,\n\t\t\t\texclude: rule.exclude\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(condition);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(condition, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resource) {\n\t\t\tcheckResourceSource(\"resource\");\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(rule.resource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.realResource) {\n\t\t\ttry {\n\t\t\t\tnewRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resourceQuery) {\n\t\t\ttry {\n\t\t\t\tnewRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.compiler) {\n\t\t\ttry {\n\t\t\t\tnewRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.issuer) {\n\t\t\ttry {\n\t\t\t\tnewRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.loader && rule.loaders) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"Provided loader and loaders for rule (use only one of them)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst loader = rule.loaders || rule.loader;\n\t\tif (typeof loader === \"string\" && !rule.options && !rule.query) {\n\t\t\tcheckUseSource(\"loader\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n\t\t} else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n\t\t\tcheckUseSource(\"loader + options/query\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(\n\t\t\t\t{\n\t\t\t\t\tloader: loader,\n\t\t\t\t\toptions: rule.options,\n\t\t\t\t\tquery: rule.query\n\t\t\t\t},\n\t\t\t\tident\n\t\t\t);\n\t\t} else if (loader && (rule.options || rule.query)) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query cannot be used with loaders (use options for each array item)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t} else if (loader) {\n\t\t\tcheckUseSource(\"loaders\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader, ident);\n\t\t} else if (rule.options || rule.query) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query provided without loader (use loader + options)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tcheckUseSource(\"use\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(rule.use, ident);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tnewRule.rules = RuleSet.normalizeRules(\n\t\t\t\trule.rules,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-rules`\n\t\t\t);\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tnewRule.oneOf = RuleSet.normalizeRules(\n\t\t\t\trule.oneOf,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-oneOf`\n\t\t\t);\n\t\t}\n\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"test\",\n\t\t\t\t\"include\",\n\t\t\t\t\"exclude\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"loader\",\n\t\t\t\t\"options\",\n\t\t\t\t\"query\",\n\t\t\t\t\"loaders\",\n\t\t\t\t\"use\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tnewRule[key] = rule[key];\n\t\t}\n\n\t\tif (Array.isArray(newRule.use)) {\n\t\t\tfor (const item of newRule.use) {\n\t\t\t\tif (item.ident) {\n\t\t\t\t\trefs[item.ident] = item.options;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newRule;\n\t}\n\n\tstatic buildErrorMessage(condition, error) {\n\t\tconst conditionAsText = JSON.stringify(\n\t\t\tcondition,\n\t\t\t(key, value) => {\n\t\t\t\treturn value === undefined ? \"undefined\" : value;\n\t\t\t},\n\t\t\t2\n\t\t);\n\t\treturn error.message + \" in \" + conditionAsText;\n\t}\n\n\tstatic normalizeUse(use, ident) {\n\t\tif (typeof use === \"function\") {\n\t\t\treturn data => RuleSet.normalizeUse(use(data), ident);\n\t\t}\n\t\tif (Array.isArray(use)) {\n\t\t\treturn use\n\t\t\t\t.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`))\n\t\t\t\t.reduce((arr, items) => arr.concat(items), []);\n\t\t}\n\t\treturn [RuleSet.normalizeUseItem(use, ident)];\n\t}\n\n\tstatic normalizeUseItemString(useItemString) {\n\t\tconst idx = useItemString.indexOf(\"?\");\n\t\tif (idx >= 0) {\n\t\t\treturn {\n\t\t\t\tloader: useItemString.substr(0, idx),\n\t\t\t\toptions: useItemString.substr(idx + 1)\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tloader: useItemString,\n\t\t\toptions: undefined\n\t\t};\n\t}\n\n\tstatic normalizeUseItem(item, ident) {\n\t\tif (typeof item === \"string\") {\n\t\t\treturn RuleSet.normalizeUseItemString(item);\n\t\t}\n\n\t\tconst newItem = {};\n\n\t\tif (item.options && item.query) {\n\t\t\tthrow new Error(\"Provided options and query in use\");\n\t\t}\n\n\t\tif (!item.loader) {\n\t\t\tthrow new Error(\"No loader specified\");\n\t\t}\n\n\t\tnewItem.options = item.options || item.query;\n\n\t\tif (typeof newItem.options === \"object\" && newItem.options) {\n\t\t\tif (newItem.options.ident) {\n\t\t\t\tnewItem.ident = newItem.options.ident;\n\t\t\t} else {\n\t\t\t\tnewItem.ident = ident;\n\t\t\t}\n\t\t}\n\n\t\tconst keys = Object.keys(item).filter(function(key) {\n\t\t\treturn ![\"options\", \"query\"].includes(key);\n\t\t});\n\n\t\tfor (const key of keys) {\n\t\t\tnewItem[key] = item[key];\n\t\t}\n\n\t\treturn newItem;\n\t}\n\n\tstatic normalizeCondition(condition) {\n\t\tif (!condition) throw new Error(\"Expected condition but got falsy value\");\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn str => str.indexOf(condition) === 0;\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\treturn condition;\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn condition.test.bind(condition);\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map(c => RuleSet.normalizeCondition(c));\n\t\t\treturn orMatcher(items);\n\t\t}\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof condition +\n\t\t\t\t\t\" when condition was expected (\" +\n\t\t\t\t\tcondition +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst matchers = [];\n\t\tObject.keys(condition).forEach(key => {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\tcase \"include\":\n\t\t\t\tcase \"test\":\n\t\t\t\t\tif (value) matchers.push(RuleSet.normalizeCondition(value));\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst items = value.map(c => RuleSet.normalizeCondition(c));\n\t\t\t\t\t\tmatchers.push(andMatcher(items));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\tcase \"exclude\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = RuleSet.normalizeCondition(value);\n\t\t\t\t\t\tmatchers.push(notMatcher(matcher));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexcepted property \" + key + \" in condition\");\n\t\t\t}\n\t\t});\n\t\tif (matchers.length === 0) {\n\t\t\tthrow new Error(\"Excepted condition but got \" + condition);\n\t\t}\n\t\tif (matchers.length === 1) {\n\t\t\treturn matchers[0];\n\t\t}\n\t\treturn andMatcher(matchers);\n\t}\n\n\texec(data) {\n\t\tconst result = [];\n\t\tthis._run(\n\t\t\tdata,\n\t\t\t{\n\t\t\t\trules: this.rules\n\t\t\t},\n\t\t\tresult\n\t\t);\n\t\treturn result;\n\t}\n\n\t_run(data, rule, result) {\n\t\t// test conditions\n\t\tif (rule.resource && !data.resource) return false;\n\t\tif (rule.realResource && !data.realResource) return false;\n\t\tif (rule.resourceQuery && !data.resourceQuery) return false;\n\t\tif (rule.compiler && !data.compiler) return false;\n\t\tif (rule.issuer && !data.issuer) return false;\n\t\tif (rule.resource && !rule.resource(data.resource)) return false;\n\t\tif (rule.realResource && !rule.realResource(data.realResource))\n\t\t\treturn false;\n\t\tif (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\t\tif (\n\t\t\tdata.resourceQuery &&\n\t\t\trule.resourceQuery &&\n\t\t\t!rule.resourceQuery(data.resourceQuery)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// apply\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"realResource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\",\n\t\t\t\t\"use\",\n\t\t\t\t\"enforce\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tresult.push({\n\t\t\t\ttype: key,\n\t\t\t\tvalue: rule[key]\n\t\t\t});\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tconst process = use => {\n\t\t\t\tif (typeof use === \"function\") {\n\t\t\t\t\tprocess(use(data));\n\t\t\t\t} else if (Array.isArray(use)) {\n\t\t\t\t\tuse.forEach(process);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\ttype: \"use\",\n\t\t\t\t\t\tvalue: use,\n\t\t\t\t\t\tenforce: rule.enforce\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tprocess(rule.use);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tfor (let i = 0; i < rule.rules.length; i++) {\n\t\t\t\tthis._run(data, rule.rules[i], result);\n\t\t\t}\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tfor (let i = 0; i < rule.oneOf.length; i++) {\n\t\t\t\tif (this._run(data, rule.oneOf[i], result)) break;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfindOptionsByIdent(ident) {\n\t\tconst options = this.references[ident];\n\t\tif (!options) {\n\t\t\tthrow new Error(\"Can't find options with ident '\" + ident + \"'\");\n\t\t}\n\t\treturn options;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}