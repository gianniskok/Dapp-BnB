{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n/**\n * @template T\n * @template K\n * Multi layer bucket sorted set\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE)\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)\n * Supports popping the first items according to defined order\n * Supports iterating all items without order\n * Supports updating an item in an efficient way\n * Supports size property, which is the number of items\n * Items are lazy partially sorted when needed\n */\n\n\nclass LazyBucketSortedSet {\n  /**\n   * @param {function(T): K} getKey function to get key from item\n   * @param {function(K, K): number} comparator comparator to sort keys\n   * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n   */\n  constructor(getKey, comparator) {\n    this._getKey = getKey;\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    this._innerArgs = args;\n    this._leaf = args.length <= 1;\n    this._keys = new SortableSet(undefined, comparator);\n    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\n    this._map = new Map();\n    this._unsortedItems = new Set();\n    this.size = 0;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  add(item) {\n    this.size++;\n\n    this._unsortedItems.add(item);\n  }\n  /**\n   * @param {K} key key of item\n   * @param {T} item the item\n   * @returns {void}\n   */\n\n\n  _addInternal(key, item) {\n    let entry = this._map.get(key);\n\n    if (entry === undefined) {\n      entry = this._leaf ? new SortableSet(undefined, this._innerArgs[0]) : new\n      /** @type {any} */\n      LazyBucketSortedSet(...this._innerArgs);\n\n      this._keys.add(key);\n\n      this._map.set(key, entry);\n    }\n\n    entry.add(item);\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  delete(item) {\n    this.size--;\n\n    if (this._unsortedItems.has(item)) {\n      this._unsortedItems.delete(item);\n\n      return;\n    }\n\n    const key = this._getKey(item);\n\n    const entry = this._map.get(key);\n\n    entry.delete(item);\n\n    if (entry.size === 0) {\n      this._deleteKey(key);\n    }\n  }\n  /**\n   * @param {K} key key to be removed\n   * @returns {void}\n   */\n\n\n  _deleteKey(key) {\n    this._keys.delete(key);\n\n    this._map.delete(key);\n  }\n  /**\n   * @returns {T | undefined} an item\n   */\n\n\n  popFirst() {\n    if (this.size === 0) return undefined;\n    this.size--;\n\n    if (this._unsortedItems.size > 0) {\n      for (const item of this._unsortedItems) {\n        const key = this._getKey(item);\n\n        this._addInternal(key, item);\n      }\n\n      this._unsortedItems.clear();\n    }\n\n    this._keys.sort();\n\n    const key = this._keys.values().next().value;\n\n    const entry = this._map.get(key);\n\n    if (this._leaf) {\n      const leafEntry =\n      /** @type {SortableSet<T>} */\n      entry;\n      leafEntry.sort();\n      const item = leafEntry.values().next().value;\n      leafEntry.delete(item);\n\n      if (leafEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    } else {\n      const nodeEntry =\n      /** @type {LazyBucketSortedSet<T, any>} */\n      entry;\n      const item = nodeEntry.popFirst();\n\n      if (nodeEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    }\n  }\n  /**\n   * @param {T} item to be updated item\n   * @returns {function(true=): void} finish update\n   */\n\n\n  startUpdate(item) {\n    if (this._unsortedItems.has(item)) {\n      return remove => {\n        if (remove) {\n          this._unsortedItems.delete(item);\n\n          this.size--;\n          return;\n        }\n      };\n    }\n\n    const key = this._getKey(item);\n\n    if (this._leaf) {\n      const oldEntry =\n      /** @type {SortableSet<T>} */\n      this._map.get(key);\n\n      return remove => {\n        if (remove) {\n          this.size--;\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          // This flags the sortable set as unordered\n          oldEntry.add(item);\n        } else {\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    } else {\n      const oldEntry =\n      /** @type {LazyBucketSortedSet<T, any>} */\n      this._map.get(key);\n\n      const finishUpdate = oldEntry.startUpdate(item);\n      return remove => {\n        if (remove) {\n          this.size--;\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          finishUpdate();\n        } else {\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    }\n  }\n  /**\n   * @param {Iterator<T>[]} iterators list of iterators to append to\n   * @returns {void}\n   */\n\n\n  _appendIterators(iterators) {\n    if (this._unsortedItems.size > 0) iterators.push(this._unsortedItems[Symbol.iterator]());\n\n    for (const key of this._keys) {\n      const entry = this._map.get(key);\n\n      if (this._leaf) {\n        const leafEntry =\n        /** @type {SortableSet<T>} */\n        entry;\n        const iterator = leafEntry[Symbol.iterator]();\n        iterators.push(iterator);\n      } else {\n        const nodeEntry =\n        /** @type {LazyBucketSortedSet<T, any>} */\n        entry;\n\n        nodeEntry._appendIterators(iterators);\n      }\n    }\n  }\n  /**\n   * @returns {Iterator<T>} the iterator\n   */\n\n\n  [Symbol.iterator]() {\n    const iterators = [];\n\n    this._appendIterators(iterators);\n\n    iterators.reverse();\n    let currentIterator = iterators.pop();\n    return {\n      next: () => {\n        const res = currentIterator.next();\n\n        if (res.done) {\n          if (iterators.length === 0) return res;\n          currentIterator = iterators.pop();\n          return currentIterator.next();\n        }\n\n        return res;\n      }\n    };\n  }\n\n}\n\nmodule.exports = LazyBucketSortedSet;","map":{"version":3,"names":["SortableSet","require","LazyBucketSortedSet","constructor","getKey","comparator","_getKey","args","_innerArgs","_leaf","length","_keys","undefined","_map","Map","_unsortedItems","Set","size","add","item","_addInternal","key","entry","get","set","delete","has","_deleteKey","popFirst","clear","sort","values","next","value","leafEntry","nodeEntry","startUpdate","remove","oldEntry","newKey","finishUpdate","_appendIterators","iterators","push","Symbol","iterator","reverse","currentIterator","pop","res","done","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/util/LazyBucketSortedSet.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/**\n * @template T\n * @template K\n * Multi layer bucket sorted set\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE)\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)\n * Supports popping the first items according to defined order\n * Supports iterating all items without order\n * Supports updating an item in an efficient way\n * Supports size property, which is the number of items\n * Items are lazy partially sorted when needed\n */\nclass LazyBucketSortedSet {\n\t/**\n\t * @param {function(T): K} getKey function to get key from item\n\t * @param {function(K, K): number} comparator comparator to sort keys\n\t * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n\t */\n\tconstructor(getKey, comparator, ...args) {\n\t\tthis._getKey = getKey;\n\t\tthis._innerArgs = args;\n\t\tthis._leaf = args.length <= 1;\n\t\tthis._keys = new SortableSet(undefined, comparator);\n\t\t/** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\t\tthis._map = new Map();\n\t\tthis._unsortedItems = new Set();\n\t\tthis.size = 0;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tadd(item) {\n\t\tthis.size++;\n\t\tthis._unsortedItems.add(item);\n\t}\n\n\t/**\n\t * @param {K} key key of item\n\t * @param {T} item the item\n\t * @returns {void}\n\t */\n\t_addInternal(key, item) {\n\t\tlet entry = this._map.get(key);\n\t\tif (entry === undefined) {\n\t\t\tentry = this._leaf\n\t\t\t\t? new SortableSet(undefined, this._innerArgs[0])\n\t\t\t\t: new /** @type {any} */ (LazyBucketSortedSet)(...this._innerArgs);\n\t\t\tthis._keys.add(key);\n\t\t\tthis._map.set(key, entry);\n\t\t}\n\t\tentry.add(item);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tthis.size--;\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\tthis._unsortedItems.delete(item);\n\t\t\treturn;\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._map.get(key);\n\t\tentry.delete(item);\n\t\tif (entry.size === 0) {\n\t\t\tthis._deleteKey(key);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} key key to be removed\n\t * @returns {void}\n\t */\n\t_deleteKey(key) {\n\t\tthis._keys.delete(key);\n\t\tthis._map.delete(key);\n\t}\n\n\t/**\n\t * @returns {T | undefined} an item\n\t */\n\tpopFirst() {\n\t\tif (this.size === 0) return undefined;\n\t\tthis.size--;\n\t\tif (this._unsortedItems.size > 0) {\n\t\t\tfor (const item of this._unsortedItems) {\n\t\t\t\tconst key = this._getKey(item);\n\t\t\t\tthis._addInternal(key, item);\n\t\t\t}\n\t\t\tthis._unsortedItems.clear();\n\t\t}\n\t\tthis._keys.sort();\n\t\tconst key = this._keys.values().next().value;\n\t\tconst entry = this._map.get(key);\n\t\tif (this._leaf) {\n\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\tleafEntry.sort();\n\t\t\tconst item = leafEntry.values().next().value;\n\t\t\tleafEntry.delete(item);\n\t\t\tif (leafEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t} else {\n\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\tconst item = nodeEntry.popFirst();\n\t\t\tif (nodeEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t}\n\n\t/**\n\t * @param {T} item to be updated item\n\t * @returns {function(true=): void} finish update\n\t */\n\tstartUpdate(item) {\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis._unsortedItems.delete(item);\n\t\t\t\t\tthis.size--;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tif (this._leaf) {\n\t\t\tconst oldEntry = /** @type {SortableSet<T>} */ (this._map.get(key));\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\t// This flags the sortable set as unordered\n\t\t\t\t\toldEntry.add(item);\n\t\t\t\t} else {\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tconst oldEntry = /** @type {LazyBucketSortedSet<T, any>} */ (this._map.get(\n\t\t\t\tkey\n\t\t\t));\n\t\t\tconst finishUpdate = oldEntry.startUpdate(item);\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\tfinishUpdate();\n\t\t\t\t} else {\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Iterator<T>[]} iterators list of iterators to append to\n\t * @returns {void}\n\t */\n\t_appendIterators(iterators) {\n\t\tif (this._unsortedItems.size > 0)\n\t\t\titerators.push(this._unsortedItems[Symbol.iterator]());\n\t\tfor (const key of this._keys) {\n\t\t\tconst entry = this._map.get(key);\n\t\t\tif (this._leaf) {\n\t\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\t\tconst iterator = leafEntry[Symbol.iterator]();\n\t\t\t\titerators.push(iterator);\n\t\t\t} else {\n\t\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\t\tnodeEntry._appendIterators(iterators);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Iterator<T>} the iterator\n\t */\n\t[Symbol.iterator]() {\n\t\tconst iterators = [];\n\t\tthis._appendIterators(iterators);\n\t\titerators.reverse();\n\t\tlet currentIterator = iterators.pop();\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\tconst res = currentIterator.next();\n\t\t\t\tif (res.done) {\n\t\t\t\t\tif (iterators.length === 0) return res;\n\t\t\t\t\tcurrentIterator = iterators.pop();\n\t\t\t\t\treturn currentIterator.next();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = LazyBucketSortedSet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}