{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n  return module => {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\n\nconst isNotAEntryModule = entryModule => {\n  return module => {\n    return entryModule !== module;\n  };\n};\n\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", chunks => {\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n\n        for (const m of compilation.modules) {\n          const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        } // Check used chunk ids\n\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          } // Get module objects from names\n\n\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name)); // Does the modules exist at all?\n\n          if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n          const size = selectedModules.reduce((sum, m) => sum + m.size(), 0);\n          if (size !== splitData.size) return false; // get chunks with all modules\n\n          const selectedChunks = intersect(selectedModules.map(m => new Set(m.chunksIterable))); // No relevant chunks found\n\n          if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n          if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          } // split the chunk into two parts\n\n\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n          }\n\n          return true;\n        }; // try to restore to recorded splitting\n\n\n        let changed = false;\n\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        } // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n\n\n        const sortedChunks = chunks.slice().sort((a, b) => {\n          const diff1 = b.modulesSize() - a.modulesSize();\n          if (diff1) return diff1;\n          const diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n          if (diff2) return diff2;\n          const modulesA = Array.from(a.modulesIterable);\n          const modulesB = Array.from(b.modulesIterable);\n          modulesA.sort();\n          modulesB.sort();\n          const aI = modulesA[Symbol.iterator]();\n          const bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n          while (true) {\n            const aItem = aI.next();\n            const bItem = bI.next();\n            if (aItem.done) return 0;\n            const aModuleIdentifier = aItem.value.identifier();\n            const bModuleIdentifier = bItem.value.identifier();\n            if (aModuleIdentifier > bModuleIdentifier) return -1;\n            if (aModuleIdentifier < bModuleIdentifier) return 1;\n          }\n        });\n\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunk.modulesSize();\n\n          if (size > maxSize && chunk.getNumberOfModules() > 1) {\n            const modules = chunk.getModules().filter(isNotAEntryModule(chunk.entryModule)).sort((a, b) => {\n              a = a.identifier();\n              b = b.identifier();\n              if (a > b) return 1;\n              if (a < b) return -1;\n              return 0;\n            });\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set(); // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData); // set flag for stats\n\n              chunk.recorded = true;\n            }\n          } // Also add all unused historial splits (after the used ones)\n          // They can still be used in some future compilation\n\n\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          } // record all splits\n\n\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["identifierUtils","require","intersect","validateOptions","schema","moveModuleBetween","oldChunk","newChunk","module","moveModule","isNotAEntryModule","entryModule","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunksAdvanced","chunks","nameToModuleMap","moduleToNameMap","m","modules","name","makePathsRelative","context","identifier","cache","set","usedIds","chunk","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","reduce","sum","selectedChunks","chunksIterable","Array","from","getNumberOfModules","length","addChunk","chunkReason","forEach","split","changed","j","sortedChunks","slice","sort","a","b","diff1","modulesSize","diff2","modulesA","modulesIterable","modulesB","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","getModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","recorded","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n\treturn module => {\n\t\toldChunk.moveModule(module, newChunk);\n\t};\n};\n\nconst isNotAEntryModule = entryModule => {\n\treturn module => {\n\t\treturn entryModule !== module;\n\t};\n};\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Aggressive Splitting Plugin\");\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tm.identifier(),\n\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tconst size = selectedModules.reduce(\n\t\t\t\t\t\t\t\t(sum, m) => sum + m.size(),\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(m => new Set(m.chunksIterable))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0].getNumberOfModules() ===\n\t\t\t\t\t\t\t\t\tselectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(moveModuleBetween(chunk, newChunk));\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst sortedChunks = chunks.slice().sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 = b.modulesSize() - a.modulesSize();\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\tconst modulesA = Array.from(a.modulesIterable);\n\t\t\t\t\t\t\tconst modulesB = Array.from(b.modulesIterable);\n\t\t\t\t\t\t\tmodulesA.sort();\n\t\t\t\t\t\t\tmodulesB.sort();\n\t\t\t\t\t\t\tconst aI = modulesA[Symbol.iterator]();\n\t\t\t\t\t\t\tconst bI = modulesB[Symbol.iterator]();\n\t\t\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst aItem = aI.next();\n\t\t\t\t\t\t\t\tconst bItem = bI.next();\n\t\t\t\t\t\t\t\tif (aItem.done) return 0;\n\t\t\t\t\t\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\t\t\t\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\t\t\t\t\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\t\t\t\t\t\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunk.modulesSize();\n\t\t\t\t\t\t\tif (size > maxSize && chunk.getNumberOfModules() > 1) {\n\t\t\t\t\t\t\t\tconst modules = chunk\n\t\t\t\t\t\t\t\t\t.getModules()\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunk.entryModule))\n\t\t\t\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t\t\t\ta = a.identifier();\n\t\t\t\t\t\t\t\t\t\tb = b.identifier();\n\t\t\t\t\t\t\t\t\t\tif (a > b) return 1;\n\t\t\t\t\t\t\t\t\t\tif (a < b) return -1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\tchunk.recorded = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historial splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}