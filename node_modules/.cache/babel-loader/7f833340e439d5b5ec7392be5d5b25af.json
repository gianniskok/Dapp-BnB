{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function (sourceNode, sourceMapConsumer, sourceFile, removeGeneratedCodeForSourceFile) {\n  // The following notations are used to name stuff:\n  // Left <------------> Middle <-------------------> Right\n  // Input arguments:\n  //        sourceNode                                       - Code mapping from Left to Middle\n  //                   sourceFile                            - Name of a Middle file\n  //                              sourceMapConsumer          - Code mapping from Middle to Right\n  // Variables:\n  //           l2m                      m2r\n  // Left <-----------------------------------------> Right\n  // Variables:\n  //                       l2r\n  var l2rResult = new SourceNode();\n  var l2rOutput = [];\n  var middleSourceContents = {};\n  var m2rMappingsByLine = {};\n  var rightSourceContentsSet = {};\n  var rightSourceContentsLines = {}; // Store all mappings by generated line\n\n  sourceMapConsumer.eachMapping(function (mapping) {\n    (m2rMappingsByLine[mapping.generatedLine] = m2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n  }, null, SourceMapConsumer.GENERATED_ORDER); // Store all source contents\n\n  sourceNode.walkSourceContents(function (source, content) {\n    middleSourceContents[\"$\" + source] = content;\n  });\n  var middleSource = middleSourceContents[\"$\" + sourceFile];\n  var middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined; // Walk all left to middle mappings\n\n  sourceNode.walk(function (chunk, middleMapping) {\n    var source; // Find a mapping from middle to right\n\n    if (middleMapping.source === sourceFile && middleMapping.line && m2rMappingsByLine[middleMapping.line]) {\n      var m2rBestFit;\n      var m2rMappings = m2rMappingsByLine[middleMapping.line]; // Note: if this becomes a performance problem, use binary search\n\n      for (var i = 0; i < m2rMappings.length; i++) {\n        if (m2rMappings[i].generatedColumn <= middleMapping.column) {\n          m2rBestFit = m2rMappings[i];\n        }\n      }\n\n      if (m2rBestFit) {\n        var allowMiddleName = false;\n        var middleLine;\n        var rightSourceContent;\n        var rightSourceContentLines;\n        var rightSource = m2rBestFit.source; // Check if we have middle and right source for this mapping\n        // Then we could have an \"identify\" mapping\n\n        if (middleSourceLines && rightSource && (middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) && ((rightSourceContentLines = rightSourceContentsLines[rightSource]) || (rightSourceContent = sourceMapConsumer.sourceContentFor(rightSource, true)))) {\n          if (!rightSourceContentLines) {\n            rightSourceContentLines = rightSourceContentsLines[rightSource] = rightSourceContent.split(\"\\n\");\n          }\n\n          var rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\n          if (rightLine) {\n            var offset = middleMapping.column - m2rBestFit.generatedColumn;\n\n            if (offset > 0) {\n              var middlePart = middleLine.slice(m2rBestFit.generatedColumn, middleMapping.column);\n              var rightPart = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + offset);\n\n              if (middlePart === rightPart) {\n                // When original and generated code is equal we assume we have an \"identity\" mapping\n                // In this case we can offset the original position\n                m2rBestFit = Object.assign({}, m2rBestFit, {\n                  originalColumn: m2rBestFit.originalColumn + offset,\n                  generatedColumn: middleMapping.column\n                });\n              }\n            }\n\n            if (!m2rBestFit.name && middleMapping.name) {\n              allowMiddleName = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + middleMapping.name.length) === middleMapping.name;\n            }\n          }\n        } // Construct a left to right node from the found middle to right mapping\n\n\n        source = m2rBestFit.source;\n        l2rOutput.push(new SourceNode(m2rBestFit.originalLine, m2rBestFit.originalColumn, source, chunk, allowMiddleName ? middleMapping.name : m2rBestFit.name)); // Set the source contents once\n\n        if (!(\"$\" + source in rightSourceContentsSet)) {\n          rightSourceContentsSet[\"$\" + source] = true;\n          var sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\n          if (sourceContent) {\n            l2rResult.setSourceContent(source, sourceContent);\n          }\n        }\n\n        return;\n      }\n    }\n\n    if (removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile || !middleMapping.source) {\n      // Construct a left to middle node with only generated code\n      // Because user do not want mappings to middle sources\n      // Or this chunk has no mapping\n      l2rOutput.push(chunk);\n      return;\n    } // Construct a left to middle node\n\n\n    source = middleMapping.source;\n    l2rOutput.push(new SourceNode(middleMapping.line, middleMapping.column, source, chunk, middleMapping.name));\n\n    if (\"$\" + source in middleSourceContents) {\n      if (!(\"$\" + source in rightSourceContentsSet)) {\n        l2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n        delete middleSourceContents[\"$\" + source];\n      }\n    }\n  }); // Put output into the resulting SourceNode\n\n  l2rResult.add(l2rOutput);\n  return l2rResult;\n};\n\nmodule.exports = applySourceMap;","map":{"version":3,"names":["SourceNode","require","SourceMapConsumer","applySourceMap","sourceNode","sourceMapConsumer","sourceFile","removeGeneratedCodeForSourceFile","l2rResult","l2rOutput","middleSourceContents","m2rMappingsByLine","rightSourceContentsSet","rightSourceContentsLines","eachMapping","mapping","generatedLine","push","GENERATED_ORDER","walkSourceContents","source","content","middleSource","middleSourceLines","split","undefined","walk","chunk","middleMapping","line","m2rBestFit","m2rMappings","i","length","generatedColumn","column","allowMiddleName","middleLine","rightSourceContent","rightSourceContentLines","rightSource","sourceContentFor","rightLine","originalLine","offset","middlePart","slice","rightPart","originalColumn","Object","assign","name","sourceContent","setSourceContent","add","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack-sources/lib/applySourceMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function(\n\tsourceNode,\n\tsourceMapConsumer,\n\tsourceFile,\n\tremoveGeneratedCodeForSourceFile\n) {\n\t// The following notations are used to name stuff:\n\t// Left <------------> Middle <-------------------> Right\n\t// Input arguments:\n\t//        sourceNode                                       - Code mapping from Left to Middle\n\t//                   sourceFile                            - Name of a Middle file\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\n\t// Variables:\n\t//           l2m                      m2r\n\t// Left <-----------------------------------------> Right\n\t// Variables:\n\t//                       l2r\n\n\tvar l2rResult = new SourceNode();\n\tvar l2rOutput = [];\n\n\tvar middleSourceContents = {};\n\n\tvar m2rMappingsByLine = {};\n\n\tvar rightSourceContentsSet = {};\n\tvar rightSourceContentsLines = {};\n\n\t// Store all mappings by generated line\n\tsourceMapConsumer.eachMapping(\n\t\tfunction(mapping) {\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n\t\t},\n\t\tnull,\n\t\tSourceMapConsumer.GENERATED_ORDER\n\t);\n\n\t// Store all source contents\n\tsourceNode.walkSourceContents(function(source, content) {\n\t\tmiddleSourceContents[\"$\" + source] = content;\n\t});\n\n\tvar middleSource = middleSourceContents[\"$\" + sourceFile];\n\tvar middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n\t// Walk all left to middle mappings\n\tsourceNode.walk(function(chunk, middleMapping) {\n\t\tvar source;\n\n\t\t// Find a mapping from middle to right\n\t\tif(\n\t\t\tmiddleMapping.source === sourceFile &&\n\t\t\tmiddleMapping.line &&\n\t\t\tm2rMappingsByLine[middleMapping.line]\n\t\t) {\n\t\t\tvar m2rBestFit;\n\t\t\tvar m2rMappings = m2rMappingsByLine[middleMapping.line];\n\t\t\t// Note: if this becomes a performance problem, use binary search\n\t\t\tfor(var i = 0; i < m2rMappings.length; i++) {\n\t\t\t\tif(m2rMappings[i].generatedColumn <= middleMapping.column) {\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m2rBestFit) {\n\t\t\t\tvar allowMiddleName = false;\n\t\t\t\tvar middleLine;\n\t\t\t\tvar rightSourceContent;\n\t\t\t\tvar rightSourceContentLines;\n\t\t\t\tvar rightSource = m2rBestFit.source;\n\t\t\t\t// Check if we have middle and right source for this mapping\n\t\t\t\t// Then we could have an \"identify\" mapping\n\t\t\t\tif(\n\t\t\t\t\tmiddleSourceLines &&\n\t\t\t\t\trightSource &&\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\trightSource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)))\n\t\t\t\t) {\n\t\t\t\t\tif(!rightSourceContentLines) {\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\n\t\t\t\t\t\t\trightSource\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tvar rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\t\t\t\t\tif(rightLine) {\n\t\t\t\t\t\tvar offset = middleMapping.column - m2rBestFit.generatedColumn;\n\t\t\t\t\t\tif(offset > 0) {\n\t\t\t\t\t\t\tvar middlePart = middleLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\n\t\t\t\t\t\t\t\tmiddleMapping.column\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvar rightPart = rightLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(middlePart === rightPart) {\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!m2rBestFit.name && middleMapping.name) {\n\t\t\t\t\t\t\tallowMiddleName =\n\t\t\t\t\t\t\t\trightLine.slice(\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\n\t\t\t\t\t\t\t\t) === middleMapping.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\n\t\t\t\tsource = m2rBestFit.source;\n\t\t\t\tl2rOutput.push(\n\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\tm2rBestFit.originalLine,\n\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Set the source contents once\n\t\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\n\t\t\t\t\tvar sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\t\t\t\t\tif(sourceContent) {\n\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif((removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile) || !middleMapping.source) {\n\t\t\t// Construct a left to middle node with only generated code\n\t\t\t// Because user do not want mappings to middle sources\n\t\t\t// Or this chunk has no mapping\n\t\t\tl2rOutput.push(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\t// Construct a left to middle node\n\t\tsource = middleMapping.source;\n\t\tl2rOutput.push(\n\t\t\tnew SourceNode(\n\t\t\t\tmiddleMapping.line,\n\t\t\t\tmiddleMapping.column,\n\t\t\t\tsource,\n\t\t\t\tchunk,\n\t\t\t\tmiddleMapping.name\n\t\t\t)\n\t\t);\n\t\tif(\"$\" + source in middleSourceContents) {\n\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Put output into the resulting SourceNode\n\tl2rResult.add(l2rOutput);\n\treturn l2rResult;\n};\n\nmodule.exports = applySourceMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}