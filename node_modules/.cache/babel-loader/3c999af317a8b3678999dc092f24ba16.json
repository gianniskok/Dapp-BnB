{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\n\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\n\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\n\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\n\n\nconst getMappingFromInfo = (info, exportName) => {\n  const staticMappings = info.static.get(exportName);\n\n  if (staticMappings !== undefined) {\n    if (staticMappings.length === 1) return staticMappings[0];\n    return undefined;\n  }\n\n  const dynamicMappings = Array.from(info.dynamic).filter(_ref => {\n    let [_, ignored] = _ref;\n    return !ignored.has(exportName);\n  });\n\n  if (dynamicMappings.length === 1) {\n    return {\n      module: dynamicMappings[0][0],\n      exportName,\n      checked: true\n    };\n  }\n\n  return undefined;\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\n\n\nconst addStaticReexport = (info, exportName, module, innerExportName, checked) => {\n  let mappings = info.static.get(exportName);\n\n  if (mappings !== undefined) {\n    for (const mapping of mappings) {\n      if (mapping.module === module && mapping.exportName === innerExportName) {\n        mapping.checked = mapping.checked && checked;\n        return;\n      }\n    }\n  } else {\n    mappings = [];\n    info.static.set(exportName, mappings);\n  }\n\n  mappings.push({\n    module,\n    exportName: innerExportName,\n    checked\n  });\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\n\n\nconst addDynamicReexport = (info, module, ignored) => {\n  const existingList = info.dynamic.get(module);\n\n  if (existingList !== undefined) {\n    for (const key of existingList) {\n      if (!ignored.has(key)) existingList.delete(key);\n    }\n  } else {\n    info.dynamic.set(module, new Set(ignored));\n  }\n};\n\nclass SideEffectsFlagPlugin {\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n\n          if (!hasSideEffects) {\n            module.factoryMeta.sideEffectFree = true;\n          }\n        }\n\n        return module;\n      });\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (data.settings.sideEffects === false) {\n          module.factoryMeta.sideEffectFree = true;\n        } else if (data.settings.sideEffects === true) {\n          module.factoryMeta.sideEffectFree = false;\n        }\n      });\n    });\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", modules => {\n        /** @type {Map<Module, ReexportInfo>} */\n        const reexportMaps = new Map(); // Capture reexports of sideEffectFree modules\n\n        for (const module of modules) {\n          /** @type {Dependency[]} */\n          const removeDependencies = [];\n\n          for (const dep of module.dependencies) {\n            if (dep instanceof HarmonyImportSideEffectDependency) {\n              if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                removeDependencies.push(dep);\n              }\n            } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n              if (module.factoryMeta.sideEffectFree) {\n                const mode = dep.getMode(true);\n\n                if (mode.type === \"safe-reexport\" || mode.type === \"checked-reexport\" || mode.type === \"dynamic-reexport\" || mode.type === \"reexport-non-harmony-default\" || mode.type === \"reexport-non-harmony-default-strict\" || mode.type === \"reexport-named-default\") {\n                  let info = reexportMaps.get(module);\n\n                  if (!info) {\n                    reexportMaps.set(module, info = {\n                      static: new Map(),\n                      dynamic: new Map()\n                    });\n                  }\n\n                  const targetModule = dep._module;\n\n                  switch (mode.type) {\n                    case \"safe-reexport\":\n                      for (const [key, id] of mode.map) {\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, false);\n                        }\n                      }\n\n                      break;\n\n                    case \"checked-reexport\":\n                      for (const [key, id] of mode.map) {\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, true);\n                        }\n                      }\n\n                      break;\n\n                    case \"dynamic-reexport\":\n                      addDynamicReexport(info, targetModule, mode.ignored);\n                      break;\n\n                    case \"reexport-non-harmony-default\":\n                    case \"reexport-non-harmony-default-strict\":\n                    case \"reexport-named-default\":\n                      addStaticReexport(info, mode.name, targetModule, \"default\", false);\n                      break;\n                  }\n                }\n              }\n            }\n          }\n        } // Flatten reexports\n\n\n        for (const info of reexportMaps.values()) {\n          const dynamicReexports = info.dynamic;\n          info.dynamic = new Map();\n\n          for (const reexport of dynamicReexports) {\n            let [targetModule, ignored] = reexport;\n\n            for (;;) {\n              const innerInfo = reexportMaps.get(targetModule);\n              if (!innerInfo) break;\n\n              for (const [key, reexports] of innerInfo.static) {\n                if (ignored.has(key)) continue;\n\n                for (const {\n                  module,\n                  exportName,\n                  checked\n                } of reexports) {\n                  addStaticReexport(info, key, module, exportName, checked);\n                }\n              } // Follow dynamic reexport if there is only one\n\n\n              if (innerInfo.dynamic.size !== 1) {\n                // When there are more then one, we don't know which one\n                break;\n              }\n\n              ignored = new Set(ignored);\n\n              for (const [innerModule, innerIgnored] of innerInfo.dynamic) {\n                for (const key of innerIgnored) {\n                  if (ignored.has(key)) continue; // This reexports ends here\n\n                  addStaticReexport(info, key, targetModule, key, true);\n                  ignored.add(key);\n                }\n\n                targetModule = innerModule;\n              }\n            } // Update reexport as all other cases has been handled\n\n\n            addDynamicReexport(info, targetModule, ignored);\n          }\n        }\n\n        for (const info of reexportMaps.values()) {\n          const staticReexports = info.static;\n          info.static = new Map();\n\n          for (const [key, reexports] of staticReexports) {\n            for (let mapping of reexports) {\n              for (;;) {\n                const innerInfo = reexportMaps.get(mapping.module);\n                if (!innerInfo) break;\n                const newMapping = getMappingFromInfo(innerInfo, mapping.exportName);\n                if (!newMapping) break;\n                mapping = newMapping;\n              }\n\n              addStaticReexport(info, key, mapping.module, mapping.exportName, mapping.checked);\n            }\n          }\n        } // Update imports along the reexports from sideEffectFree modules\n\n\n        for (const pair of reexportMaps) {\n          const module = pair[0];\n          const info = pair[1];\n          let newReasons = undefined;\n\n          for (let i = 0; i < module.reasons.length; i++) {\n            const reason = module.reasons[i];\n            const dep = reason.dependency;\n\n            if ((dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) && dep._id) {\n              const mapping = getMappingFromInfo(info, dep._id);\n\n              if (mapping) {\n                dep.redirectedModule = mapping.module;\n                dep.redirectedId = mapping.exportName;\n                mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\"); // removing the currect reason, by not adding it to the newReasons array\n                // lazily create the newReasons array\n\n                if (newReasons === undefined) {\n                  newReasons = i === 0 ? [] : module.reasons.slice(0, i);\n                }\n\n                continue;\n              }\n            }\n\n            if (newReasons !== undefined) newReasons.push(reason);\n          }\n\n          if (newReasons !== undefined) {\n            module.reasons = newReasons;\n          }\n        }\n      });\n    });\n  }\n\n  static moduleHasSideEffects(moduleName, flagValue) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n\n      case \"boolean\":\n        return flagValue;\n\n      case \"string\":\n        if (process.platform === \"win32\") {\n          flagValue = flagValue.replace(/\\\\/g, \"/\");\n        }\n\n        return mm.isMatch(moduleName, flagValue, {\n          matchBase: true\n        });\n\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));\n    }\n  }\n\n}\n\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"names":["mm","require","HarmonyExportImportedSpecifierDependency","HarmonyImportSideEffectDependency","HarmonyImportSpecifierDependency","getMappingFromInfo","info","exportName","staticMappings","static","get","undefined","length","dynamicMappings","Array","from","dynamic","filter","_","ignored","has","module","checked","addStaticReexport","innerExportName","mappings","mapping","set","push","addDynamicReexport","existingList","key","delete","Set","SideEffectsFlagPlugin","apply","compiler","hooks","normalModuleFactory","tap","nmf","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","hasSideEffects","moduleHasSideEffects","factoryMeta","sideEffectFree","settings","compilation","optimizeDependencies","modules","reexportMaps","Map","removeDependencies","dep","dependencies","mode","getMode","type","targetModule","_module","id","map","name","values","dynamicReexports","reexport","innerInfo","reexports","size","innerModule","innerIgnored","add","staticReexports","newMapping","pair","newReasons","i","reasons","reason","dependency","namespaceObjectAsContext","_id","redirectedModule","redirectedId","addReason","explanation","slice","moduleName","flagValue","process","platform","replace","isMatch","matchBase","some","glob","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\nconst getMappingFromInfo = (info, exportName) => {\n\tconst staticMappings = info.static.get(exportName);\n\tif (staticMappings !== undefined) {\n\t\tif (staticMappings.length === 1) return staticMappings[0];\n\t\treturn undefined;\n\t}\n\tconst dynamicMappings = Array.from(info.dynamic).filter(\n\t\t([_, ignored]) => !ignored.has(exportName)\n\t);\n\tif (dynamicMappings.length === 1) {\n\t\treturn {\n\t\t\tmodule: dynamicMappings[0][0],\n\t\t\texportName,\n\t\t\tchecked: true\n\t\t};\n\t}\n\treturn undefined;\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\nconst addStaticReexport = (\n\tinfo,\n\texportName,\n\tmodule,\n\tinnerExportName,\n\tchecked\n) => {\n\tlet mappings = info.static.get(exportName);\n\tif (mappings !== undefined) {\n\t\tfor (const mapping of mappings) {\n\t\t\tif (mapping.module === module && mapping.exportName === innerExportName) {\n\t\t\t\tmapping.checked = mapping.checked && checked;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmappings = [];\n\t\tinfo.static.set(exportName, mappings);\n\t}\n\tmappings.push({\n\t\tmodule,\n\t\texportName: innerExportName,\n\t\tchecked\n\t});\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\nconst addDynamicReexport = (info, module, ignored) => {\n\tconst existingList = info.dynamic.get(module);\n\tif (existingList !== undefined) {\n\t\tfor (const key of existingList) {\n\t\t\tif (!ignored.has(key)) existingList.delete(key);\n\t\t}\n\t} else {\n\t\tinfo.dynamic.set(module, new Set(ignored));\n\t}\n};\n\nclass SideEffectsFlagPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\tif (\n\t\t\t\t\tresolveData &&\n\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\tresolveData.relativePath\n\t\t\t\t) {\n\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\tsideEffects\n\t\t\t\t\t);\n\t\t\t\t\tif (!hasSideEffects) {\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t});\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tif (data.settings.sideEffects === false) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t} else if (data.settings.sideEffects === true) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tcompiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\t/** @type {Map<Module, ReexportInfo>} */\n\t\t\t\t\tconst reexportMaps = new Map();\n\n\t\t\t\t\t// Capture reexports of sideEffectFree modules\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t/** @type {Dependency[]} */\n\t\t\t\t\t\tconst removeDependencies = [];\n\t\t\t\t\t\tfor (const dep of module.dependencies) {\n\t\t\t\t\t\t\tif (dep instanceof HarmonyImportSideEffectDependency) {\n\t\t\t\t\t\t\t\tif (dep.module && dep.module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tremoveDependencies.push(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tconst mode = dep.getMode(true);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmode.type === \"safe-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"checked-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"dynamic-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default-strict\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-named-default\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tlet info = reexportMaps.get(module);\n\t\t\t\t\t\t\t\t\t\tif (!info) {\n\t\t\t\t\t\t\t\t\t\t\treexportMaps.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\t\t\t\t\tstatic: new Map(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tdynamic: new Map()\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst targetModule = dep._module;\n\t\t\t\t\t\t\t\t\t\tswitch (mode.type) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"safe-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"checked-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"dynamic-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, mode.ignored);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default-strict\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-named-default\":\n\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"default\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Flatten reexports\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst dynamicReexports = info.dynamic;\n\t\t\t\t\t\tinfo.dynamic = new Map();\n\t\t\t\t\t\tfor (const reexport of dynamicReexports) {\n\t\t\t\t\t\t\tlet [targetModule, ignored] = reexport;\n\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(targetModule);\n\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\tfor (const [key, reexports] of innerInfo.static) {\n\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\tfor (const { module, exportName, checked } of reexports) {\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, module, exportName, checked);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Follow dynamic reexport if there is only one\n\t\t\t\t\t\t\t\tif (innerInfo.dynamic.size !== 1) {\n\t\t\t\t\t\t\t\t\t// When there are more then one, we don't know which one\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tignored = new Set(ignored);\n\t\t\t\t\t\t\t\tfor (const [innerModule, innerIgnored] of innerInfo.dynamic) {\n\t\t\t\t\t\t\t\t\tfor (const key of innerIgnored) {\n\t\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\t\t// This reexports ends here\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, targetModule, key, true);\n\t\t\t\t\t\t\t\t\t\tignored.add(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttargetModule = innerModule;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update reexport as all other cases has been handled\n\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst staticReexports = info.static;\n\t\t\t\t\t\tinfo.static = new Map();\n\t\t\t\t\t\tfor (const [key, reexports] of staticReexports) {\n\t\t\t\t\t\t\tfor (let mapping of reexports) {\n\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(mapping.module);\n\t\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\t\tconst newMapping = getMappingFromInfo(\n\t\t\t\t\t\t\t\t\t\tinnerInfo,\n\t\t\t\t\t\t\t\t\t\tmapping.exportName\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!newMapping) break;\n\t\t\t\t\t\t\t\t\tmapping = newMapping;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tmapping.module,\n\t\t\t\t\t\t\t\t\tmapping.exportName,\n\t\t\t\t\t\t\t\t\tmapping.checked\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update imports along the reexports from sideEffectFree modules\n\t\t\t\t\tfor (const pair of reexportMaps) {\n\t\t\t\t\t\tconst module = pair[0];\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tlet newReasons = undefined;\n\t\t\t\t\t\tfor (let i = 0; i < module.reasons.length; i++) {\n\t\t\t\t\t\t\tconst reason = module.reasons[i];\n\t\t\t\t\t\t\tconst dep = reason.dependency;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(dep instanceof HarmonyExportImportedSpecifierDependency ||\n\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)) &&\n\t\t\t\t\t\t\t\tdep._id\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst mapping = getMappingFromInfo(info, dep._id);\n\t\t\t\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\t\t\t\tdep.redirectedModule = mapping.module;\n\t\t\t\t\t\t\t\t\tdep.redirectedId = mapping.exportName;\n\t\t\t\t\t\t\t\t\tmapping.module.addReason(\n\t\t\t\t\t\t\t\t\t\treason.module,\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\treason.explanation\n\t\t\t\t\t\t\t\t\t\t\t? reason.explanation +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" (skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t: \"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// removing the currect reason, by not adding it to the newReasons array\n\t\t\t\t\t\t\t\t\t// lazily create the newReasons array\n\t\t\t\t\t\t\t\t\tif (newReasons === undefined) {\n\t\t\t\t\t\t\t\t\t\tnewReasons = i === 0 ? [] : module.reasons.slice(0, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newReasons !== undefined) newReasons.push(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newReasons !== undefined) {\n\t\t\t\t\t\t\tmodule.reasons = newReasons;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tflagValue = flagValue.replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t\treturn mm.isMatch(moduleName, flagValue, {\n\t\t\t\t\tmatchBase: true\n\t\t\t\t});\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}