{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst util = require(\"util\");\n\nconst {\n  CachedSource\n} = require(\"webpack-sources\");\n\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\n\nconst ModuleNotFoundError = require(\"./ModuleNotFoundError\");\n\nconst ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\n\nconst ModuleDependencyError = require(\"./ModuleDependencyError\");\n\nconst ChunkGroup = require(\"./ChunkGroup\");\n\nconst Chunk = require(\"./Chunk\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst MainTemplate = require(\"./MainTemplate\");\n\nconst ChunkTemplate = require(\"./ChunkTemplate\");\n\nconst HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\n\nconst ModuleTemplate = require(\"./ModuleTemplate\");\n\nconst RuntimeTemplate = require(\"./RuntimeTemplate\");\n\nconst ChunkRenderError = require(\"./ChunkRenderError\");\n\nconst Stats = require(\"./Stats\");\n\nconst Semaphore = require(\"./util/Semaphore\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst GraphHelpers = require(\"./GraphHelpers\");\n\nconst ModuleDependency = require(\"./dependencies/ModuleDependency\");\n\nconst compareLocations = require(\"./compareLocations\");\n\nconst {\n  Logger,\n  LogType\n} = require(\"./logging/Logger\");\n\nconst ErrorHelpers = require(\"./ErrorHelpers\");\n\nconst buildChunkGraph = require(\"./buildChunkGraph\");\n\nconst WebpackError = require(\"./WebpackError\");\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n// TODO use @callback\n\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n\n/** @typedef {(module: Module) => void} OnModuleCallback */\n\n/** @typedef {(err?: Error|null) => void} Callback */\n\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @typedef {Object} LogEntry\n * @property {string} type\n * @property {any[]} args\n * @property {number} time\n * @property {string[]=} trace\n */\n\n/**\n * @typedef {Object} AssetInfo\n * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)\n * @property {number=} size size in bytes, only set after asset has been emitted\n * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets\n * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)\n */\n\n/**\n * @typedef {Object} Asset\n * @property {string} name the filename of the asset\n * @property {Source} source source of the asset\n * @property {AssetInfo} info info about the asset\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\n\n\nconst byId = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byIdOrIdentifier = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byIndexOrIdentifier = (a, b) => {\n  if (a.index < b.index) return -1;\n  if (a.index > b.index) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byNameOrHash = (a, b) => {\n  if (a.name < b.name) return -1;\n  if (a.name > b.name) return 1;\n  if (a.fullHash < b.fullHash) return -1;\n  if (a.fullHash > b.fullHash) return 1;\n  return 0;\n};\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\n\n\nconst iterationBlockVariable = (variables, fn) => {\n  for (let indexVariable = 0; indexVariable < variables.length; indexVariable++) {\n    const varDep = variables[indexVariable].dependencies;\n\n    for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n      fn(varDep[indexVDep]);\n    }\n  }\n};\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\n\n\nconst iterationOfArrayCallback = (arr, fn) => {\n  for (let index = 0; index < arr.length; index++) {\n    fn(arr[index]);\n  }\n};\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\n\n\nconst addAllToSet = (set, otherSet) => {\n  for (const item of otherSet) {\n    set.add(item);\n  }\n};\n/**\n * @param {Source} a a source\n * @param {Source} b another source\n * @returns {boolean} true, when both sources are equal\n */\n\n\nconst isSourceEqual = (a, b) => {\n  if (a === b) return true; // TODO webpack 5: check .buffer() instead, it's called anyway during emit\n\n  /** @type {Buffer|string} */\n\n  let aSource = a.source();\n  /** @type {Buffer|string} */\n\n  let bSource = b.source();\n  if (aSource === bSource) return true;\n  if (typeof aSource === \"string\" && typeof bSource === \"string\") return false;\n  if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, \"utf-8\");\n  if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, \"utf-8\");\n  return aSource.equals(bSource);\n};\n\nclass Compilation extends Tapable {\n  /**\n   * Creates an instance of Compilation.\n   * @param {Compiler} compiler the compiler which created the compilation\n   */\n  constructor(compiler) {\n    super();\n    this.hooks = {\n      /** @type {SyncHook<Module>} */\n      buildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module>} */\n      rebuildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module, Error>} */\n      failedModule: new SyncHook([\"module\", \"error\"]),\n\n      /** @type {SyncHook<Module>} */\n      succeedModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Dependency, string>} */\n      addEntry: new SyncHook([\"entry\", \"name\"]),\n\n      /** @type {SyncHook<Dependency, string, Error>} */\n      failedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n\n      /** @type {SyncHook<Dependency, string, Module>} */\n      succeedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n\n      /** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n      dependencyReference: new SyncWaterfallHook([\"dependencyReference\", \"dependency\", \"module\"]),\n\n      /** @type {AsyncSeriesHook<Module[]>} */\n      finishModules: new AsyncSeriesHook([\"modules\"]),\n\n      /** @type {SyncHook<Module>} */\n      finishRebuildingModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook} */\n      unseal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      seal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunks: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterChunks: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependencies: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      afterOptimizeDependencies: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook} */\n      optimize: new SyncHook([]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModules: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModules: new SyncHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n      afterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n      optimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook} */\n      shouldRecord: new SyncBailHook([]),\n\n      /** @type {SyncHook<Module[], any>} */\n      reviveModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      advancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      beforeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      moduleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      reviveChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkOrder: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      beforeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Module[], any>} */\n      recordModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      recordChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeHash: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk>} */\n      contentHash: new SyncHook([\"chunk\"]),\n\n      /** @type {SyncHook} */\n      afterHash: new SyncHook([]),\n\n      /** @type {SyncHook<any>} */\n      recordHash: new SyncHook([\"records\"]),\n\n      /** @type {SyncHook<Compilation, any>} */\n      record: new SyncHook([\"compilation\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeModuleAssets: new SyncHook([]),\n\n      /** @type {SyncBailHook} */\n      shouldGenerateChunkAssets: new SyncBailHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunkAssets: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      additionalChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook} */\n      additionalAssets: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Chunk[]>} */\n      optimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook<CompilationAssets>} */\n      optimizeAssets: new AsyncSeriesHook([\"assets\"]),\n\n      /** @type {SyncHook<CompilationAssets>} */\n      afterOptimizeAssets: new SyncHook([\"assets\"]),\n\n      /** @type {SyncBailHook} */\n      needAdditionalSeal: new SyncBailHook([]),\n\n      /** @type {AsyncSeriesHook} */\n      afterSeal: new AsyncSeriesHook([]),\n\n      /** @type {SyncHook<Chunk, Hash>} */\n      chunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n\n      /** @type {SyncHook<Module, string>} */\n      moduleAsset: new SyncHook([\"module\", \"filename\"]),\n\n      /** @type {SyncHook<Chunk, string>} */\n      chunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n\n      /** @type {SyncWaterfallHook<string, TODO>} */\n      assetPath: new SyncWaterfallHook([\"filename\", \"data\"]),\n      // TODO MainTemplate\n\n      /** @type {SyncBailHook} */\n      needAdditionalPass: new SyncBailHook([]),\n\n      /** @type {SyncHook<Compiler, string, number>} */\n      childCompiler: new SyncHook([\"childCompiler\", \"compilerName\", \"compilerIndex\"]),\n\n      /** @type {SyncBailHook<string, LogEntry>} */\n      log: new SyncBailHook([\"origin\", \"logEntry\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook<object, Module>} */\n      normalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n    };\n\n    this._pluginCompat.tap(\"Compilation\", options => {\n      switch (options.name) {\n        case \"optimize-tree\":\n        case \"additional-assets\":\n        case \"optimize-chunk-assets\":\n        case \"optimize-assets\":\n        case \"after-seal\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    this.name = undefined;\n    /** @type {Compiler} */\n\n    this.compiler = compiler;\n    this.resolverFactory = compiler.resolverFactory;\n    this.inputFileSystem = compiler.inputFileSystem;\n    this.requestShortener = compiler.requestShortener;\n    const options = compiler.options;\n    this.options = options;\n    this.outputOptions = options && options.output;\n    /** @type {boolean=} */\n\n    this.bail = options && options.bail;\n    this.profile = options && options.profile;\n    this.performance = options && options.performance;\n    this.mainTemplate = new MainTemplate(this.outputOptions);\n    this.chunkTemplate = new ChunkTemplate(this.outputOptions);\n    this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);\n    this.runtimeTemplate = new RuntimeTemplate(this.outputOptions, this.requestShortener);\n    this.moduleTemplates = {\n      javascript: new ModuleTemplate(this.runtimeTemplate, \"javascript\"),\n      webassembly: new ModuleTemplate(this.runtimeTemplate, \"webassembly\")\n    };\n    this.semaphore = new Semaphore(options.parallelism || 100);\n    this.entries = [];\n    /** @private @type {{name: string, request: string, module: Module}[]} */\n\n    this._preparedEntrypoints = [];\n    /** @type {Map<string, Entrypoint>} */\n\n    this.entrypoints = new Map();\n    /** @type {Chunk[]} */\n\n    this.chunks = [];\n    /** @type {ChunkGroup[]} */\n\n    this.chunkGroups = [];\n    /** @type {Map<string, ChunkGroup>} */\n\n    this.namedChunkGroups = new Map();\n    /** @type {Map<string, Chunk>} */\n\n    this.namedChunks = new Map();\n    /** @type {Module[]} */\n\n    this.modules = [];\n    /** @private @type {Map<string, Module>} */\n\n    this._modules = new Map();\n    this.cache = null;\n    this.records = null;\n    /** @type {string[]} */\n\n    this.additionalChunkAssets = [];\n    /** @type {CompilationAssets} */\n\n    this.assets = {};\n    /** @type {Map<string, AssetInfo>} */\n\n    this.assetsInfo = new Map();\n    /** @type {WebpackError[]} */\n\n    this.errors = [];\n    /** @type {WebpackError[]} */\n\n    this.warnings = [];\n    /** @type {Compilation[]} */\n\n    this.children = [];\n    /** @type {Map<string, LogEntry[]>} */\n\n    this.logging = new Map();\n    /** @type {Map<DepConstructor, ModuleFactory>} */\n\n    this.dependencyFactories = new Map();\n    /** @type {Map<DepConstructor, DependencyTemplate>} */\n\n    this.dependencyTemplates = new Map(); // TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n    // @ts-ignore\n\n    this.dependencyTemplates.set(\"hash\", \"\");\n    this.childrenCounters = {};\n    /** @type {Set<number|string>} */\n\n    this.usedChunkIds = null;\n    /** @type {Set<number>} */\n\n    this.usedModuleIds = null;\n    /** @type {Map<string, number>=} */\n\n    this.fileTimestamps = undefined;\n    /** @type {Map<string, number>=} */\n\n    this.contextTimestamps = undefined;\n    /** @type {Set<string>=} */\n\n    this.compilationDependencies = undefined;\n    /** @private @type {Map<Module, Callback[]>} */\n\n    this._buildingModules = new Map();\n    /** @private @type {Map<Module, Callback[]>} */\n\n    this._rebuildingModules = new Map();\n    /** @type {Set<string>} */\n\n    this.emittedAssets = new Set();\n  }\n\n  getStats() {\n    return new Stats(this);\n  }\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n\n\n  getLogger(name) {\n    if (!name) {\n      throw new TypeError(\"Compilation.getLogger(name) called without a name\");\n    }\n    /** @type {LogEntry[] | undefined} */\n\n\n    let logEntries;\n    return new Logger((type, args) => {\n      if (typeof name === \"function\") {\n        name = name();\n\n        if (!name) {\n          throw new TypeError(\"Compilation.getLogger(name) called with a function not returning a name\");\n        }\n      }\n\n      let trace;\n\n      switch (type) {\n        case LogType.warn:\n        case LogType.error:\n        case LogType.trace:\n          trace = ErrorHelpers.cutOffLoaderExecution(new Error(\"Trace\").stack).split(\"\\n\").slice(3);\n          break;\n      }\n      /** @type {LogEntry} */\n\n\n      const logEntry = {\n        time: Date.now(),\n        type,\n        args,\n        trace\n      };\n\n      if (this.hooks.log.call(name, logEntry) === undefined) {\n        if (logEntry.type === LogType.profileEnd) {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          if (typeof console.profileEnd === \"function\") {\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            console.profileEnd(`[${name}] ${logEntry.args[0]}`);\n          }\n        }\n\n        if (logEntries === undefined) {\n          logEntries = this.logging.get(name);\n\n          if (logEntries === undefined) {\n            logEntries = [];\n            this.logging.set(name, logEntries);\n          }\n        }\n\n        logEntries.push(logEntry);\n\n        if (logEntry.type === LogType.profile) {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          if (typeof console.profile === \"function\") {\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            console.profile(`[${name}] ${logEntry.args[0]}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * @typedef {Object} AddModuleResult\n   * @property {Module} module the added or existing module\n   * @property {boolean} issuer was this the first request for this module\n   * @property {boolean} build should the module be build\n   * @property {boolean} dependencies should dependencies be walked\n   */\n\n  /**\n   * @param {Module} module module to be added that was created\n   * @param {any=} cacheGroup cacheGroup it is apart of\n   * @returns {AddModuleResult} returns meta about whether or not the module had built\n   * had an issuer, or any dependnecies\n   */\n\n\n  addModule(module, cacheGroup) {\n    const identifier = module.identifier();\n\n    const alreadyAddedModule = this._modules.get(identifier);\n\n    if (alreadyAddedModule) {\n      return {\n        module: alreadyAddedModule,\n        issuer: false,\n        build: false,\n        dependencies: false\n      };\n    }\n\n    const cacheName = (cacheGroup || \"m\") + identifier;\n\n    if (this.cache && this.cache[cacheName]) {\n      const cacheModule = this.cache[cacheName];\n\n      if (typeof cacheModule.updateCacheModule === \"function\") {\n        cacheModule.updateCacheModule(module);\n      }\n\n      let rebuild = true;\n\n      if (this.fileTimestamps && this.contextTimestamps) {\n        rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);\n      }\n\n      if (!rebuild) {\n        cacheModule.disconnect();\n\n        this._modules.set(identifier, cacheModule);\n\n        this.modules.push(cacheModule);\n\n        for (const err of cacheModule.errors) {\n          this.errors.push(err);\n        }\n\n        for (const err of cacheModule.warnings) {\n          this.warnings.push(err);\n        }\n\n        return {\n          module: cacheModule,\n          issuer: true,\n          build: false,\n          dependencies: true\n        };\n      }\n\n      cacheModule.unbuild();\n      module = cacheModule;\n    }\n\n    this._modules.set(identifier, module);\n\n    if (this.cache) {\n      this.cache[cacheName] = module;\n    }\n\n    this.modules.push(module);\n    return {\n      module: module,\n      issuer: true,\n      build: true,\n      dependencies: true\n    };\n  }\n  /**\n   * Fetches a module from a compilation by its identifier\n   * @param {Module} module the module provided\n   * @returns {Module} the module requested\n   */\n\n\n  getModule(module) {\n    const identifier = module.identifier();\n    return this._modules.get(identifier);\n  }\n  /**\n   * Attempts to search for a module by its identifier\n   * @param {string} identifier identifier (usually path) for module\n   * @returns {Module|undefined} attempt to search for module and return it, else undefined\n   */\n\n\n  findModule(identifier) {\n    return this._modules.get(identifier);\n  }\n  /**\n   * @param {Module} module module with its callback list\n   * @param {Callback} callback the callback function\n   * @returns {void}\n   */\n\n\n  waitForBuildingFinished(module, callback) {\n    let callbackList = this._buildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(() => callback());\n    } else {\n      process.nextTick(callback);\n    }\n  }\n  /**\n   * Builds the module object\n   *\n   * @param {Module} module module to be built\n   * @param {boolean} optional optional flag\n   * @param {Module=} origin origin module this module build was requested from\n   * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n   * @param {TODO} thisCallback the callback\n   * @returns {TODO} returns the callback function with results\n   */\n\n\n  buildModule(module, optional, origin, dependencies, thisCallback) {\n    let callbackList = this._buildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n\n    this._buildingModules.set(module, callbackList = [thisCallback]);\n\n    const callback = err => {\n      this._buildingModules.delete(module);\n\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n\n    this.hooks.buildModule.call(module);\n    module.build(this.options, this, this.resolverFactory.get(\"normal\", module.resolveOptions), this.inputFileSystem, error => {\n      const errors = module.errors;\n\n      for (let indexError = 0; indexError < errors.length; indexError++) {\n        const err = errors[indexError];\n        err.origin = origin;\n        err.dependencies = dependencies;\n\n        if (optional) {\n          this.warnings.push(err);\n        } else {\n          this.errors.push(err);\n        }\n      }\n\n      const warnings = module.warnings;\n\n      for (let indexWarning = 0; indexWarning < warnings.length; indexWarning++) {\n        const war = warnings[indexWarning];\n        war.origin = origin;\n        war.dependencies = dependencies;\n        this.warnings.push(war);\n      }\n\n      const originalMap = module.dependencies.reduce((map, v, i) => {\n        map.set(v, i);\n        return map;\n      }, new Map());\n      module.dependencies.sort((a, b) => {\n        const cmp = compareLocations(a.loc, b.loc);\n        if (cmp) return cmp;\n        return originalMap.get(a) - originalMap.get(b);\n      });\n\n      if (error) {\n        this.hooks.failedModule.call(module, error);\n        return callback(error);\n      }\n\n      this.hooks.succeedModule.call(module);\n      return callback();\n    });\n  }\n  /**\n   * @param {Module} module to be processed for deps\n   * @param {ModuleCallback} callback callback to be triggered\n   * @returns {void}\n   */\n\n\n  processModuleDependencies(module, callback) {\n    const dependencies = new Map();\n\n    const addDependency = dep => {\n      const resourceIdent = dep.getResourceIdentifier();\n\n      if (resourceIdent) {\n        const factory = this.dependencyFactories.get(dep.constructor);\n\n        if (factory === undefined) {\n          throw new Error(`No module factory available for dependency type: ${dep.constructor.name}`);\n        }\n\n        let innerMap = dependencies.get(factory);\n\n        if (innerMap === undefined) {\n          dependencies.set(factory, innerMap = new Map());\n        }\n\n        let list = innerMap.get(resourceIdent);\n        if (list === undefined) innerMap.set(resourceIdent, list = []);\n        list.push(dep);\n      }\n    };\n\n    const addDependenciesBlock = block => {\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, addDependency);\n      }\n\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, addDependenciesBlock);\n      }\n\n      if (block.variables) {\n        iterationBlockVariable(block.variables, addDependency);\n      }\n    };\n\n    try {\n      addDependenciesBlock(module);\n    } catch (e) {\n      callback(e);\n    }\n\n    const sortedDependencies = [];\n\n    for (const pair1 of dependencies) {\n      for (const pair2 of pair1[1]) {\n        sortedDependencies.push({\n          factory: pair1[0],\n          dependencies: pair2[1]\n        });\n      }\n    }\n\n    this.addModuleDependencies(module, sortedDependencies, this.bail, null, true, callback);\n  }\n  /**\n   * @param {Module} module module to add deps to\n   * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n   * @param {(boolean|null)=} bail whether to bail or not\n   * @param {TODO} cacheGroup optional cacheGroup\n   * @param {boolean} recursive whether it is recursive traversal\n   * @param {function} callback callback for when dependencies are finished being added\n   * @returns {void}\n   */\n\n\n  addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    asyncLib.forEach(dependencies, (item, callback) => {\n      const dependencies = item.dependencies;\n\n      const errorAndCallback = err => {\n        err.origin = module;\n        err.dependencies = dependencies;\n        this.errors.push(err);\n\n        if (bail) {\n          callback(err);\n        } else {\n          callback();\n        }\n      };\n\n      const warningAndCallback = err => {\n        err.origin = module;\n        this.warnings.push(err);\n        callback();\n      };\n\n      const semaphore = this.semaphore;\n      semaphore.acquire(() => {\n        const factory = item.factory;\n        factory.create({\n          contextInfo: {\n            issuer: module.nameForCondition && module.nameForCondition(),\n            compiler: this.compiler.name\n          },\n          resolveOptions: module.resolveOptions,\n          context: module.context,\n          dependencies: dependencies\n        }, (err, dependentModule) => {\n          let afterFactory;\n\n          const isOptional = () => {\n            return dependencies.every(d => d.optional);\n          };\n\n          const errorOrWarningAndCallback = err => {\n            if (isOptional()) {\n              return warningAndCallback(err);\n            } else {\n              return errorAndCallback(err);\n            }\n          };\n\n          if (err) {\n            semaphore.release();\n            return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));\n          }\n\n          if (!dependentModule) {\n            semaphore.release();\n            return process.nextTick(callback);\n          }\n\n          if (currentProfile) {\n            afterFactory = Date.now();\n            currentProfile.factory = afterFactory - start;\n          }\n\n          const iterationDependencies = depend => {\n            for (let index = 0; index < depend.length; index++) {\n              const dep = depend[index];\n              dep.module = dependentModule;\n              dependentModule.addReason(module, dep);\n            }\n          };\n\n          const addModuleResult = this.addModule(dependentModule, cacheGroup);\n          dependentModule = addModuleResult.module;\n          iterationDependencies(dependencies);\n\n          const afterBuild = () => {\n            if (recursive && addModuleResult.dependencies) {\n              this.processModuleDependencies(dependentModule, callback);\n            } else {\n              return callback();\n            }\n          };\n\n          if (addModuleResult.issuer) {\n            if (currentProfile) {\n              dependentModule.profile = currentProfile;\n            }\n\n            dependentModule.issuer = module;\n          } else {\n            if (this.profile) {\n              if (module.profile) {\n                const time = Date.now() - start;\n\n                if (!module.profile.dependencies || time > module.profile.dependencies) {\n                  module.profile.dependencies = time;\n                }\n              }\n            }\n          }\n\n          if (addModuleResult.build) {\n            this.buildModule(dependentModule, isOptional(), module, dependencies, err => {\n              if (err) {\n                semaphore.release();\n                return errorOrWarningAndCallback(err);\n              }\n\n              if (currentProfile) {\n                const afterBuilding = Date.now();\n                currentProfile.building = afterBuilding - afterFactory;\n              }\n\n              semaphore.release();\n              afterBuild();\n            });\n          } else {\n            semaphore.release();\n            this.waitForBuildingFinished(dependentModule, afterBuild);\n          }\n        });\n      });\n    }, err => {\n      // In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n      // errors are created inside closures that keep a reference to the Compilation, so errors are\n      // leaking the Compilation object.\n      if (err) {\n        // eslint-disable-next-line no-self-assign\n        err.stack = err.stack;\n        return callback(err);\n      }\n\n      return process.nextTick(callback);\n    });\n  }\n  /**\n   *\n   * @param {string} context context string path\n   * @param {Dependency} dependency dependency used to create Module chain\n   * @param {OnModuleCallback} onModule function invoked on modules creation\n   * @param {ModuleChainCallback} callback callback for when module chain is complete\n   * @returns {void} will throw if dependency instance is not a valid Dependency\n   */\n\n\n  _addModuleChain(context, dependency, onModule, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    const errorAndCallback = this.bail ? err => {\n      callback(err);\n    } : err => {\n      err.dependencies = [dependency];\n      this.errors.push(err);\n      callback();\n    };\n\n    if (typeof dependency !== \"object\" || dependency === null || !dependency.constructor) {\n      throw new Error(\"Parameter 'dependency' must be a Dependency\");\n    }\n\n    const Dep =\n    /** @type {DepConstructor} */\n    dependency.constructor;\n    const moduleFactory = this.dependencyFactories.get(Dep);\n\n    if (!moduleFactory) {\n      throw new Error(`No dependency factory available for this dependency type: ${dependency.constructor.name}`);\n    }\n\n    this.semaphore.acquire(() => {\n      moduleFactory.create({\n        contextInfo: {\n          issuer: \"\",\n          compiler: this.compiler.name\n        },\n        context: context,\n        dependencies: [dependency]\n      }, (err, module) => {\n        if (err) {\n          this.semaphore.release();\n          return errorAndCallback(new EntryModuleNotFoundError(err));\n        }\n\n        let afterFactory;\n\n        if (currentProfile) {\n          afterFactory = Date.now();\n          currentProfile.factory = afterFactory - start;\n        }\n\n        const addModuleResult = this.addModule(module);\n        module = addModuleResult.module;\n        onModule(module);\n        dependency.module = module;\n        module.addReason(null, dependency);\n\n        const afterBuild = () => {\n          if (addModuleResult.dependencies) {\n            this.processModuleDependencies(module, err => {\n              if (err) return callback(err);\n              callback(null, module);\n            });\n          } else {\n            return callback(null, module);\n          }\n        };\n\n        if (addModuleResult.issuer) {\n          if (currentProfile) {\n            module.profile = currentProfile;\n          }\n        }\n\n        if (addModuleResult.build) {\n          this.buildModule(module, false, null, null, err => {\n            if (err) {\n              this.semaphore.release();\n              return errorAndCallback(err);\n            }\n\n            if (currentProfile) {\n              const afterBuilding = Date.now();\n              currentProfile.building = afterBuilding - afterFactory;\n            }\n\n            this.semaphore.release();\n            afterBuild();\n          });\n        } else {\n          this.semaphore.release();\n          this.waitForBuildingFinished(module, afterBuild);\n        }\n      });\n    });\n  }\n  /**\n   *\n   * @param {string} context context path for entry\n   * @param {Dependency} entry entry dependency being created\n   * @param {string} name name of entry\n   * @param {ModuleCallback} callback callback function\n   * @returns {void} returns\n   */\n\n\n  addEntry(context, entry, name, callback) {\n    this.hooks.addEntry.call(entry, name);\n    const slot = {\n      name: name,\n      // TODO webpack 5 remove `request`\n      request: null,\n      module: null\n    };\n\n    if (entry instanceof ModuleDependency) {\n      slot.request = entry.request;\n    } // TODO webpack 5: merge modules instead when multiple entry modules are supported\n\n\n    const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);\n\n    if (idx >= 0) {\n      // Overwrite existing entrypoint\n      this._preparedEntrypoints[idx] = slot;\n    } else {\n      this._preparedEntrypoints.push(slot);\n    }\n\n    this._addModuleChain(context, entry, module => {\n      this.entries.push(module);\n    }, (err, module) => {\n      if (err) {\n        this.hooks.failedEntry.call(entry, name, err);\n        return callback(err);\n      }\n\n      if (module) {\n        slot.module = module;\n      } else {\n        const idx = this._preparedEntrypoints.indexOf(slot);\n\n        if (idx >= 0) {\n          this._preparedEntrypoints.splice(idx, 1);\n        }\n      }\n\n      this.hooks.succeedEntry.call(entry, name, module);\n      return callback(null, module);\n    });\n  }\n  /**\n   * @param {string} context context path string\n   * @param {Dependency} dependency dep used to create module\n   * @param {ModuleCallback} callback module callback sending module up a level\n   * @returns {void}\n   */\n\n\n  prefetch(context, dependency, callback) {\n    this._addModuleChain(context, dependency, module => {\n      module.prefetched = true;\n    }, callback);\n  }\n  /**\n   * @param {Module} module module to be rebuilt\n   * @param {Callback} thisCallback callback when module finishes rebuilding\n   * @returns {void}\n   */\n\n\n  rebuildModule(module, thisCallback) {\n    let callbackList = this._rebuildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n\n    this._rebuildingModules.set(module, callbackList = [thisCallback]);\n\n    const callback = err => {\n      this._rebuildingModules.delete(module);\n\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n\n    this.hooks.rebuildModule.call(module);\n    const oldDependencies = module.dependencies.slice();\n    const oldVariables = module.variables.slice();\n    const oldBlocks = module.blocks.slice();\n    module.unbuild();\n    this.buildModule(module, false, module, null, err => {\n      if (err) {\n        this.hooks.finishRebuildingModule.call(module);\n        return callback(err);\n      }\n\n      this.processModuleDependencies(module, err => {\n        if (err) return callback(err);\n        this.removeReasonsOfDependencyBlock(module, {\n          dependencies: oldDependencies,\n          variables: oldVariables,\n          blocks: oldBlocks\n        });\n        this.hooks.finishRebuildingModule.call(module);\n        callback();\n      });\n    });\n  }\n\n  finish(callback) {\n    const modules = this.modules;\n    this.hooks.finishModules.callAsync(modules, err => {\n      if (err) return callback(err);\n\n      for (let index = 0; index < modules.length; index++) {\n        const module = modules[index];\n        this.reportDependencyErrorsAndWarnings(module, [module]);\n      }\n\n      callback();\n    });\n  }\n\n  unseal() {\n    this.hooks.unseal.call();\n    this.chunks.length = 0;\n    this.chunkGroups.length = 0;\n    this.namedChunks.clear();\n    this.namedChunkGroups.clear();\n    this.additionalChunkAssets.length = 0;\n    this.assets = {};\n    this.assetsInfo.clear();\n\n    for (const module of this.modules) {\n      module.unseal();\n    }\n  }\n  /**\n   * @param {Callback} callback signals when the seal method is finishes\n   * @returns {void}\n   */\n\n\n  seal(callback) {\n    this.hooks.seal.call();\n\n    while (this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeDependencies.call(this.modules);\n    this.hooks.beforeChunks.call();\n\n    for (const preparedEntrypoint of this._preparedEntrypoints) {\n      const module = preparedEntrypoint.module;\n      const name = preparedEntrypoint.name;\n      const chunk = this.addChunk(name);\n      const entrypoint = new Entrypoint(name);\n      entrypoint.setRuntimeChunk(chunk);\n      entrypoint.addOrigin(null, name, preparedEntrypoint.request);\n      this.namedChunkGroups.set(name, entrypoint);\n      this.entrypoints.set(name, entrypoint);\n      this.chunkGroups.push(entrypoint);\n      GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n      GraphHelpers.connectChunkAndModule(chunk, module);\n      chunk.entryModule = module;\n      chunk.name = name;\n      this.assignDepth(module);\n    }\n\n    buildChunkGraph(this,\n    /** @type {Entrypoint[]} */\n    this.chunkGroups.slice());\n    this.sortModules(this.modules);\n    this.hooks.afterChunks.call(this.chunks);\n    this.hooks.optimize.call();\n\n    while (this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeModules.call(this.modules);\n\n    while (this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.hooks.afterOptimizeTree.call(this.chunks, this.modules);\n\n      while (this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) || this.hooks.optimizeChunkModules.call(this.chunks, this.modules) || this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)) {\n        /* empty */\n      }\n\n      this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);\n      const shouldRecord = this.hooks.shouldRecord.call() !== false;\n      this.hooks.reviveModules.call(this.modules, this.records);\n      this.hooks.optimizeModuleOrder.call(this.modules);\n      this.hooks.advancedOptimizeModuleOrder.call(this.modules);\n      this.hooks.beforeModuleIds.call(this.modules);\n      this.hooks.moduleIds.call(this.modules);\n      this.applyModuleIds();\n      this.hooks.optimizeModuleIds.call(this.modules);\n      this.hooks.afterOptimizeModuleIds.call(this.modules);\n      this.sortItemsWithModuleIds();\n      this.hooks.reviveChunks.call(this.chunks, this.records);\n      this.hooks.optimizeChunkOrder.call(this.chunks);\n      this.hooks.beforeChunkIds.call(this.chunks);\n      this.applyChunkIds();\n      this.hooks.optimizeChunkIds.call(this.chunks);\n      this.hooks.afterOptimizeChunkIds.call(this.chunks);\n      this.sortItemsWithChunkIds();\n\n      if (shouldRecord) {\n        this.hooks.recordModules.call(this.modules, this.records);\n        this.hooks.recordChunks.call(this.chunks, this.records);\n      }\n\n      this.hooks.beforeHash.call();\n      this.createHash();\n      this.hooks.afterHash.call();\n\n      if (shouldRecord) {\n        this.hooks.recordHash.call(this.records);\n      }\n\n      this.hooks.beforeModuleAssets.call();\n      this.createModuleAssets();\n\n      if (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n        this.hooks.beforeChunkAssets.call();\n        this.createChunkAssets();\n      }\n\n      this.hooks.additionalChunkAssets.call(this.chunks);\n      this.summarizeDependencies();\n\n      if (shouldRecord) {\n        this.hooks.record.call(this, this.records);\n      }\n\n      this.hooks.additionalAssets.callAsync(err => {\n        if (err) {\n          return callback(err);\n        }\n\n        this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          this.hooks.afterOptimizeChunkAssets.call(this.chunks);\n          this.hooks.optimizeAssets.callAsync(this.assets, err => {\n            if (err) {\n              return callback(err);\n            }\n\n            this.hooks.afterOptimizeAssets.call(this.assets);\n\n            if (this.hooks.needAdditionalSeal.call()) {\n              this.unseal();\n              return this.seal(callback);\n            }\n\n            return this.hooks.afterSeal.callAsync(callback);\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {Module[]} modules the modules array on compilation to perform the sort for\n   * @returns {void}\n   */\n\n\n  sortModules(modules) {\n    // TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n    // TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n    // TODO remove this method\n    modules.sort(byIndexOrIdentifier);\n  }\n  /**\n   * @param {Module} module moulde to report from\n   * @param {DependenciesBlock[]} blocks blocks to report from\n   * @returns {void}\n   */\n\n\n  reportDependencyErrorsAndWarnings(module, blocks) {\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const block = blocks[indexBlock];\n      const dependencies = block.dependencies;\n\n      for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {\n        const d = dependencies[indexDep];\n        const warnings = d.getWarnings();\n\n        if (warnings) {\n          for (let indexWar = 0; indexWar < warnings.length; indexWar++) {\n            const w = warnings[indexWar];\n            const warning = new ModuleDependencyWarning(module, w, d.loc);\n            this.warnings.push(warning);\n          }\n        }\n\n        const errors = d.getErrors();\n\n        if (errors) {\n          for (let indexErr = 0; indexErr < errors.length; indexErr++) {\n            const e = errors[indexErr];\n            const error = new ModuleDependencyError(module, e, d.loc);\n            this.errors.push(error);\n          }\n        }\n      }\n\n      this.reportDependencyErrorsAndWarnings(module, block.blocks);\n    }\n  }\n  /**\n   * @param {TODO} groupOptions options for the chunk group\n   * @param {Module} module the module the references the chunk group\n   * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n   * @param {string} request the request from which the the chunk group is referenced\n   * @returns {ChunkGroup} the new or existing chunk group\n   */\n\n\n  addChunkInGroup(groupOptions, module, loc, request) {\n    if (typeof groupOptions === \"string\") {\n      groupOptions = {\n        name: groupOptions\n      };\n    }\n\n    const name = groupOptions.name;\n\n    if (name) {\n      const chunkGroup = this.namedChunkGroups.get(name);\n\n      if (chunkGroup !== undefined) {\n        chunkGroup.addOptions(groupOptions);\n\n        if (module) {\n          chunkGroup.addOrigin(module, loc, request);\n        }\n\n        return chunkGroup;\n      }\n    }\n\n    const chunkGroup = new ChunkGroup(groupOptions);\n    if (module) chunkGroup.addOrigin(module, loc, request);\n    const chunk = this.addChunk(name);\n    GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n    this.chunkGroups.push(chunkGroup);\n\n    if (name) {\n      this.namedChunkGroups.set(name, chunkGroup);\n    }\n\n    return chunkGroup;\n  }\n  /**\n   * This method first looks to see if a name is provided for a new chunk,\n   * and first looks to see if any named chunks already exist and reuse that chunk instead.\n   *\n   * @param {string=} name optional chunk name to be provided\n   * @returns {Chunk} create a chunk (invoked during seal event)\n   */\n\n\n  addChunk(name) {\n    if (name) {\n      const chunk = this.namedChunks.get(name);\n\n      if (chunk !== undefined) {\n        return chunk;\n      }\n    }\n\n    const chunk = new Chunk(name);\n    this.chunks.push(chunk);\n\n    if (name) {\n      this.namedChunks.set(name, chunk);\n    }\n\n    return chunk;\n  }\n  /**\n   * @param {Module} module module to assign depth\n   * @returns {void}\n   */\n\n\n  assignDepth(module) {\n    const queue = new Set([module]);\n    let depth;\n    module.depth = 0;\n    /**\n     * @param {Module} module module for processeing\n     * @returns {void}\n     */\n\n    const enqueueJob = module => {\n      const d = module.depth;\n      if (typeof d === \"number\" && d <= depth) return;\n      queue.add(module);\n      module.depth = depth;\n    };\n    /**\n     * @param {Dependency} dependency dependency to assign depth to\n     * @returns {void}\n     */\n\n\n    const assignDepthToDependency = dependency => {\n      if (dependency.module) {\n        enqueueJob(dependency.module);\n      }\n    };\n    /**\n     * @param {DependenciesBlock} block block to assign depth to\n     * @returns {void}\n     */\n\n\n    const assignDepthToDependencyBlock = block => {\n      if (block.variables) {\n        iterationBlockVariable(block.variables, assignDepthToDependency);\n      }\n\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, assignDepthToDependency);\n      }\n\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n      }\n    };\n\n    for (module of queue) {\n      queue.delete(module);\n      depth = module.depth;\n      depth++;\n      assignDepthToDependencyBlock(module);\n    }\n  }\n  /**\n   * @param {Module} module the module containing the dependency\n   * @param {Dependency} dependency the dependency\n   * @returns {DependencyReference} a reference for the dependency\n   */\n\n\n  getDependencyReference(module, dependency) {\n    // TODO remove dep.getReference existence check in webpack 5\n    if (typeof dependency.getReference !== \"function\") return null;\n    const ref = dependency.getReference();\n    if (!ref) return null;\n    return this.hooks.dependencyReference.call(ref, dependency, module);\n  }\n  /**\n   *\n   * @param {Module} module module relationship for removal\n   * @param {DependenciesBlockLike} block //TODO: good description\n   * @returns {void}\n   */\n\n\n  removeReasonsOfDependencyBlock(module, block) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n\n      if (d.module.removeReason(module, d)) {\n        for (const chunk of d.module.chunksIterable) {\n          this.patchChunksAfterReasonRemoval(d.module, chunk);\n        }\n      }\n    };\n\n    if (block.blocks) {\n      iterationOfArrayCallback(block.blocks, block => this.removeReasonsOfDependencyBlock(module, block));\n    }\n\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n  /**\n   * @param {Module} module module to patch tie\n   * @param {Chunk} chunk chunk to patch tie\n   * @returns {void}\n   */\n\n\n  patchChunksAfterReasonRemoval(module, chunk) {\n    if (!module.hasReasons()) {\n      this.removeReasonsOfDependencyBlock(module, module);\n    }\n\n    if (!module.hasReasonForChunk(chunk)) {\n      if (module.removeChunk(chunk)) {\n        this.removeChunkFromDependencies(module, chunk);\n      }\n    }\n  }\n  /**\n   *\n   * @param {DependenciesBlock} block block tie for Chunk\n   * @param {Chunk} chunk chunk to remove from dep\n   * @returns {void}\n   */\n\n\n  removeChunkFromDependencies(block, chunk) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n\n      this.patchChunksAfterReasonRemoval(d.module, chunk);\n    };\n\n    const blocks = block.blocks;\n\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const asyncBlock = blocks[indexBlock]; // Grab all chunks from the first Block's AsyncDepBlock\n\n      const chunks = asyncBlock.chunkGroup.chunks; // For each chunk in chunkGroup\n\n      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        const iteratedChunk = chunks[indexChunk];\n        asyncBlock.chunkGroup.removeChunk(iteratedChunk);\n        asyncBlock.chunkGroup.removeParent(iteratedChunk); // Recurse\n\n        this.removeChunkFromDependencies(block, iteratedChunk);\n      }\n    }\n\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n\n  applyModuleIds() {\n    const unusedIds = [];\n    let nextFreeModuleId = 0;\n    const usedIds = new Set();\n\n    if (this.usedModuleIds) {\n      for (const id of this.usedModuleIds) {\n        usedIds.add(id);\n      }\n    }\n\n    const modules1 = this.modules;\n\n    for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n      const module1 = modules1[indexModule1];\n\n      if (module1.id !== null) {\n        usedIds.add(module1.id);\n      }\n    }\n\n    if (usedIds.size > 0) {\n      let usedIdMax = -1;\n\n      for (const usedIdKey of usedIds) {\n        if (typeof usedIdKey !== \"number\") {\n          continue;\n        }\n\n        usedIdMax = Math.max(usedIdMax, usedIdKey);\n      }\n\n      let lengthFreeModules = nextFreeModuleId = usedIdMax + 1;\n\n      while (lengthFreeModules--) {\n        if (!usedIds.has(lengthFreeModules)) {\n          unusedIds.push(lengthFreeModules);\n        }\n      }\n    }\n\n    const modules2 = this.modules;\n\n    for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n      const module2 = modules2[indexModule2];\n\n      if (module2.id === null) {\n        if (unusedIds.length > 0) {\n          module2.id = unusedIds.pop();\n        } else {\n          module2.id = nextFreeModuleId++;\n        }\n      }\n    }\n  }\n\n  applyChunkIds() {\n    /** @type {Set<number>} */\n    const usedIds = new Set(); // Get used ids from usedChunkIds property (i. e. from records)\n\n    if (this.usedChunkIds) {\n      for (const id of this.usedChunkIds) {\n        if (typeof id !== \"number\") {\n          continue;\n        }\n\n        usedIds.add(id);\n      }\n    } // Get used ids from existing chunks\n\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n      const usedIdValue = chunk.id;\n\n      if (typeof usedIdValue !== \"number\") {\n        continue;\n      }\n\n      usedIds.add(usedIdValue);\n    } // Calculate maximum assigned chunk id\n\n\n    let nextFreeChunkId = -1;\n\n    for (const id of usedIds) {\n      nextFreeChunkId = Math.max(nextFreeChunkId, id);\n    }\n\n    nextFreeChunkId++; // Determine free chunk ids from 0 to maximum\n\n    /** @type {number[]} */\n\n    const unusedIds = [];\n\n    if (nextFreeChunkId > 0) {\n      let index = nextFreeChunkId;\n\n      while (index--) {\n        if (!usedIds.has(index)) {\n          unusedIds.push(index);\n        }\n      }\n    } // Assign ids to chunk which has no id\n\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n\n      if (chunk.id === null) {\n        if (unusedIds.length > 0) {\n          chunk.id = unusedIds.pop();\n        } else {\n          chunk.id = nextFreeChunkId++;\n        }\n      }\n\n      if (!chunk.ids) {\n        chunk.ids = [chunk.id];\n      }\n    }\n  }\n\n  sortItemsWithModuleIds() {\n    this.modules.sort(byIdOrIdentifier);\n    const modules = this.modules;\n\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      modules[indexModule].sortItems(false);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n\n    chunks.sort((a, b) => a.compareTo(b));\n  }\n\n  sortItemsWithChunkIds() {\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.sortItems();\n    }\n\n    this.chunks.sort(byId);\n\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      this.modules[indexModule].sortItems(true);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n    /**\n     * Used to sort errors and warnings in compilation. this.warnings, and\n     * this.errors contribute to the compilation hash and therefore should be\n     * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n     * integrity\n     *\n     * @param {WebpackError} a first WebpackError instance (including subclasses)\n     * @param {WebpackError} b second WebpackError instance (including subclasses)\n     * @returns {-1|0|1} sort order index\n     */\n\n\n    const byMessage = (a, b) => {\n      const ma = `${a.message}`;\n      const mb = `${b.message}`;\n      if (ma < mb) return -1;\n      if (mb < ma) return 1;\n      return 0;\n    };\n\n    this.errors.sort(byMessage);\n    this.warnings.sort(byMessage);\n    this.children.sort(byNameOrHash);\n  }\n\n  summarizeDependencies() {\n    this.fileDependencies = new SortableSet(this.compilationDependencies);\n    this.contextDependencies = new SortableSet();\n    this.missingDependencies = new SortableSet();\n\n    for (let indexChildren = 0; indexChildren < this.children.length; indexChildren++) {\n      const child = this.children[indexChildren];\n      addAllToSet(this.fileDependencies, child.fileDependencies);\n      addAllToSet(this.contextDependencies, child.contextDependencies);\n      addAllToSet(this.missingDependencies, child.missingDependencies);\n    }\n\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      const module = this.modules[indexModule];\n\n      if (module.buildInfo.fileDependencies) {\n        addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);\n      }\n\n      if (module.buildInfo.contextDependencies) {\n        addAllToSet(this.contextDependencies, module.buildInfo.contextDependencies);\n      }\n    }\n\n    for (const error of this.errors) {\n      if (typeof error.missing === \"object\" && error.missing && error.missing[Symbol.iterator]) {\n        addAllToSet(this.missingDependencies, error.missing);\n      }\n    }\n\n    this.fileDependencies.sort();\n    this.contextDependencies.sort();\n    this.missingDependencies.sort();\n  }\n\n  createHash() {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n\n    if (outputOptions.hashSalt) {\n      hash.update(outputOptions.hashSalt);\n    }\n\n    this.mainTemplate.updateHash(hash);\n    this.chunkTemplate.updateHash(hash);\n\n    for (const key of Object.keys(this.moduleTemplates).sort()) {\n      this.moduleTemplates[key].updateHash(hash);\n    }\n\n    for (const child of this.children) {\n      hash.update(child.hash);\n    }\n\n    for (const warning of this.warnings) {\n      hash.update(`${warning.message}`);\n    }\n\n    for (const error of this.errors) {\n      hash.update(`${error.message}`);\n    }\n\n    const modules = this.modules;\n\n    for (let i = 0; i < modules.length; i++) {\n      const module = modules[i];\n      const moduleHash = createHash(hashFunction);\n      module.updateHash(moduleHash);\n      module.hash =\n      /** @type {string} */\n      moduleHash.digest(hashDigest);\n      module.renderedHash = module.hash.substr(0, hashDigestLength);\n    } // clone needed as sort below is inplace mutation\n\n\n    const chunks = this.chunks.slice();\n    /**\n     * sort here will bring all \"falsy\" values to the beginning\n     * this is needed as the \"hasRuntime()\" chunks are dependent on the\n     * hashes of the non-runtime chunks.\n     */\n\n    chunks.sort((a, b) => {\n      const aEntry = a.hasRuntime();\n      const bEntry = b.hasRuntime();\n      if (aEntry && !bEntry) return 1;\n      if (!aEntry && bEntry) return -1;\n      return byId(a, b);\n    });\n\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const chunkHash = createHash(hashFunction);\n\n      try {\n        if (outputOptions.hashSalt) {\n          chunkHash.update(outputOptions.hashSalt);\n        }\n\n        chunk.updateHash(chunkHash);\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        template.updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates);\n        this.hooks.chunkHash.call(chunk, chunkHash);\n        chunk.hash =\n        /** @type {string} */\n        chunkHash.digest(hashDigest);\n        hash.update(chunk.hash);\n        chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n        this.hooks.contentHash.call(chunk);\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, \"\", err));\n      }\n    }\n\n    this.fullHash =\n    /** @type {string} */\n    hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n  /**\n   * @param {string} update extra information\n   * @returns {void}\n   */\n\n\n  modifyHash(update) {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n    hash.update(this.fullHash);\n    hash.update(update);\n    this.fullHash =\n    /** @type {string} */\n    hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n  /**\n   * @param {string} file file name\n   * @param {Source} source asset source\n   * @param {AssetInfo} assetInfo extra asset information\n   * @returns {void}\n   */\n\n\n  emitAsset(file, source) {\n    let assetInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (this.assets[file]) {\n      if (!isSourceEqual(this.assets[file], source)) {\n        // TODO webpack 5: make this an error instead\n        this.warnings.push(new WebpackError(`Conflict: Multiple assets emit different content to the same filename ${file}`));\n        this.assets[file] = source;\n        this.assetsInfo.set(file, assetInfo);\n        return;\n      }\n\n      const oldInfo = this.assetsInfo.get(file);\n      this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));\n      return;\n    }\n\n    this.assets[file] = source;\n    this.assetsInfo.set(file, assetInfo);\n  }\n  /**\n   * @param {string} file file name\n   * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new\n   * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new\n   */\n\n\n  updateAsset(file, newSourceOrFunction) {\n    let assetInfoUpdateOrFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    if (!this.assets[file]) {\n      throw new Error(`Called Compilation.updateAsset for not existing filename ${file}`);\n    }\n\n    if (typeof newSourceOrFunction === \"function\") {\n      this.assets[file] = newSourceOrFunction(this.assets[file]);\n    } else {\n      this.assets[file] = newSourceOrFunction;\n    }\n\n    if (assetInfoUpdateOrFunction !== undefined) {\n      const oldInfo = this.assetsInfo.get(file);\n\n      if (typeof assetInfoUpdateOrFunction === \"function\") {\n        this.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));\n      } else {\n        this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfoUpdateOrFunction));\n      }\n    }\n  }\n\n  getAssets() {\n    /** @type {Asset[]} */\n    const array = [];\n\n    for (const assetName of Object.keys(this.assets)) {\n      if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {\n        array.push({\n          name: assetName,\n          source: this.assets[assetName],\n          info: this.assetsInfo.get(assetName) || {}\n        });\n      }\n    }\n\n    return array;\n  }\n  /**\n   * @param {string} name the name of the asset\n   * @returns {Asset | undefined} the asset or undefined when not found\n   */\n\n\n  getAsset(name) {\n    if (!Object.prototype.hasOwnProperty.call(this.assets, name)) return undefined;\n    return {\n      name,\n      source: this.assets[name],\n      info: this.assetsInfo.get(name) || {}\n    };\n  }\n\n  createModuleAssets() {\n    for (let i = 0; i < this.modules.length; i++) {\n      const module = this.modules[i];\n\n      if (module.buildInfo.assets) {\n        const assetsInfo = module.buildInfo.assetsInfo;\n\n        for (const assetName of Object.keys(module.buildInfo.assets)) {\n          const fileName = this.getPath(assetName);\n          this.emitAsset(fileName, module.buildInfo.assets[assetName], assetsInfo ? assetsInfo.get(assetName) : undefined);\n          this.hooks.moduleAsset.call(module, fileName);\n        }\n      }\n    }\n  }\n\n  createChunkAssets() {\n    const outputOptions = this.outputOptions;\n    const cachedSourceMap = new Map();\n    /** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n\n    const alreadyWrittenFiles = new Map();\n\n    for (let i = 0; i < this.chunks.length; i++) {\n      const chunk = this.chunks[i];\n      chunk.files = [];\n      let source;\n      let file;\n      let filenameTemplate;\n\n      try {\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        const manifest = template.getRenderManifest({\n          chunk,\n          hash: this.hash,\n          fullHash: this.fullHash,\n          outputOptions,\n          moduleTemplates: this.moduleTemplates,\n          dependencyTemplates: this.dependencyTemplates\n        }); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n\n        for (const fileManifest of manifest) {\n          const cacheName = fileManifest.identifier;\n          const usedHash = fileManifest.hash;\n          filenameTemplate = fileManifest.filenameTemplate;\n          const pathAndInfo = this.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);\n          file = pathAndInfo.path;\n          const assetInfo = pathAndInfo.info; // check if the same filename was already written by another chunk\n\n          const alreadyWritten = alreadyWrittenFiles.get(file);\n\n          if (alreadyWritten !== undefined) {\n            if (alreadyWritten.hash === usedHash) {\n              if (this.cache) {\n                this.cache[cacheName] = {\n                  hash: usedHash,\n                  source: alreadyWritten.source\n                };\n              }\n\n              chunk.files.push(file);\n              this.hooks.chunkAsset.call(chunk, file);\n              continue;\n            } else {\n              throw new Error(`Conflict: Multiple chunks emit assets to the same filename ${file}` + ` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`);\n            }\n          }\n\n          if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) {\n            source = this.cache[cacheName].source;\n          } else {\n            source = fileManifest.render(); // Ensure that source is a cached source to avoid additional cost because of repeated access\n\n            if (!(source instanceof CachedSource)) {\n              const cacheEntry = cachedSourceMap.get(source);\n\n              if (cacheEntry) {\n                source = cacheEntry;\n              } else {\n                const cachedSource = new CachedSource(source);\n                cachedSourceMap.set(source, cachedSource);\n                source = cachedSource;\n              }\n            }\n\n            if (this.cache) {\n              this.cache[cacheName] = {\n                hash: usedHash,\n                source\n              };\n            }\n          }\n\n          this.emitAsset(file, source, assetInfo);\n          chunk.files.push(file);\n          this.hooks.chunkAsset.call(chunk, file);\n          alreadyWrittenFiles.set(file, {\n            hash: usedHash,\n            source,\n            chunk\n          });\n        }\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));\n      }\n    }\n  }\n  /**\n   * @param {string} filename used to get asset path with hash\n   * @param {TODO=} data // TODO: figure out this param type\n   * @returns {string} interpolated path\n   */\n\n\n  getPath(filename, data) {\n    data = data || {};\n    data.hash = data.hash || this.hash;\n    return this.mainTemplate.getAssetPath(filename, data);\n  }\n  /**\n   * @param {string} filename used to get asset path with hash\n   * @param {TODO=} data // TODO: figure out this param type\n   * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info\n   */\n\n\n  getPathWithInfo(filename, data) {\n    data = data || {};\n    data.hash = data.hash || this.hash;\n    return this.mainTemplate.getAssetPathWithInfo(filename, data);\n  }\n  /**\n   * This function allows you to run another instance of webpack inside of webpack however as\n   * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n   * from parent (or top level compiler) and creates a child Compilation\n   *\n   * @param {string} name name of the child compiler\n   * @param {TODO} outputOptions // Need to convert config schema to types for this\n   * @param {Plugin[]} plugins webpack plugins that will be applied\n   * @returns {Compiler} creates a child Compiler instance\n   */\n\n\n  createChildCompiler(name, outputOptions, plugins) {\n    const idx = this.childrenCounters[name] || 0;\n    this.childrenCounters[name] = idx + 1;\n    return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);\n  }\n\n  checkConstraints() {\n    /** @type {Set<number|string>} */\n    const usedIds = new Set();\n    const modules = this.modules;\n\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      const moduleId = modules[indexModule].id;\n      if (moduleId === null) continue;\n\n      if (usedIds.has(moduleId)) {\n        throw new Error(`checkConstraints: duplicate module id ${moduleId}`);\n      }\n\n      usedIds.add(moduleId);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n\n      if (chunks.indexOf(chunk) !== indexChunk) {\n        throw new Error(`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`);\n      }\n    }\n\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.checkConstraints();\n    }\n  }\n\n} // TODO remove in webpack 5\n\n\nCompilation.prototype.applyPlugins = util.deprecate(\n/**\n * @deprecated\n * @param {string} name Name\n * @param {any[]} args Other arguments\n * @returns {void}\n * @this {Compilation}\n */\nfunction (name) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  this.hooks[name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())].call(...args);\n}, \"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\"); // TODO remove in webpack 5\n\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Compilation}\n   * @returns {TODO} module template\n   */\n  function () {\n    return this.moduleTemplates.javascript;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {ModuleTemplate} value Template value\n   * @this {Compilation}\n   * @returns {void}\n   */\n  function (value) {\n    this.moduleTemplates.javascript = value;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\")\n});\nmodule.exports = Compilation;","map":{"version":3,"names":["asyncLib","require","util","CachedSource","Tapable","SyncHook","SyncBailHook","SyncWaterfallHook","AsyncSeriesHook","EntryModuleNotFoundError","ModuleNotFoundError","ModuleDependencyWarning","ModuleDependencyError","ChunkGroup","Chunk","Entrypoint","MainTemplate","ChunkTemplate","HotUpdateChunkTemplate","ModuleTemplate","RuntimeTemplate","ChunkRenderError","Stats","Semaphore","createHash","SortableSet","GraphHelpers","ModuleDependency","compareLocations","Logger","LogType","ErrorHelpers","buildChunkGraph","WebpackError","byId","a","b","id","byIdOrIdentifier","identA","identifier","identB","byIndexOrIdentifier","index","byNameOrHash","name","fullHash","iterationBlockVariable","variables","fn","indexVariable","length","varDep","dependencies","indexVDep","iterationOfArrayCallback","arr","addAllToSet","set","otherSet","item","add","isSourceEqual","aSource","source","bSource","Buffer","isBuffer","from","equals","Compilation","constructor","compiler","hooks","buildModule","rebuildModule","failedModule","succeedModule","addEntry","failedEntry","succeedEntry","dependencyReference","finishModules","finishRebuildingModule","unseal","seal","beforeChunks","afterChunks","optimizeDependenciesBasic","optimizeDependencies","optimizeDependenciesAdvanced","afterOptimizeDependencies","optimize","optimizeModulesBasic","optimizeModules","optimizeModulesAdvanced","afterOptimizeModules","optimizeChunksBasic","optimizeChunks","optimizeChunksAdvanced","afterOptimizeChunks","optimizeTree","afterOptimizeTree","optimizeChunkModulesBasic","optimizeChunkModules","optimizeChunkModulesAdvanced","afterOptimizeChunkModules","shouldRecord","reviveModules","optimizeModuleOrder","advancedOptimizeModuleOrder","beforeModuleIds","moduleIds","optimizeModuleIds","afterOptimizeModuleIds","reviveChunks","optimizeChunkOrder","beforeChunkIds","optimizeChunkIds","afterOptimizeChunkIds","recordModules","recordChunks","beforeHash","contentHash","afterHash","recordHash","record","beforeModuleAssets","shouldGenerateChunkAssets","beforeChunkAssets","additionalChunkAssets","additionalAssets","optimizeChunkAssets","afterOptimizeChunkAssets","optimizeAssets","afterOptimizeAssets","needAdditionalSeal","afterSeal","chunkHash","moduleAsset","chunkAsset","assetPath","needAdditionalPass","childCompiler","log","normalModuleLoader","optimizeExtractedChunksBasic","optimizeExtractedChunks","optimizeExtractedChunksAdvanced","afterOptimizeExtractedChunks","_pluginCompat","tap","options","async","undefined","resolverFactory","inputFileSystem","requestShortener","outputOptions","output","bail","profile","performance","mainTemplate","chunkTemplate","hotUpdateChunkTemplate","runtimeTemplate","moduleTemplates","javascript","webassembly","semaphore","parallelism","entries","_preparedEntrypoints","entrypoints","Map","chunks","chunkGroups","namedChunkGroups","namedChunks","modules","_modules","cache","records","assets","assetsInfo","errors","warnings","children","logging","dependencyFactories","dependencyTemplates","childrenCounters","usedChunkIds","usedModuleIds","fileTimestamps","contextTimestamps","compilationDependencies","_buildingModules","_rebuildingModules","emittedAssets","Set","getStats","getLogger","TypeError","logEntries","type","args","trace","warn","error","cutOffLoaderExecution","Error","stack","split","slice","logEntry","time","Date","now","call","profileEnd","console","get","push","addModule","module","cacheGroup","alreadyAddedModule","issuer","build","cacheName","cacheModule","updateCacheModule","rebuild","needRebuild","disconnect","err","unbuild","getModule","findModule","waitForBuildingFinished","callback","callbackList","process","nextTick","optional","origin","thisCallback","delete","cb","resolveOptions","indexError","indexWarning","war","originalMap","reduce","map","v","i","sort","cmp","loc","processModuleDependencies","addDependency","dep","resourceIdent","getResourceIdentifier","factory","innerMap","list","addDependenciesBlock","block","blocks","e","sortedDependencies","pair1","pair2","addModuleDependencies","recursive","start","currentProfile","forEach","errorAndCallback","warningAndCallback","acquire","create","contextInfo","nameForCondition","context","dependentModule","afterFactory","isOptional","every","d","errorOrWarningAndCallback","release","iterationDependencies","depend","addReason","addModuleResult","afterBuild","afterBuilding","building","_addModuleChain","dependency","onModule","Dep","moduleFactory","entry","slot","request","idx","findIndex","indexOf","splice","prefetch","prefetched","oldDependencies","oldVariables","oldBlocks","removeReasonsOfDependencyBlock","finish","callAsync","reportDependencyErrorsAndWarnings","clear","preparedEntrypoint","chunk","addChunk","entrypoint","setRuntimeChunk","addOrigin","connectChunkGroupAndChunk","connectChunkAndModule","entryModule","assignDepth","sortModules","applyModuleIds","sortItemsWithModuleIds","applyChunkIds","sortItemsWithChunkIds","createModuleAssets","createChunkAssets","summarizeDependencies","indexBlock","indexDep","getWarnings","indexWar","w","warning","getErrors","indexErr","addChunkInGroup","groupOptions","chunkGroup","addOptions","queue","depth","enqueueJob","assignDepthToDependency","assignDepthToDependencyBlock","getDependencyReference","getReference","ref","iteratorDependency","removeReason","chunksIterable","patchChunksAfterReasonRemoval","hasReasons","hasReasonForChunk","removeChunk","removeChunkFromDependencies","asyncBlock","indexChunk","iteratedChunk","removeParent","unusedIds","nextFreeModuleId","usedIds","modules1","indexModule1","module1","size","usedIdMax","usedIdKey","Math","max","lengthFreeModules","has","modules2","indexModule2","module2","pop","usedIdValue","nextFreeChunkId","ids","indexModule","sortItems","compareTo","byMessage","ma","message","mb","fileDependencies","contextDependencies","missingDependencies","indexChildren","child","buildInfo","missing","Symbol","iterator","hashFunction","hashDigest","hashDigestLength","hash","hashSalt","update","updateHash","key","Object","keys","moduleHash","digest","renderedHash","substr","aEntry","hasRuntime","bEntry","template","updateHashForChunk","modifyHash","emitAsset","file","assetInfo","oldInfo","assign","updateAsset","newSourceOrFunction","assetInfoUpdateOrFunction","getAssets","array","assetName","prototype","hasOwnProperty","info","getAsset","fileName","getPath","cachedSourceMap","alreadyWrittenFiles","files","filenameTemplate","manifest","getRenderManifest","fileManifest","usedHash","pathAndInfo","getPathWithInfo","pathOptions","path","alreadyWritten","render","cacheEntry","cachedSource","filename","data","getAssetPath","getAssetPathWithInfo","createChildCompiler","plugins","checkConstraints","moduleId","debugId","applyPlugins","deprecate","replace","match","toUpperCase","defineProperty","configurable","value","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/Compilation.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst util = require(\"util\");\nconst { CachedSource } = require(\"webpack-sources\");\nconst {\n\tTapable,\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\nconst ModuleNotFoundError = require(\"./ModuleNotFoundError\");\nconst ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\nconst ModuleDependencyError = require(\"./ModuleDependencyError\");\nconst ChunkGroup = require(\"./ChunkGroup\");\nconst Chunk = require(\"./Chunk\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst MainTemplate = require(\"./MainTemplate\");\nconst ChunkTemplate = require(\"./ChunkTemplate\");\nconst HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\nconst ModuleTemplate = require(\"./ModuleTemplate\");\nconst RuntimeTemplate = require(\"./RuntimeTemplate\");\nconst ChunkRenderError = require(\"./ChunkRenderError\");\nconst Stats = require(\"./Stats\");\nconst Semaphore = require(\"./util/Semaphore\");\nconst createHash = require(\"./util/createHash\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst ModuleDependency = require(\"./dependencies/ModuleDependency\");\nconst compareLocations = require(\"./compareLocations\");\nconst { Logger, LogType } = require(\"./logging/Logger\");\nconst ErrorHelpers = require(\"./ErrorHelpers\");\nconst buildChunkGraph = require(\"./buildChunkGraph\");\nconst WebpackError = require(\"./WebpackError\");\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n// TODO use @callback\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n/** @typedef {(module: Module) => void} OnModuleCallback */\n/** @typedef {(err?: Error|null) => void} Callback */\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @typedef {Object} LogEntry\n * @property {string} type\n * @property {any[]} args\n * @property {number} time\n * @property {string[]=} trace\n */\n\n/**\n * @typedef {Object} AssetInfo\n * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)\n * @property {number=} size size in bytes, only set after asset has been emitted\n * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets\n * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)\n */\n\n/**\n * @typedef {Object} Asset\n * @property {string} name the filename of the asset\n * @property {Source} source source of the asset\n * @property {AssetInfo} info info about the asset\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\nconst byId = (a, b) => {\n\tif (typeof a.id !== typeof b.id) {\n\t\treturn typeof a.id < typeof b.id ? -1 : 1;\n\t}\n\tif (a.id < b.id) return -1;\n\tif (a.id > b.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIdOrIdentifier = (a, b) => {\n\tif (typeof a.id !== typeof b.id) {\n\t\treturn typeof a.id < typeof b.id ? -1 : 1;\n\t}\n\tif (a.id < b.id) return -1;\n\tif (a.id > b.id) return 1;\n\tconst identA = a.identifier();\n\tconst identB = b.identifier();\n\tif (identA < identB) return -1;\n\tif (identA > identB) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIndexOrIdentifier = (a, b) => {\n\tif (a.index < b.index) return -1;\n\tif (a.index > b.index) return 1;\n\tconst identA = a.identifier();\n\tconst identB = b.identifier();\n\tif (identA < identB) return -1;\n\tif (identA > identB) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\nconst byNameOrHash = (a, b) => {\n\tif (a.name < b.name) return -1;\n\tif (a.name > b.name) return 1;\n\tif (a.fullHash < b.fullHash) return -1;\n\tif (a.fullHash > b.fullHash) return 1;\n\treturn 0;\n};\n\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\nconst iterationBlockVariable = (variables, fn) => {\n\tfor (\n\t\tlet indexVariable = 0;\n\t\tindexVariable < variables.length;\n\t\tindexVariable++\n\t) {\n\t\tconst varDep = variables[indexVariable].dependencies;\n\t\tfor (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n\t\t\tfn(varDep[indexVDep]);\n\t\t}\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\nconst iterationOfArrayCallback = (arr, fn) => {\n\tfor (let index = 0; index < arr.length; index++) {\n\t\tfn(arr[index]);\n\t}\n};\n\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tfor (const item of otherSet) {\n\t\tset.add(item);\n\t}\n};\n\n/**\n * @param {Source} a a source\n * @param {Source} b another source\n * @returns {boolean} true, when both sources are equal\n */\nconst isSourceEqual = (a, b) => {\n\tif (a === b) return true;\n\t// TODO webpack 5: check .buffer() instead, it's called anyway during emit\n\t/** @type {Buffer|string} */\n\tlet aSource = a.source();\n\t/** @type {Buffer|string} */\n\tlet bSource = b.source();\n\tif (aSource === bSource) return true;\n\tif (typeof aSource === \"string\" && typeof bSource === \"string\") return false;\n\tif (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, \"utf-8\");\n\tif (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, \"utf-8\");\n\treturn aSource.equals(bSource);\n};\n\nclass Compilation extends Tapable {\n\t/**\n\t * Creates an instance of Compilation.\n\t * @param {Compiler} compiler the compiler which created the compilation\n\t */\n\tconstructor(compiler) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tbuildModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\trebuildModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook<Module, Error>} */\n\t\t\tfailedModule: new SyncHook([\"module\", \"error\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tsucceedModule: new SyncHook([\"module\"]),\n\n\t\t\t/** @type {SyncHook<Dependency, string>} */\n\t\t\taddEntry: new SyncHook([\"entry\", \"name\"]),\n\t\t\t/** @type {SyncHook<Dependency, string, Error>} */\n\t\t\tfailedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n\t\t\t/** @type {SyncHook<Dependency, string, Module>} */\n\t\t\tsucceedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n\n\t\t\t/** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n\t\t\tdependencyReference: new SyncWaterfallHook([\n\t\t\t\t\"dependencyReference\",\n\t\t\t\t\"dependency\",\n\t\t\t\t\"module\"\n\t\t\t]),\n\n\t\t\t/** @type {AsyncSeriesHook<Module[]>} */\n\t\t\tfinishModules: new AsyncSeriesHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tfinishRebuildingModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tunseal: new SyncHook([]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tseal: new SyncHook([]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeChunks: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterChunks: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependencies: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\tafterOptimizeDependencies: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\toptimize: new SyncHook([]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModulesBasic: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModules: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tafterOptimizeModules: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n\t\t\tafterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n\t\t\toptimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncHook<Chunk[], Module[]>} */\n\t\t\tafterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncHook<Chunk[], Module[]>} */\n\t\t\tafterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tshouldRecord: new SyncBailHook([]),\n\n\t\t\t/** @type {SyncHook<Module[], any>} */\n\t\t\treviveModules: new SyncHook([\"modules\", \"records\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\toptimizeModuleOrder: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tadvancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tbeforeModuleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tmoduleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\toptimizeModuleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tafterOptimizeModuleIds: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncHook<Chunk[], any>} */\n\t\t\treviveChunks: new SyncHook([\"chunks\", \"records\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\toptimizeChunkOrder: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tbeforeChunkIds: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\toptimizeChunkIds: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {SyncHook<Module[], any>} */\n\t\t\trecordModules: new SyncHook([\"modules\", \"records\"]),\n\t\t\t/** @type {SyncHook<Chunk[], any>} */\n\t\t\trecordChunks: new SyncHook([\"chunks\", \"records\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeHash: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk>} */\n\t\t\tcontentHash: new SyncHook([\"chunk\"]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tafterHash: new SyncHook([]),\n\t\t\t/** @type {SyncHook<any>} */\n\t\t\trecordHash: new SyncHook([\"records\"]),\n\t\t\t/** @type {SyncHook<Compilation, any>} */\n\t\t\trecord: new SyncHook([\"compilation\", \"records\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeModuleAssets: new SyncHook([]),\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tshouldGenerateChunkAssets: new SyncBailHook([]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeChunkAssets: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tadditionalChunkAssets: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {AsyncSeriesHook} */\n\t\t\tadditionalAssets: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<Chunk[]>} */\n\t\t\toptimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {AsyncSeriesHook<CompilationAssets>} */\n\t\t\toptimizeAssets: new AsyncSeriesHook([\"assets\"]),\n\t\t\t/** @type {SyncHook<CompilationAssets>} */\n\t\t\tafterOptimizeAssets: new SyncHook([\"assets\"]),\n\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tneedAdditionalSeal: new SyncBailHook([]),\n\t\t\t/** @type {AsyncSeriesHook} */\n\t\t\tafterSeal: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncHook<Chunk, Hash>} */\n\t\t\tchunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n\t\t\t/** @type {SyncHook<Module, string>} */\n\t\t\tmoduleAsset: new SyncHook([\"module\", \"filename\"]),\n\t\t\t/** @type {SyncHook<Chunk, string>} */\n\t\t\tchunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n\n\t\t\t/** @type {SyncWaterfallHook<string, TODO>} */\n\t\t\tassetPath: new SyncWaterfallHook([\"filename\", \"data\"]), // TODO MainTemplate\n\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tneedAdditionalPass: new SyncBailHook([]),\n\n\t\t\t/** @type {SyncHook<Compiler, string, number>} */\n\t\t\tchildCompiler: new SyncHook([\n\t\t\t\t\"childCompiler\",\n\t\t\t\t\"compilerName\",\n\t\t\t\t\"compilerIndex\"\n\t\t\t]),\n\n\t\t\t/** @type {SyncBailHook<string, LogEntry>} */\n\t\t\tlog: new SyncBailHook([\"origin\", \"logEntry\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<object, Module>} */\n\t\t\tnormalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n\t\t};\n\t\tthis._pluginCompat.tap(\"Compilation\", options => {\n\t\t\tswitch (options.name) {\n\t\t\t\tcase \"optimize-tree\":\n\t\t\t\tcase \"additional-assets\":\n\t\t\t\tcase \"optimize-chunk-assets\":\n\t\t\t\tcase \"optimize-assets\":\n\t\t\t\tcase \"after-seal\":\n\t\t\t\t\toptions.async = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.compiler = compiler;\n\t\tthis.resolverFactory = compiler.resolverFactory;\n\t\tthis.inputFileSystem = compiler.inputFileSystem;\n\t\tthis.requestShortener = compiler.requestShortener;\n\n\t\tconst options = compiler.options;\n\t\tthis.options = options;\n\t\tthis.outputOptions = options && options.output;\n\t\t/** @type {boolean=} */\n\t\tthis.bail = options && options.bail;\n\t\tthis.profile = options && options.profile;\n\t\tthis.performance = options && options.performance;\n\n\t\tthis.mainTemplate = new MainTemplate(this.outputOptions);\n\t\tthis.chunkTemplate = new ChunkTemplate(this.outputOptions);\n\t\tthis.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(\n\t\t\tthis.outputOptions\n\t\t);\n\t\tthis.runtimeTemplate = new RuntimeTemplate(\n\t\t\tthis.outputOptions,\n\t\t\tthis.requestShortener\n\t\t);\n\t\tthis.moduleTemplates = {\n\t\t\tjavascript: new ModuleTemplate(this.runtimeTemplate, \"javascript\"),\n\t\t\twebassembly: new ModuleTemplate(this.runtimeTemplate, \"webassembly\")\n\t\t};\n\n\t\tthis.semaphore = new Semaphore(options.parallelism || 100);\n\n\t\tthis.entries = [];\n\t\t/** @private @type {{name: string, request: string, module: Module}[]} */\n\t\tthis._preparedEntrypoints = [];\n\t\t/** @type {Map<string, Entrypoint>} */\n\t\tthis.entrypoints = new Map();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {ChunkGroup[]} */\n\t\tthis.chunkGroups = [];\n\t\t/** @type {Map<string, ChunkGroup>} */\n\t\tthis.namedChunkGroups = new Map();\n\t\t/** @type {Map<string, Chunk>} */\n\t\tthis.namedChunks = new Map();\n\t\t/** @type {Module[]} */\n\t\tthis.modules = [];\n\t\t/** @private @type {Map<string, Module>} */\n\t\tthis._modules = new Map();\n\t\tthis.cache = null;\n\t\tthis.records = null;\n\t\t/** @type {string[]} */\n\t\tthis.additionalChunkAssets = [];\n\t\t/** @type {CompilationAssets} */\n\t\tthis.assets = {};\n\t\t/** @type {Map<string, AssetInfo>} */\n\t\tthis.assetsInfo = new Map();\n\t\t/** @type {WebpackError[]} */\n\t\tthis.errors = [];\n\t\t/** @type {WebpackError[]} */\n\t\tthis.warnings = [];\n\t\t/** @type {Compilation[]} */\n\t\tthis.children = [];\n\t\t/** @type {Map<string, LogEntry[]>} */\n\t\tthis.logging = new Map();\n\t\t/** @type {Map<DepConstructor, ModuleFactory>} */\n\t\tthis.dependencyFactories = new Map();\n\t\t/** @type {Map<DepConstructor, DependencyTemplate>} */\n\t\tthis.dependencyTemplates = new Map();\n\t\t// TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n\t\t// @ts-ignore\n\t\tthis.dependencyTemplates.set(\"hash\", \"\");\n\t\tthis.childrenCounters = {};\n\t\t/** @type {Set<number|string>} */\n\t\tthis.usedChunkIds = null;\n\t\t/** @type {Set<number>} */\n\t\tthis.usedModuleIds = null;\n\t\t/** @type {Map<string, number>=} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {Map<string, number>=} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {Set<string>=} */\n\t\tthis.compilationDependencies = undefined;\n\t\t/** @private @type {Map<Module, Callback[]>} */\n\t\tthis._buildingModules = new Map();\n\t\t/** @private @type {Map<Module, Callback[]>} */\n\t\tthis._rebuildingModules = new Map();\n\t\t/** @type {Set<string>} */\n\t\tthis.emittedAssets = new Set();\n\t}\n\n\tgetStats() {\n\t\treturn new Stats(this);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\"Compilation.getLogger(name) called without a name\");\n\t\t}\n\t\t/** @type {LogEntry[] | undefined} */\n\t\tlet logEntries;\n\t\treturn new Logger((type, args) => {\n\t\t\tif (typeof name === \"function\") {\n\t\t\t\tname = name();\n\t\t\t\tif (!name) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\"Compilation.getLogger(name) called with a function not returning a name\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet trace;\n\t\t\tswitch (type) {\n\t\t\t\tcase LogType.warn:\n\t\t\t\tcase LogType.error:\n\t\t\t\tcase LogType.trace:\n\t\t\t\t\ttrace = ErrorHelpers.cutOffLoaderExecution(new Error(\"Trace\").stack)\n\t\t\t\t\t\t.split(\"\\n\")\n\t\t\t\t\t\t.slice(3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/** @type {LogEntry} */\n\t\t\tconst logEntry = {\n\t\t\t\ttime: Date.now(),\n\t\t\t\ttype,\n\t\t\t\targs,\n\t\t\t\ttrace\n\t\t\t};\n\t\t\tif (this.hooks.log.call(name, logEntry) === undefined) {\n\t\t\t\tif (logEntry.type === LogType.profileEnd) {\n\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\tif (typeof console.profileEnd === \"function\") {\n\t\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\t\tconsole.profileEnd(`[${name}] ${logEntry.args[0]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (logEntries === undefined) {\n\t\t\t\t\tlogEntries = this.logging.get(name);\n\t\t\t\t\tif (logEntries === undefined) {\n\t\t\t\t\t\tlogEntries = [];\n\t\t\t\t\t\tthis.logging.set(name, logEntries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogEntries.push(logEntry);\n\t\t\t\tif (logEntry.type === LogType.profile) {\n\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\tif (typeof console.profile === \"function\") {\n\t\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\t\tconsole.profile(`[${name}] ${logEntry.args[0]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @typedef {Object} AddModuleResult\n\t * @property {Module} module the added or existing module\n\t * @property {boolean} issuer was this the first request for this module\n\t * @property {boolean} build should the module be build\n\t * @property {boolean} dependencies should dependencies be walked\n\t */\n\n\t/**\n\t * @param {Module} module module to be added that was created\n\t * @param {any=} cacheGroup cacheGroup it is apart of\n\t * @returns {AddModuleResult} returns meta about whether or not the module had built\n\t * had an issuer, or any dependnecies\n\t */\n\taddModule(module, cacheGroup) {\n\t\tconst identifier = module.identifier();\n\t\tconst alreadyAddedModule = this._modules.get(identifier);\n\t\tif (alreadyAddedModule) {\n\t\t\treturn {\n\t\t\t\tmodule: alreadyAddedModule,\n\t\t\t\tissuer: false,\n\t\t\t\tbuild: false,\n\t\t\t\tdependencies: false\n\t\t\t};\n\t\t}\n\t\tconst cacheName = (cacheGroup || \"m\") + identifier;\n\t\tif (this.cache && this.cache[cacheName]) {\n\t\t\tconst cacheModule = this.cache[cacheName];\n\n\t\t\tif (typeof cacheModule.updateCacheModule === \"function\") {\n\t\t\t\tcacheModule.updateCacheModule(module);\n\t\t\t}\n\n\t\t\tlet rebuild = true;\n\t\t\tif (this.fileTimestamps && this.contextTimestamps) {\n\t\t\t\trebuild = cacheModule.needRebuild(\n\t\t\t\t\tthis.fileTimestamps,\n\t\t\t\t\tthis.contextTimestamps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!rebuild) {\n\t\t\t\tcacheModule.disconnect();\n\t\t\t\tthis._modules.set(identifier, cacheModule);\n\t\t\t\tthis.modules.push(cacheModule);\n\t\t\t\tfor (const err of cacheModule.errors) {\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t}\n\t\t\t\tfor (const err of cacheModule.warnings) {\n\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tmodule: cacheModule,\n\t\t\t\t\tissuer: true,\n\t\t\t\t\tbuild: false,\n\t\t\t\t\tdependencies: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tcacheModule.unbuild();\n\t\t\tmodule = cacheModule;\n\t\t}\n\t\tthis._modules.set(identifier, module);\n\t\tif (this.cache) {\n\t\t\tthis.cache[cacheName] = module;\n\t\t}\n\t\tthis.modules.push(module);\n\t\treturn {\n\t\t\tmodule: module,\n\t\t\tissuer: true,\n\t\t\tbuild: true,\n\t\t\tdependencies: true\n\t\t};\n\t}\n\n\t/**\n\t * Fetches a module from a compilation by its identifier\n\t * @param {Module} module the module provided\n\t * @returns {Module} the module requested\n\t */\n\tgetModule(module) {\n\t\tconst identifier = module.identifier();\n\t\treturn this._modules.get(identifier);\n\t}\n\n\t/**\n\t * Attempts to search for a module by its identifier\n\t * @param {string} identifier identifier (usually path) for module\n\t * @returns {Module|undefined} attempt to search for module and return it, else undefined\n\t */\n\tfindModule(identifier) {\n\t\treturn this._modules.get(identifier);\n\t}\n\n\t/**\n\t * @param {Module} module module with its callback list\n\t * @param {Callback} callback the callback function\n\t * @returns {void}\n\t */\n\twaitForBuildingFinished(module, callback) {\n\t\tlet callbackList = this._buildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(() => callback());\n\t\t} else {\n\t\t\tprocess.nextTick(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the module object\n\t *\n\t * @param {Module} module module to be built\n\t * @param {boolean} optional optional flag\n\t * @param {Module=} origin origin module this module build was requested from\n\t * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n\t * @param {TODO} thisCallback the callback\n\t * @returns {TODO} returns the callback function with results\n\t */\n\tbuildModule(module, optional, origin, dependencies, thisCallback) {\n\t\tlet callbackList = this._buildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(thisCallback);\n\t\t\treturn;\n\t\t}\n\t\tthis._buildingModules.set(module, (callbackList = [thisCallback]));\n\n\t\tconst callback = err => {\n\t\t\tthis._buildingModules.delete(module);\n\t\t\tfor (const cb of callbackList) {\n\t\t\t\tcb(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.buildModule.call(module);\n\t\tmodule.build(\n\t\t\tthis.options,\n\t\t\tthis,\n\t\t\tthis.resolverFactory.get(\"normal\", module.resolveOptions),\n\t\t\tthis.inputFileSystem,\n\t\t\terror => {\n\t\t\t\tconst errors = module.errors;\n\t\t\t\tfor (let indexError = 0; indexError < errors.length; indexError++) {\n\t\t\t\t\tconst err = errors[indexError];\n\t\t\t\t\terr.origin = origin;\n\t\t\t\t\terr.dependencies = dependencies;\n\t\t\t\t\tif (optional) {\n\t\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst warnings = module.warnings;\n\t\t\t\tfor (\n\t\t\t\t\tlet indexWarning = 0;\n\t\t\t\t\tindexWarning < warnings.length;\n\t\t\t\t\tindexWarning++\n\t\t\t\t) {\n\t\t\t\t\tconst war = warnings[indexWarning];\n\t\t\t\t\twar.origin = origin;\n\t\t\t\t\twar.dependencies = dependencies;\n\t\t\t\t\tthis.warnings.push(war);\n\t\t\t\t}\n\t\t\t\tconst originalMap = module.dependencies.reduce((map, v, i) => {\n\t\t\t\t\tmap.set(v, i);\n\t\t\t\t\treturn map;\n\t\t\t\t}, new Map());\n\t\t\t\tmodule.dependencies.sort((a, b) => {\n\t\t\t\t\tconst cmp = compareLocations(a.loc, b.loc);\n\t\t\t\t\tif (cmp) return cmp;\n\t\t\t\t\treturn originalMap.get(a) - originalMap.get(b);\n\t\t\t\t});\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.hooks.failedModule.call(module, error);\n\t\t\t\t\treturn callback(error);\n\t\t\t\t}\n\t\t\t\tthis.hooks.succeedModule.call(module);\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module to be processed for deps\n\t * @param {ModuleCallback} callback callback to be triggered\n\t * @returns {void}\n\t */\n\tprocessModuleDependencies(module, callback) {\n\t\tconst dependencies = new Map();\n\n\t\tconst addDependency = dep => {\n\t\t\tconst resourceIdent = dep.getResourceIdentifier();\n\t\t\tif (resourceIdent) {\n\t\t\t\tconst factory = this.dependencyFactories.get(dep.constructor);\n\t\t\t\tif (factory === undefined) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet innerMap = dependencies.get(factory);\n\t\t\t\tif (innerMap === undefined) {\n\t\t\t\t\tdependencies.set(factory, (innerMap = new Map()));\n\t\t\t\t}\n\t\t\t\tlet list = innerMap.get(resourceIdent);\n\t\t\t\tif (list === undefined) innerMap.set(resourceIdent, (list = []));\n\t\t\t\tlist.push(dep);\n\t\t\t}\n\t\t};\n\n\t\tconst addDependenciesBlock = block => {\n\t\t\tif (block.dependencies) {\n\t\t\t\titerationOfArrayCallback(block.dependencies, addDependency);\n\t\t\t}\n\t\t\tif (block.blocks) {\n\t\t\t\titerationOfArrayCallback(block.blocks, addDependenciesBlock);\n\t\t\t}\n\t\t\tif (block.variables) {\n\t\t\t\titerationBlockVariable(block.variables, addDependency);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\taddDependenciesBlock(module);\n\t\t} catch (e) {\n\t\t\tcallback(e);\n\t\t}\n\n\t\tconst sortedDependencies = [];\n\n\t\tfor (const pair1 of dependencies) {\n\t\t\tfor (const pair2 of pair1[1]) {\n\t\t\t\tsortedDependencies.push({\n\t\t\t\t\tfactory: pair1[0],\n\t\t\t\t\tdependencies: pair2[1]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.addModuleDependencies(\n\t\t\tmodule,\n\t\t\tsortedDependencies,\n\t\t\tthis.bail,\n\t\t\tnull,\n\t\t\ttrue,\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module to add deps to\n\t * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n\t * @param {(boolean|null)=} bail whether to bail or not\n\t * @param {TODO} cacheGroup optional cacheGroup\n\t * @param {boolean} recursive whether it is recursive traversal\n\t * @param {function} callback callback for when dependencies are finished being added\n\t * @returns {void}\n\t */\n\taddModuleDependencies(\n\t\tmodule,\n\t\tdependencies,\n\t\tbail,\n\t\tcacheGroup,\n\t\trecursive,\n\t\tcallback\n\t) {\n\t\tconst start = this.profile && Date.now();\n\t\tconst currentProfile = this.profile && {};\n\n\t\tasyncLib.forEach(\n\t\t\tdependencies,\n\t\t\t(item, callback) => {\n\t\t\t\tconst dependencies = item.dependencies;\n\n\t\t\t\tconst errorAndCallback = err => {\n\t\t\t\t\terr.origin = module;\n\t\t\t\t\terr.dependencies = dependencies;\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\tif (bail) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst warningAndCallback = err => {\n\t\t\t\t\terr.origin = module;\n\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t\tcallback();\n\t\t\t\t};\n\n\t\t\t\tconst semaphore = this.semaphore;\n\t\t\t\tsemaphore.acquire(() => {\n\t\t\t\t\tconst factory = item.factory;\n\t\t\t\t\tfactory.create(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\tissuer: module.nameForCondition && module.nameForCondition(),\n\t\t\t\t\t\t\t\tcompiler: this.compiler.name\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tresolveOptions: module.resolveOptions,\n\t\t\t\t\t\t\tcontext: module.context,\n\t\t\t\t\t\t\tdependencies: dependencies\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, dependentModule) => {\n\t\t\t\t\t\t\tlet afterFactory;\n\n\t\t\t\t\t\t\tconst isOptional = () => {\n\t\t\t\t\t\t\t\treturn dependencies.every(d => d.optional);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst errorOrWarningAndCallback = err => {\n\t\t\t\t\t\t\t\tif (isOptional()) {\n\t\t\t\t\t\t\t\t\treturn warningAndCallback(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn errorAndCallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\treturn errorOrWarningAndCallback(\n\t\t\t\t\t\t\t\t\tnew ModuleNotFoundError(module, err)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dependentModule) {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\tafterFactory = Date.now();\n\t\t\t\t\t\t\t\tcurrentProfile.factory = afterFactory - start;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst iterationDependencies = depend => {\n\t\t\t\t\t\t\t\tfor (let index = 0; index < depend.length; index++) {\n\t\t\t\t\t\t\t\t\tconst dep = depend[index];\n\t\t\t\t\t\t\t\t\tdep.module = dependentModule;\n\t\t\t\t\t\t\t\t\tdependentModule.addReason(module, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst addModuleResult = this.addModule(\n\t\t\t\t\t\t\t\tdependentModule,\n\t\t\t\t\t\t\t\tcacheGroup\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependentModule = addModuleResult.module;\n\t\t\t\t\t\t\titerationDependencies(dependencies);\n\n\t\t\t\t\t\t\tconst afterBuild = () => {\n\t\t\t\t\t\t\t\tif (recursive && addModuleResult.dependencies) {\n\t\t\t\t\t\t\t\t\tthis.processModuleDependencies(dependentModule, callback);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (addModuleResult.issuer) {\n\t\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\t\tdependentModule.profile = currentProfile;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdependentModule.issuer = module;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (this.profile) {\n\t\t\t\t\t\t\t\t\tif (module.profile) {\n\t\t\t\t\t\t\t\t\t\tconst time = Date.now() - start;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!module.profile.dependencies ||\n\t\t\t\t\t\t\t\t\t\t\ttime > module.profile.dependencies\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tmodule.profile.dependencies = time;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (addModuleResult.build) {\n\t\t\t\t\t\t\t\tthis.buildModule(\n\t\t\t\t\t\t\t\t\tdependentModule,\n\t\t\t\t\t\t\t\t\tisOptional(),\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tdependencies,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\t\t\t\treturn errorOrWarningAndCallback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\t\t\t\tconst afterBuilding = Date.now();\n\t\t\t\t\t\t\t\t\t\t\tcurrentProfile.building = afterBuilding - afterFactory;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\t\t\tafterBuild();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\tthis.waitForBuildingFinished(dependentModule, afterBuild);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\t// In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n\t\t\t\t// errors are created inside closures that keep a reference to the Compilation, so errors are\n\t\t\t\t// leaking the Compilation object.\n\n\t\t\t\tif (err) {\n\t\t\t\t\t// eslint-disable-next-line no-self-assign\n\t\t\t\t\terr.stack = err.stack;\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\treturn process.nextTick(callback);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {string} context context string path\n\t * @param {Dependency} dependency dependency used to create Module chain\n\t * @param {OnModuleCallback} onModule function invoked on modules creation\n\t * @param {ModuleChainCallback} callback callback for when module chain is complete\n\t * @returns {void} will throw if dependency instance is not a valid Dependency\n\t */\n\t_addModuleChain(context, dependency, onModule, callback) {\n\t\tconst start = this.profile && Date.now();\n\t\tconst currentProfile = this.profile && {};\n\n\t\tconst errorAndCallback = this.bail\n\t\t\t? err => {\n\t\t\t\t\tcallback(err);\n\t\t\t  }\n\t\t\t: err => {\n\t\t\t\t\terr.dependencies = [dependency];\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\tcallback();\n\t\t\t  };\n\n\t\tif (\n\t\t\ttypeof dependency !== \"object\" ||\n\t\t\tdependency === null ||\n\t\t\t!dependency.constructor\n\t\t) {\n\t\t\tthrow new Error(\"Parameter 'dependency' must be a Dependency\");\n\t\t}\n\t\tconst Dep = /** @type {DepConstructor} */ (dependency.constructor);\n\t\tconst moduleFactory = this.dependencyFactories.get(Dep);\n\t\tif (!moduleFactory) {\n\t\t\tthrow new Error(\n\t\t\t\t`No dependency factory available for this dependency type: ${dependency.constructor.name}`\n\t\t\t);\n\t\t}\n\n\t\tthis.semaphore.acquire(() => {\n\t\t\tmoduleFactory.create(\n\t\t\t\t{\n\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\tissuer: \"\",\n\t\t\t\t\t\tcompiler: this.compiler.name\n\t\t\t\t\t},\n\t\t\t\t\tcontext: context,\n\t\t\t\t\tdependencies: [dependency]\n\t\t\t\t},\n\t\t\t\t(err, module) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\treturn errorAndCallback(new EntryModuleNotFoundError(err));\n\t\t\t\t\t}\n\n\t\t\t\t\tlet afterFactory;\n\n\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\tafterFactory = Date.now();\n\t\t\t\t\t\tcurrentProfile.factory = afterFactory - start;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst addModuleResult = this.addModule(module);\n\t\t\t\t\tmodule = addModuleResult.module;\n\n\t\t\t\t\tonModule(module);\n\n\t\t\t\t\tdependency.module = module;\n\t\t\t\t\tmodule.addReason(null, dependency);\n\n\t\t\t\t\tconst afterBuild = () => {\n\t\t\t\t\t\tif (addModuleResult.dependencies) {\n\t\t\t\t\t\t\tthis.processModuleDependencies(module, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcallback(null, module);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn callback(null, module);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (addModuleResult.issuer) {\n\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\tmodule.profile = currentProfile;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (addModuleResult.build) {\n\t\t\t\t\t\tthis.buildModule(module, false, null, null, err => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\t\t\treturn errorAndCallback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\tconst afterBuilding = Date.now();\n\t\t\t\t\t\t\t\tcurrentProfile.building = afterBuilding - afterFactory;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\t\tafterBuild();\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\tthis.waitForBuildingFinished(module, afterBuild);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t *\n\t * @param {string} context context path for entry\n\t * @param {Dependency} entry entry dependency being created\n\t * @param {string} name name of entry\n\t * @param {ModuleCallback} callback callback function\n\t * @returns {void} returns\n\t */\n\taddEntry(context, entry, name, callback) {\n\t\tthis.hooks.addEntry.call(entry, name);\n\n\t\tconst slot = {\n\t\t\tname: name,\n\t\t\t// TODO webpack 5 remove `request`\n\t\t\trequest: null,\n\t\t\tmodule: null\n\t\t};\n\n\t\tif (entry instanceof ModuleDependency) {\n\t\t\tslot.request = entry.request;\n\t\t}\n\n\t\t// TODO webpack 5: merge modules instead when multiple entry modules are supported\n\t\tconst idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);\n\t\tif (idx >= 0) {\n\t\t\t// Overwrite existing entrypoint\n\t\t\tthis._preparedEntrypoints[idx] = slot;\n\t\t} else {\n\t\t\tthis._preparedEntrypoints.push(slot);\n\t\t}\n\t\tthis._addModuleChain(\n\t\t\tcontext,\n\t\t\tentry,\n\t\t\tmodule => {\n\t\t\t\tthis.entries.push(module);\n\t\t\t},\n\t\t\t(err, module) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tthis.hooks.failedEntry.call(entry, name, err);\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (module) {\n\t\t\t\t\tslot.module = module;\n\t\t\t\t} else {\n\t\t\t\t\tconst idx = this._preparedEntrypoints.indexOf(slot);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tthis._preparedEntrypoints.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.hooks.succeedEntry.call(entry, name, module);\n\t\t\t\treturn callback(null, module);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} context context path string\n\t * @param {Dependency} dependency dep used to create module\n\t * @param {ModuleCallback} callback module callback sending module up a level\n\t * @returns {void}\n\t */\n\tprefetch(context, dependency, callback) {\n\t\tthis._addModuleChain(\n\t\t\tcontext,\n\t\t\tdependency,\n\t\t\tmodule => {\n\t\t\t\tmodule.prefetched = true;\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module to be rebuilt\n\t * @param {Callback} thisCallback callback when module finishes rebuilding\n\t * @returns {void}\n\t */\n\trebuildModule(module, thisCallback) {\n\t\tlet callbackList = this._rebuildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(thisCallback);\n\t\t\treturn;\n\t\t}\n\t\tthis._rebuildingModules.set(module, (callbackList = [thisCallback]));\n\n\t\tconst callback = err => {\n\t\t\tthis._rebuildingModules.delete(module);\n\t\t\tfor (const cb of callbackList) {\n\t\t\t\tcb(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.rebuildModule.call(module);\n\t\tconst oldDependencies = module.dependencies.slice();\n\t\tconst oldVariables = module.variables.slice();\n\t\tconst oldBlocks = module.blocks.slice();\n\t\tmodule.unbuild();\n\t\tthis.buildModule(module, false, module, null, err => {\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.finishRebuildingModule.call(module);\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tthis.processModuleDependencies(module, err => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.removeReasonsOfDependencyBlock(module, {\n\t\t\t\t\tdependencies: oldDependencies,\n\t\t\t\t\tvariables: oldVariables,\n\t\t\t\t\tblocks: oldBlocks\n\t\t\t\t});\n\t\t\t\tthis.hooks.finishRebuildingModule.call(module);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t});\n\t}\n\n\tfinish(callback) {\n\t\tconst modules = this.modules;\n\t\tthis.hooks.finishModules.callAsync(modules, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tfor (let index = 0; index < modules.length; index++) {\n\t\t\t\tconst module = modules[index];\n\t\t\t\tthis.reportDependencyErrorsAndWarnings(module, [module]);\n\t\t\t}\n\n\t\t\tcallback();\n\t\t});\n\t}\n\n\tunseal() {\n\t\tthis.hooks.unseal.call();\n\t\tthis.chunks.length = 0;\n\t\tthis.chunkGroups.length = 0;\n\t\tthis.namedChunks.clear();\n\t\tthis.namedChunkGroups.clear();\n\t\tthis.additionalChunkAssets.length = 0;\n\t\tthis.assets = {};\n\t\tthis.assetsInfo.clear();\n\t\tfor (const module of this.modules) {\n\t\t\tmodule.unseal();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback} callback signals when the seal method is finishes\n\t * @returns {void}\n\t */\n\tseal(callback) {\n\t\tthis.hooks.seal.call();\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeDependenciesBasic.call(this.modules) ||\n\t\t\tthis.hooks.optimizeDependencies.call(this.modules) ||\n\t\t\tthis.hooks.optimizeDependenciesAdvanced.call(this.modules)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeDependencies.call(this.modules);\n\n\t\tthis.hooks.beforeChunks.call();\n\t\tfor (const preparedEntrypoint of this._preparedEntrypoints) {\n\t\t\tconst module = preparedEntrypoint.module;\n\t\t\tconst name = preparedEntrypoint.name;\n\t\t\tconst chunk = this.addChunk(name);\n\t\t\tconst entrypoint = new Entrypoint(name);\n\t\t\tentrypoint.setRuntimeChunk(chunk);\n\t\t\tentrypoint.addOrigin(null, name, preparedEntrypoint.request);\n\t\t\tthis.namedChunkGroups.set(name, entrypoint);\n\t\t\tthis.entrypoints.set(name, entrypoint);\n\t\t\tthis.chunkGroups.push(entrypoint);\n\n\t\t\tGraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n\t\t\tGraphHelpers.connectChunkAndModule(chunk, module);\n\n\t\t\tchunk.entryModule = module;\n\t\t\tchunk.name = name;\n\n\t\t\tthis.assignDepth(module);\n\t\t}\n\t\tbuildChunkGraph(\n\t\t\tthis,\n\t\t\t/** @type {Entrypoint[]} */ (this.chunkGroups.slice())\n\t\t);\n\t\tthis.sortModules(this.modules);\n\t\tthis.hooks.afterChunks.call(this.chunks);\n\n\t\tthis.hooks.optimize.call();\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeModulesBasic.call(this.modules) ||\n\t\t\tthis.hooks.optimizeModules.call(this.modules) ||\n\t\t\tthis.hooks.optimizeModulesAdvanced.call(this.modules)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeModules.call(this.modules);\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||\n\t\t\tthis.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||\n\t\t\tthis.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n\n\t\tthis.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {\n\t\t\tif (err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tthis.hooks.afterOptimizeTree.call(this.chunks, this.modules);\n\n\t\t\twhile (\n\t\t\t\tthis.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||\n\t\t\t\tthis.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||\n\t\t\t\tthis.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)\n\t\t\t) {\n\t\t\t\t/* empty */\n\t\t\t}\n\t\t\tthis.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);\n\n\t\t\tconst shouldRecord = this.hooks.shouldRecord.call() !== false;\n\n\t\t\tthis.hooks.reviveModules.call(this.modules, this.records);\n\t\t\tthis.hooks.optimizeModuleOrder.call(this.modules);\n\t\t\tthis.hooks.advancedOptimizeModuleOrder.call(this.modules);\n\t\t\tthis.hooks.beforeModuleIds.call(this.modules);\n\t\t\tthis.hooks.moduleIds.call(this.modules);\n\t\t\tthis.applyModuleIds();\n\t\t\tthis.hooks.optimizeModuleIds.call(this.modules);\n\t\t\tthis.hooks.afterOptimizeModuleIds.call(this.modules);\n\n\t\t\tthis.sortItemsWithModuleIds();\n\n\t\t\tthis.hooks.reviveChunks.call(this.chunks, this.records);\n\t\t\tthis.hooks.optimizeChunkOrder.call(this.chunks);\n\t\t\tthis.hooks.beforeChunkIds.call(this.chunks);\n\t\t\tthis.applyChunkIds();\n\t\t\tthis.hooks.optimizeChunkIds.call(this.chunks);\n\t\t\tthis.hooks.afterOptimizeChunkIds.call(this.chunks);\n\n\t\t\tthis.sortItemsWithChunkIds();\n\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.recordModules.call(this.modules, this.records);\n\t\t\t\tthis.hooks.recordChunks.call(this.chunks, this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.beforeHash.call();\n\t\t\tthis.createHash();\n\t\t\tthis.hooks.afterHash.call();\n\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.recordHash.call(this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.beforeModuleAssets.call();\n\t\t\tthis.createModuleAssets();\n\t\t\tif (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n\t\t\t\tthis.hooks.beforeChunkAssets.call();\n\t\t\t\tthis.createChunkAssets();\n\t\t\t}\n\t\t\tthis.hooks.additionalChunkAssets.call(this.chunks);\n\t\t\tthis.summarizeDependencies();\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.record.call(this, this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.additionalAssets.callAsync(err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tthis.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.hooks.afterOptimizeChunkAssets.call(this.chunks);\n\t\t\t\t\tthis.hooks.optimizeAssets.callAsync(this.assets, err => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterOptimizeAssets.call(this.assets);\n\t\t\t\t\t\tif (this.hooks.needAdditionalSeal.call()) {\n\t\t\t\t\t\t\tthis.unseal();\n\t\t\t\t\t\t\treturn this.seal(callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.hooks.afterSeal.callAsync(callback);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Module[]} modules the modules array on compilation to perform the sort for\n\t * @returns {void}\n\t */\n\tsortModules(modules) {\n\t\t// TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n\t\t// TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n\t\t// TODO remove this method\n\t\tmodules.sort(byIndexOrIdentifier);\n\t}\n\n\t/**\n\t * @param {Module} module moulde to report from\n\t * @param {DependenciesBlock[]} blocks blocks to report from\n\t * @returns {void}\n\t */\n\treportDependencyErrorsAndWarnings(module, blocks) {\n\t\tfor (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n\t\t\tconst block = blocks[indexBlock];\n\t\t\tconst dependencies = block.dependencies;\n\n\t\t\tfor (let indexDep = 0; indexDep < dependencies.length; indexDep++) {\n\t\t\t\tconst d = dependencies[indexDep];\n\n\t\t\t\tconst warnings = d.getWarnings();\n\t\t\t\tif (warnings) {\n\t\t\t\t\tfor (let indexWar = 0; indexWar < warnings.length; indexWar++) {\n\t\t\t\t\t\tconst w = warnings[indexWar];\n\n\t\t\t\t\t\tconst warning = new ModuleDependencyWarning(module, w, d.loc);\n\t\t\t\t\t\tthis.warnings.push(warning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst errors = d.getErrors();\n\t\t\t\tif (errors) {\n\t\t\t\t\tfor (let indexErr = 0; indexErr < errors.length; indexErr++) {\n\t\t\t\t\t\tconst e = errors[indexErr];\n\n\t\t\t\t\t\tconst error = new ModuleDependencyError(module, e, d.loc);\n\t\t\t\t\t\tthis.errors.push(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.reportDependencyErrorsAndWarnings(module, block.blocks);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TODO} groupOptions options for the chunk group\n\t * @param {Module} module the module the references the chunk group\n\t * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n\t * @param {string} request the request from which the the chunk group is referenced\n\t * @returns {ChunkGroup} the new or existing chunk group\n\t */\n\taddChunkInGroup(groupOptions, module, loc, request) {\n\t\tif (typeof groupOptions === \"string\") {\n\t\t\tgroupOptions = { name: groupOptions };\n\t\t}\n\t\tconst name = groupOptions.name;\n\t\tif (name) {\n\t\t\tconst chunkGroup = this.namedChunkGroups.get(name);\n\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\tchunkGroup.addOptions(groupOptions);\n\t\t\t\tif (module) {\n\t\t\t\t\tchunkGroup.addOrigin(module, loc, request);\n\t\t\t\t}\n\t\t\t\treturn chunkGroup;\n\t\t\t}\n\t\t}\n\t\tconst chunkGroup = new ChunkGroup(groupOptions);\n\t\tif (module) chunkGroup.addOrigin(module, loc, request);\n\t\tconst chunk = this.addChunk(name);\n\n\t\tGraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n\n\t\tthis.chunkGroups.push(chunkGroup);\n\t\tif (name) {\n\t\t\tthis.namedChunkGroups.set(name, chunkGroup);\n\t\t}\n\t\treturn chunkGroup;\n\t}\n\n\t/**\n\t * This method first looks to see if a name is provided for a new chunk,\n\t * and first looks to see if any named chunks already exist and reuse that chunk instead.\n\t *\n\t * @param {string=} name optional chunk name to be provided\n\t * @returns {Chunk} create a chunk (invoked during seal event)\n\t */\n\taddChunk(name) {\n\t\tif (name) {\n\t\t\tconst chunk = this.namedChunks.get(name);\n\t\t\tif (chunk !== undefined) {\n\t\t\t\treturn chunk;\n\t\t\t}\n\t\t}\n\t\tconst chunk = new Chunk(name);\n\t\tthis.chunks.push(chunk);\n\t\tif (name) {\n\t\t\tthis.namedChunks.set(name, chunk);\n\t\t}\n\t\treturn chunk;\n\t}\n\n\t/**\n\t * @param {Module} module module to assign depth\n\t * @returns {void}\n\t */\n\tassignDepth(module) {\n\t\tconst queue = new Set([module]);\n\t\tlet depth;\n\n\t\tmodule.depth = 0;\n\n\t\t/**\n\t\t * @param {Module} module module for processeing\n\t\t * @returns {void}\n\t\t */\n\t\tconst enqueueJob = module => {\n\t\t\tconst d = module.depth;\n\t\t\tif (typeof d === \"number\" && d <= depth) return;\n\t\t\tqueue.add(module);\n\t\t\tmodule.depth = depth;\n\t\t};\n\n\t\t/**\n\t\t * @param {Dependency} dependency dependency to assign depth to\n\t\t * @returns {void}\n\t\t */\n\t\tconst assignDepthToDependency = dependency => {\n\t\t\tif (dependency.module) {\n\t\t\t\tenqueueJob(dependency.module);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @param {DependenciesBlock} block block to assign depth to\n\t\t * @returns {void}\n\t\t */\n\t\tconst assignDepthToDependencyBlock = block => {\n\t\t\tif (block.variables) {\n\t\t\t\titerationBlockVariable(block.variables, assignDepthToDependency);\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\titerationOfArrayCallback(block.dependencies, assignDepthToDependency);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\titerationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n\t\t\t}\n\t\t};\n\n\t\tfor (module of queue) {\n\t\t\tqueue.delete(module);\n\t\t\tdepth = module.depth;\n\n\t\t\tdepth++;\n\t\t\tassignDepthToDependencyBlock(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module containing the dependency\n\t * @param {Dependency} dependency the dependency\n\t * @returns {DependencyReference} a reference for the dependency\n\t */\n\tgetDependencyReference(module, dependency) {\n\t\t// TODO remove dep.getReference existence check in webpack 5\n\t\tif (typeof dependency.getReference !== \"function\") return null;\n\t\tconst ref = dependency.getReference();\n\t\tif (!ref) return null;\n\t\treturn this.hooks.dependencyReference.call(ref, dependency, module);\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module module relationship for removal\n\t * @param {DependenciesBlockLike} block //TODO: good description\n\t * @returns {void}\n\t */\n\tremoveReasonsOfDependencyBlock(module, block) {\n\t\tconst iteratorDependency = d => {\n\t\t\tif (!d.module) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (d.module.removeReason(module, d)) {\n\t\t\t\tfor (const chunk of d.module.chunksIterable) {\n\t\t\t\t\tthis.patchChunksAfterReasonRemoval(d.module, chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (block.blocks) {\n\t\t\titerationOfArrayCallback(block.blocks, block =>\n\t\t\t\tthis.removeReasonsOfDependencyBlock(module, block)\n\t\t\t);\n\t\t}\n\n\t\tif (block.dependencies) {\n\t\t\titerationOfArrayCallback(block.dependencies, iteratorDependency);\n\t\t}\n\n\t\tif (block.variables) {\n\t\t\titerationBlockVariable(block.variables, iteratorDependency);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module module to patch tie\n\t * @param {Chunk} chunk chunk to patch tie\n\t * @returns {void}\n\t */\n\tpatchChunksAfterReasonRemoval(module, chunk) {\n\t\tif (!module.hasReasons()) {\n\t\t\tthis.removeReasonsOfDependencyBlock(module, module);\n\t\t}\n\t\tif (!module.hasReasonForChunk(chunk)) {\n\t\t\tif (module.removeChunk(chunk)) {\n\t\t\t\tthis.removeChunkFromDependencies(module, chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block tie for Chunk\n\t * @param {Chunk} chunk chunk to remove from dep\n\t * @returns {void}\n\t */\n\tremoveChunkFromDependencies(block, chunk) {\n\t\tconst iteratorDependency = d => {\n\t\t\tif (!d.module) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.patchChunksAfterReasonRemoval(d.module, chunk);\n\t\t};\n\n\t\tconst blocks = block.blocks;\n\t\tfor (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n\t\t\tconst asyncBlock = blocks[indexBlock];\n\t\t\t// Grab all chunks from the first Block's AsyncDepBlock\n\t\t\tconst chunks = asyncBlock.chunkGroup.chunks;\n\t\t\t// For each chunk in chunkGroup\n\t\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\t\tconst iteratedChunk = chunks[indexChunk];\n\t\t\t\tasyncBlock.chunkGroup.removeChunk(iteratedChunk);\n\t\t\t\tasyncBlock.chunkGroup.removeParent(iteratedChunk);\n\t\t\t\t// Recurse\n\t\t\t\tthis.removeChunkFromDependencies(block, iteratedChunk);\n\t\t\t}\n\t\t}\n\n\t\tif (block.dependencies) {\n\t\t\titerationOfArrayCallback(block.dependencies, iteratorDependency);\n\t\t}\n\n\t\tif (block.variables) {\n\t\t\titerationBlockVariable(block.variables, iteratorDependency);\n\t\t}\n\t}\n\n\tapplyModuleIds() {\n\t\tconst unusedIds = [];\n\t\tlet nextFreeModuleId = 0;\n\t\tconst usedIds = new Set();\n\t\tif (this.usedModuleIds) {\n\t\t\tfor (const id of this.usedModuleIds) {\n\t\t\t\tusedIds.add(id);\n\t\t\t}\n\t\t}\n\n\t\tconst modules1 = this.modules;\n\t\tfor (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n\t\t\tconst module1 = modules1[indexModule1];\n\t\t\tif (module1.id !== null) {\n\t\t\t\tusedIds.add(module1.id);\n\t\t\t}\n\t\t}\n\n\t\tif (usedIds.size > 0) {\n\t\t\tlet usedIdMax = -1;\n\t\t\tfor (const usedIdKey of usedIds) {\n\t\t\t\tif (typeof usedIdKey !== \"number\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusedIdMax = Math.max(usedIdMax, usedIdKey);\n\t\t\t}\n\n\t\t\tlet lengthFreeModules = (nextFreeModuleId = usedIdMax + 1);\n\n\t\t\twhile (lengthFreeModules--) {\n\t\t\t\tif (!usedIds.has(lengthFreeModules)) {\n\t\t\t\t\tunusedIds.push(lengthFreeModules);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst modules2 = this.modules;\n\t\tfor (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n\t\t\tconst module2 = modules2[indexModule2];\n\t\t\tif (module2.id === null) {\n\t\t\t\tif (unusedIds.length > 0) {\n\t\t\t\t\tmodule2.id = unusedIds.pop();\n\t\t\t\t} else {\n\t\t\t\t\tmodule2.id = nextFreeModuleId++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyChunkIds() {\n\t\t/** @type {Set<number>} */\n\t\tconst usedIds = new Set();\n\n\t\t// Get used ids from usedChunkIds property (i. e. from records)\n\t\tif (this.usedChunkIds) {\n\t\t\tfor (const id of this.usedChunkIds) {\n\t\t\t\tif (typeof id !== \"number\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusedIds.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Get used ids from existing chunks\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tconst usedIdValue = chunk.id;\n\n\t\t\tif (typeof usedIdValue !== \"number\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusedIds.add(usedIdValue);\n\t\t}\n\n\t\t// Calculate maximum assigned chunk id\n\t\tlet nextFreeChunkId = -1;\n\t\tfor (const id of usedIds) {\n\t\t\tnextFreeChunkId = Math.max(nextFreeChunkId, id);\n\t\t}\n\t\tnextFreeChunkId++;\n\n\t\t// Determine free chunk ids from 0 to maximum\n\t\t/** @type {number[]} */\n\t\tconst unusedIds = [];\n\t\tif (nextFreeChunkId > 0) {\n\t\t\tlet index = nextFreeChunkId;\n\t\t\twhile (index--) {\n\t\t\t\tif (!usedIds.has(index)) {\n\t\t\t\t\tunusedIds.push(index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Assign ids to chunk which has no id\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tif (chunk.id === null) {\n\t\t\t\tif (unusedIds.length > 0) {\n\t\t\t\t\tchunk.id = unusedIds.pop();\n\t\t\t\t} else {\n\t\t\t\t\tchunk.id = nextFreeChunkId++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chunk.ids) {\n\t\t\t\tchunk.ids = [chunk.id];\n\t\t\t}\n\t\t}\n\t}\n\n\tsortItemsWithModuleIds() {\n\t\tthis.modules.sort(byIdOrIdentifier);\n\n\t\tconst modules = this.modules;\n\t\tfor (let indexModule = 0; indexModule < modules.length; indexModule++) {\n\t\t\tmodules[indexModule].sortItems(false);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tchunks[indexChunk].sortItems();\n\t\t}\n\n\t\tchunks.sort((a, b) => a.compareTo(b));\n\t}\n\n\tsortItemsWithChunkIds() {\n\t\tfor (const chunkGroup of this.chunkGroups) {\n\t\t\tchunkGroup.sortItems();\n\t\t}\n\n\t\tthis.chunks.sort(byId);\n\n\t\tfor (\n\t\t\tlet indexModule = 0;\n\t\t\tindexModule < this.modules.length;\n\t\t\tindexModule++\n\t\t) {\n\t\t\tthis.modules[indexModule].sortItems(true);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tchunks[indexChunk].sortItems();\n\t\t}\n\n\t\t/**\n\t\t * Used to sort errors and warnings in compilation. this.warnings, and\n\t\t * this.errors contribute to the compilation hash and therefore should be\n\t\t * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n\t\t * integrity\n\t\t *\n\t\t * @param {WebpackError} a first WebpackError instance (including subclasses)\n\t\t * @param {WebpackError} b second WebpackError instance (including subclasses)\n\t\t * @returns {-1|0|1} sort order index\n\t\t */\n\t\tconst byMessage = (a, b) => {\n\t\t\tconst ma = `${a.message}`;\n\t\t\tconst mb = `${b.message}`;\n\t\t\tif (ma < mb) return -1;\n\t\t\tif (mb < ma) return 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\tthis.errors.sort(byMessage);\n\t\tthis.warnings.sort(byMessage);\n\t\tthis.children.sort(byNameOrHash);\n\t}\n\n\tsummarizeDependencies() {\n\t\tthis.fileDependencies = new SortableSet(this.compilationDependencies);\n\t\tthis.contextDependencies = new SortableSet();\n\t\tthis.missingDependencies = new SortableSet();\n\n\t\tfor (\n\t\t\tlet indexChildren = 0;\n\t\t\tindexChildren < this.children.length;\n\t\t\tindexChildren++\n\t\t) {\n\t\t\tconst child = this.children[indexChildren];\n\n\t\t\taddAllToSet(this.fileDependencies, child.fileDependencies);\n\t\t\taddAllToSet(this.contextDependencies, child.contextDependencies);\n\t\t\taddAllToSet(this.missingDependencies, child.missingDependencies);\n\t\t}\n\n\t\tfor (\n\t\t\tlet indexModule = 0;\n\t\t\tindexModule < this.modules.length;\n\t\t\tindexModule++\n\t\t) {\n\t\t\tconst module = this.modules[indexModule];\n\n\t\t\tif (module.buildInfo.fileDependencies) {\n\t\t\t\taddAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);\n\t\t\t}\n\t\t\tif (module.buildInfo.contextDependencies) {\n\t\t\t\taddAllToSet(\n\t\t\t\t\tthis.contextDependencies,\n\t\t\t\t\tmodule.buildInfo.contextDependencies\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const error of this.errors) {\n\t\t\tif (\n\t\t\t\ttypeof error.missing === \"object\" &&\n\t\t\t\terror.missing &&\n\t\t\t\terror.missing[Symbol.iterator]\n\t\t\t) {\n\t\t\t\taddAllToSet(this.missingDependencies, error.missing);\n\t\t\t}\n\t\t}\n\t\tthis.fileDependencies.sort();\n\t\tthis.contextDependencies.sort();\n\t\tthis.missingDependencies.sort();\n\t}\n\n\tcreateHash() {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst hashFunction = outputOptions.hashFunction;\n\t\tconst hashDigest = outputOptions.hashDigest;\n\t\tconst hashDigestLength = outputOptions.hashDigestLength;\n\t\tconst hash = createHash(hashFunction);\n\t\tif (outputOptions.hashSalt) {\n\t\t\thash.update(outputOptions.hashSalt);\n\t\t}\n\t\tthis.mainTemplate.updateHash(hash);\n\t\tthis.chunkTemplate.updateHash(hash);\n\t\tfor (const key of Object.keys(this.moduleTemplates).sort()) {\n\t\t\tthis.moduleTemplates[key].updateHash(hash);\n\t\t}\n\t\tfor (const child of this.children) {\n\t\t\thash.update(child.hash);\n\t\t}\n\t\tfor (const warning of this.warnings) {\n\t\t\thash.update(`${warning.message}`);\n\t\t}\n\t\tfor (const error of this.errors) {\n\t\t\thash.update(`${error.message}`);\n\t\t}\n\t\tconst modules = this.modules;\n\t\tfor (let i = 0; i < modules.length; i++) {\n\t\t\tconst module = modules[i];\n\t\t\tconst moduleHash = createHash(hashFunction);\n\t\t\tmodule.updateHash(moduleHash);\n\t\t\tmodule.hash = /** @type {string} */ (moduleHash.digest(hashDigest));\n\t\t\tmodule.renderedHash = module.hash.substr(0, hashDigestLength);\n\t\t}\n\t\t// clone needed as sort below is inplace mutation\n\t\tconst chunks = this.chunks.slice();\n\t\t/**\n\t\t * sort here will bring all \"falsy\" values to the beginning\n\t\t * this is needed as the \"hasRuntime()\" chunks are dependent on the\n\t\t * hashes of the non-runtime chunks.\n\t\t */\n\t\tchunks.sort((a, b) => {\n\t\t\tconst aEntry = a.hasRuntime();\n\t\t\tconst bEntry = b.hasRuntime();\n\t\t\tif (aEntry && !bEntry) return 1;\n\t\t\tif (!aEntry && bEntry) return -1;\n\t\t\treturn byId(a, b);\n\t\t});\n\t\tfor (let i = 0; i < chunks.length; i++) {\n\t\t\tconst chunk = chunks[i];\n\t\t\tconst chunkHash = createHash(hashFunction);\n\t\t\ttry {\n\t\t\t\tif (outputOptions.hashSalt) {\n\t\t\t\t\tchunkHash.update(outputOptions.hashSalt);\n\t\t\t\t}\n\t\t\t\tchunk.updateHash(chunkHash);\n\t\t\t\tconst template = chunk.hasRuntime()\n\t\t\t\t\t? this.mainTemplate\n\t\t\t\t\t: this.chunkTemplate;\n\t\t\t\ttemplate.updateHashForChunk(\n\t\t\t\t\tchunkHash,\n\t\t\t\t\tchunk,\n\t\t\t\t\tthis.moduleTemplates.javascript,\n\t\t\t\t\tthis.dependencyTemplates\n\t\t\t\t);\n\t\t\t\tthis.hooks.chunkHash.call(chunk, chunkHash);\n\t\t\t\tchunk.hash = /** @type {string} */ (chunkHash.digest(hashDigest));\n\t\t\t\thash.update(chunk.hash);\n\t\t\t\tchunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n\t\t\t\tthis.hooks.contentHash.call(chunk);\n\t\t\t} catch (err) {\n\t\t\t\tthis.errors.push(new ChunkRenderError(chunk, \"\", err));\n\t\t\t}\n\t\t}\n\t\tthis.fullHash = /** @type {string} */ (hash.digest(hashDigest));\n\t\tthis.hash = this.fullHash.substr(0, hashDigestLength);\n\t}\n\n\t/**\n\t * @param {string} update extra information\n\t * @returns {void}\n\t */\n\tmodifyHash(update) {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst hashFunction = outputOptions.hashFunction;\n\t\tconst hashDigest = outputOptions.hashDigest;\n\t\tconst hashDigestLength = outputOptions.hashDigestLength;\n\t\tconst hash = createHash(hashFunction);\n\t\thash.update(this.fullHash);\n\t\thash.update(update);\n\t\tthis.fullHash = /** @type {string} */ (hash.digest(hashDigest));\n\t\tthis.hash = this.fullHash.substr(0, hashDigestLength);\n\t}\n\n\t/**\n\t * @param {string} file file name\n\t * @param {Source} source asset source\n\t * @param {AssetInfo} assetInfo extra asset information\n\t * @returns {void}\n\t */\n\temitAsset(file, source, assetInfo = {}) {\n\t\tif (this.assets[file]) {\n\t\t\tif (!isSourceEqual(this.assets[file], source)) {\n\t\t\t\t// TODO webpack 5: make this an error instead\n\t\t\t\tthis.warnings.push(\n\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t`Conflict: Multiple assets emit different content to the same filename ${file}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tthis.assets[file] = source;\n\t\t\t\tthis.assetsInfo.set(file, assetInfo);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst oldInfo = this.assetsInfo.get(file);\n\t\t\tthis.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));\n\t\t\treturn;\n\t\t}\n\t\tthis.assets[file] = source;\n\t\tthis.assetsInfo.set(file, assetInfo);\n\t}\n\n\t/**\n\t * @param {string} file file name\n\t * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new\n\t * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new\n\t */\n\tupdateAsset(\n\t\tfile,\n\t\tnewSourceOrFunction,\n\t\tassetInfoUpdateOrFunction = undefined\n\t) {\n\t\tif (!this.assets[file]) {\n\t\t\tthrow new Error(\n\t\t\t\t`Called Compilation.updateAsset for not existing filename ${file}`\n\t\t\t);\n\t\t}\n\t\tif (typeof newSourceOrFunction === \"function\") {\n\t\t\tthis.assets[file] = newSourceOrFunction(this.assets[file]);\n\t\t} else {\n\t\t\tthis.assets[file] = newSourceOrFunction;\n\t\t}\n\t\tif (assetInfoUpdateOrFunction !== undefined) {\n\t\t\tconst oldInfo = this.assetsInfo.get(file);\n\t\t\tif (typeof assetInfoUpdateOrFunction === \"function\") {\n\t\t\t\tthis.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));\n\t\t\t} else {\n\t\t\t\tthis.assetsInfo.set(\n\t\t\t\t\tfile,\n\t\t\t\t\tObject.assign({}, oldInfo, assetInfoUpdateOrFunction)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetAssets() {\n\t\t/** @type {Asset[]} */\n\t\tconst array = [];\n\t\tfor (const assetName of Object.keys(this.assets)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {\n\t\t\t\tarray.push({\n\t\t\t\t\tname: assetName,\n\t\t\t\t\tsource: this.assets[assetName],\n\t\t\t\t\tinfo: this.assetsInfo.get(assetName) || {}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {string} name the name of the asset\n\t * @returns {Asset | undefined} the asset or undefined when not found\n\t */\n\tgetAsset(name) {\n\t\tif (!Object.prototype.hasOwnProperty.call(this.assets, name))\n\t\t\treturn undefined;\n\t\treturn {\n\t\t\tname,\n\t\t\tsource: this.assets[name],\n\t\t\tinfo: this.assetsInfo.get(name) || {}\n\t\t};\n\t}\n\n\tcreateModuleAssets() {\n\t\tfor (let i = 0; i < this.modules.length; i++) {\n\t\t\tconst module = this.modules[i];\n\t\t\tif (module.buildInfo.assets) {\n\t\t\t\tconst assetsInfo = module.buildInfo.assetsInfo;\n\t\t\t\tfor (const assetName of Object.keys(module.buildInfo.assets)) {\n\t\t\t\t\tconst fileName = this.getPath(assetName);\n\t\t\t\t\tthis.emitAsset(\n\t\t\t\t\t\tfileName,\n\t\t\t\t\t\tmodule.buildInfo.assets[assetName],\n\t\t\t\t\t\tassetsInfo ? assetsInfo.get(assetName) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tthis.hooks.moduleAsset.call(module, fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateChunkAssets() {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst cachedSourceMap = new Map();\n\t\t/** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n\t\tconst alreadyWrittenFiles = new Map();\n\t\tfor (let i = 0; i < this.chunks.length; i++) {\n\t\t\tconst chunk = this.chunks[i];\n\t\t\tchunk.files = [];\n\t\t\tlet source;\n\t\t\tlet file;\n\t\t\tlet filenameTemplate;\n\t\t\ttry {\n\t\t\t\tconst template = chunk.hasRuntime()\n\t\t\t\t\t? this.mainTemplate\n\t\t\t\t\t: this.chunkTemplate;\n\t\t\t\tconst manifest = template.getRenderManifest({\n\t\t\t\t\tchunk,\n\t\t\t\t\thash: this.hash,\n\t\t\t\t\tfullHash: this.fullHash,\n\t\t\t\t\toutputOptions,\n\t\t\t\t\tmoduleTemplates: this.moduleTemplates,\n\t\t\t\t\tdependencyTemplates: this.dependencyTemplates\n\t\t\t\t}); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n\t\t\t\tfor (const fileManifest of manifest) {\n\t\t\t\t\tconst cacheName = fileManifest.identifier;\n\t\t\t\t\tconst usedHash = fileManifest.hash;\n\t\t\t\t\tfilenameTemplate = fileManifest.filenameTemplate;\n\t\t\t\t\tconst pathAndInfo = this.getPathWithInfo(\n\t\t\t\t\t\tfilenameTemplate,\n\t\t\t\t\t\tfileManifest.pathOptions\n\t\t\t\t\t);\n\t\t\t\t\tfile = pathAndInfo.path;\n\t\t\t\t\tconst assetInfo = pathAndInfo.info;\n\n\t\t\t\t\t// check if the same filename was already written by another chunk\n\t\t\t\t\tconst alreadyWritten = alreadyWrittenFiles.get(file);\n\t\t\t\t\tif (alreadyWritten !== undefined) {\n\t\t\t\t\t\tif (alreadyWritten.hash === usedHash) {\n\t\t\t\t\t\t\tif (this.cache) {\n\t\t\t\t\t\t\t\tthis.cache[cacheName] = {\n\t\t\t\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\t\t\t\tsource: alreadyWritten.source\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunk.files.push(file);\n\t\t\t\t\t\t\tthis.hooks.chunkAsset.call(chunk, file);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Conflict: Multiple chunks emit assets to the same filename ${file}` +\n\t\t\t\t\t\t\t\t\t` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.cache &&\n\t\t\t\t\t\tthis.cache[cacheName] &&\n\t\t\t\t\t\tthis.cache[cacheName].hash === usedHash\n\t\t\t\t\t) {\n\t\t\t\t\t\tsource = this.cache[cacheName].source;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsource = fileManifest.render();\n\t\t\t\t\t\t// Ensure that source is a cached source to avoid additional cost because of repeated access\n\t\t\t\t\t\tif (!(source instanceof CachedSource)) {\n\t\t\t\t\t\t\tconst cacheEntry = cachedSourceMap.get(source);\n\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\tsource = cacheEntry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst cachedSource = new CachedSource(source);\n\t\t\t\t\t\t\t\tcachedSourceMap.set(source, cachedSource);\n\t\t\t\t\t\t\t\tsource = cachedSource;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.cache) {\n\t\t\t\t\t\t\tthis.cache[cacheName] = {\n\t\t\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\t\t\tsource\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.emitAsset(file, source, assetInfo);\n\t\t\t\t\tchunk.files.push(file);\n\t\t\t\t\tthis.hooks.chunkAsset.call(chunk, file);\n\t\t\t\t\talreadyWrittenFiles.set(file, {\n\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tthis.errors.push(\n\t\t\t\t\tnew ChunkRenderError(chunk, file || filenameTemplate, err)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} filename used to get asset path with hash\n\t * @param {TODO=} data // TODO: figure out this param type\n\t * @returns {string} interpolated path\n\t */\n\tgetPath(filename, data) {\n\t\tdata = data || {};\n\t\tdata.hash = data.hash || this.hash;\n\t\treturn this.mainTemplate.getAssetPath(filename, data);\n\t}\n\n\t/**\n\t * @param {string} filename used to get asset path with hash\n\t * @param {TODO=} data // TODO: figure out this param type\n\t * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info\n\t */\n\tgetPathWithInfo(filename, data) {\n\t\tdata = data || {};\n\t\tdata.hash = data.hash || this.hash;\n\t\treturn this.mainTemplate.getAssetPathWithInfo(filename, data);\n\t}\n\n\t/**\n\t * This function allows you to run another instance of webpack inside of webpack however as\n\t * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n\t * from parent (or top level compiler) and creates a child Compilation\n\t *\n\t * @param {string} name name of the child compiler\n\t * @param {TODO} outputOptions // Need to convert config schema to types for this\n\t * @param {Plugin[]} plugins webpack plugins that will be applied\n\t * @returns {Compiler} creates a child Compiler instance\n\t */\n\tcreateChildCompiler(name, outputOptions, plugins) {\n\t\tconst idx = this.childrenCounters[name] || 0;\n\t\tthis.childrenCounters[name] = idx + 1;\n\t\treturn this.compiler.createChildCompiler(\n\t\t\tthis,\n\t\t\tname,\n\t\t\tidx,\n\t\t\toutputOptions,\n\t\t\tplugins\n\t\t);\n\t}\n\n\tcheckConstraints() {\n\t\t/** @type {Set<number|string>} */\n\t\tconst usedIds = new Set();\n\n\t\tconst modules = this.modules;\n\t\tfor (let indexModule = 0; indexModule < modules.length; indexModule++) {\n\t\t\tconst moduleId = modules[indexModule].id;\n\t\t\tif (moduleId === null) continue;\n\t\t\tif (usedIds.has(moduleId)) {\n\t\t\t\tthrow new Error(`checkConstraints: duplicate module id ${moduleId}`);\n\t\t\t}\n\t\t\tusedIds.add(moduleId);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tif (chunks.indexOf(chunk) !== indexChunk) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of this.chunkGroups) {\n\t\t\tchunkGroup.checkConstraints();\n\t\t}\n\t}\n}\n\n// TODO remove in webpack 5\nCompilation.prototype.applyPlugins = util.deprecate(\n\t/**\n\t * @deprecated\n\t * @param {string} name Name\n\t * @param {any[]} args Other arguments\n\t * @returns {void}\n\t * @this {Compilation}\n\t */\n\tfunction(name, ...args) {\n\t\tthis.hooks[\n\t\t\tname.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())\n\t\t].call(...args);\n\t},\n\t\"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\"\n);\n\n// TODO remove in webpack 5\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n\tconfigurable: false,\n\tget: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Compilation}\n\t\t * @returns {TODO} module template\n\t\t */\n\t\tfunction() {\n\t\t\treturn this.moduleTemplates.javascript;\n\t\t},\n\t\t\"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"\n\t),\n\tset: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {ModuleTemplate} value Template value\n\t\t * @this {Compilation}\n\t\t * @returns {void}\n\t\t */\n\t\tfunction(value) {\n\t\t\tthis.moduleTemplates.javascript = value;\n\t\t},\n\t\t\"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\"\n\t)\n});\n\nmodule.exports = Compilation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}