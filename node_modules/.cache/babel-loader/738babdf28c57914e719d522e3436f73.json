{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst compareLocations = require(\"./compareLocations\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\n\nlet debugId = 5000;\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\n\nconst getArray = set => Array.from(set);\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\n\n\nconst sortById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\n\n\nconst sortOrigin = (a, b) => {\n  const aIdent = a.module ? a.module.identifier() : \"\";\n  const bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  constructor(options) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n\n\n    this.groupDebugId = debugId++;\n    this.options = options;\n    /** @type {SortableSet<ChunkGroup>} */\n\n    this._children = new SortableSet(undefined, sortById);\n    this._parents = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n\n    this.origins = [];\n    /** Indices in top-down order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._moduleIndices = new Map();\n    /** Indices in bottom-up order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._moduleIndices2 = new Map();\n  }\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n\n\n  addOptions(options) {\n    for (const key of Object.keys(options)) {\n      if (this.options[key] === undefined) {\n        this.options[key] = options[key];\n      } else if (this.options[key] !== options[key]) {\n        if (key.endsWith(\"Order\")) {\n          this.options[key] = Math.max(this.options[key], options[key]);\n        } else {\n          throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);\n        }\n      }\n    }\n  }\n  /**\n   * returns the name of current ChunkGroup\n   * @returns {string|undefined} returns the ChunkGroup name\n   */\n\n\n  get name() {\n    return this.options.name;\n  }\n  /**\n   * sets a new name for current ChunkGroup\n   * @param {string} value the new name for ChunkGroup\n   * @returns {void}\n   */\n\n\n  set name(value) {\n    this.options.name = value;\n  }\n  /**\n   * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n   * @returns {string} a unique concatenation of chunk debugId's\n   */\n\n\n  get debugId() {\n    return Array.from(this.chunks, x => x.debugId).join(\"+\");\n  }\n  /**\n   * get a unique id for ChunkGroup, made up of its member Chunk id's\n   * @returns {string} a unique concatenation of chunk ids\n   */\n\n\n  get id() {\n    return Array.from(this.chunks, x => x.id).join(\"+\");\n  }\n  /**\n   * Performs an unshift of a specific chunk\n   * @param {Chunk} chunk chunk being unshifted\n   * @returns {boolean} returns true if attempted chunk shift is accepted\n   */\n\n\n  unshiftChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx > 0) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.unshift(chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.unshift(chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * inserts a chunk before another existing chunk in group\n   * @param {Chunk} chunk Chunk being inserted\n   * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n   * @returns {boolean} return true if insertion was successful\n   */\n\n\n  insertChunk(chunk, before) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    const idx = this.chunks.indexOf(before);\n\n    if (idx < 0) {\n      throw new Error(\"before chunk not found\");\n    }\n\n    if (oldIdx >= 0 && oldIdx > idx) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.splice(idx, 0, chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.splice(idx, 0, chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * add a chunk into ChunkGroup. Is pushed on or prepended\n   * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n   * @returns {boolean} returns true if chunk addition was successful.\n   */\n\n\n  pushChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx >= 0) {\n      return false;\n    }\n\n    this.chunks.push(chunk);\n    return true;\n  }\n  /**\n   * @param {Chunk} oldChunk chunk to be replaced\n   * @param {Chunk} newChunk New chunk that will be replaced with\n   * @returns {boolean} returns true if the replacement was successful\n   */\n\n\n  replaceChunk(oldChunk, newChunk) {\n    const oldIdx = this.chunks.indexOf(oldChunk);\n    if (oldIdx < 0) return false;\n    const newIdx = this.chunks.indexOf(newChunk);\n\n    if (newIdx < 0) {\n      this.chunks[oldIdx] = newChunk;\n      return true;\n    }\n\n    if (newIdx < oldIdx) {\n      this.chunks.splice(oldIdx, 1);\n      return true;\n    } else if (newIdx !== oldIdx) {\n      this.chunks[oldIdx] = newChunk;\n      this.chunks.splice(newIdx, 1);\n      return true;\n    }\n  }\n\n  removeChunk(chunk) {\n    const idx = this.chunks.indexOf(chunk);\n\n    if (idx >= 0) {\n      this.chunks.splice(idx, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  isInitial() {\n    return false;\n  }\n\n  addChild(chunk) {\n    if (this._children.has(chunk)) {\n      return false;\n    }\n\n    this._children.add(chunk);\n\n    return true;\n  }\n\n  getChildren() {\n    return this._children.getFromCache(getArray);\n  }\n\n  getNumberOfChildren() {\n    return this._children.size;\n  }\n\n  get childrenIterable() {\n    return this._children;\n  }\n\n  removeChild(chunk) {\n    if (!this._children.has(chunk)) {\n      return false;\n    }\n\n    this._children.delete(chunk);\n\n    chunk.removeParent(this);\n    return true;\n  }\n\n  addParent(parentChunk) {\n    if (!this._parents.has(parentChunk)) {\n      this._parents.add(parentChunk);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getParents() {\n    return this._parents.getFromCache(getArray);\n  }\n\n  setParents(newParents) {\n    this._parents.clear();\n\n    for (const p of newParents) {\n      this._parents.add(p);\n    }\n  }\n\n  getNumberOfParents() {\n    return this._parents.size;\n  }\n\n  hasParent(parent) {\n    return this._parents.has(parent);\n  }\n\n  get parentsIterable() {\n    return this._parents;\n  }\n\n  removeParent(chunk) {\n    if (this._parents.delete(chunk)) {\n      chunk.removeChunk(this);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {Array} - an array containing the blocks\n   */\n\n\n  getBlocks() {\n    return this._blocks.getFromCache(getArray);\n  }\n\n  getNumberOfBlocks() {\n    return this._blocks.size;\n  }\n\n  hasBlock(block) {\n    return this._blocks.has(block);\n  }\n\n  get blocksIterable() {\n    return this._blocks;\n  }\n\n  addBlock(block) {\n    if (!this._blocks.has(block)) {\n      this._blocks.add(block);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  addOrigin(module, loc, request) {\n    this.origins.push({\n      module,\n      loc,\n      request\n    });\n  }\n\n  containsModule(module) {\n    for (const chunk of this.chunks) {\n      if (chunk.containsModule(module)) return true;\n    }\n\n    return false;\n  }\n\n  getFiles() {\n    const files = new Set();\n\n    for (const chunk of this.chunks) {\n      for (const file of chunk.files) {\n        files.add(file);\n      }\n    }\n\n    return Array.from(files);\n  }\n  /**\n   * @param {string=} reason reason for removing ChunkGroup\n   * @returns {void}\n   */\n\n\n  remove(reason) {\n    // cleanup parents\n    for (const parentChunkGroup of this._parents) {\n      // remove this chunk from its parents\n      parentChunkGroup._children.delete(this); // cleanup \"sub chunks\"\n\n\n      for (const chunkGroup of this._children) {\n        /**\n         * remove this chunk as \"intermediary\" and connect\n         * it \"sub chunks\" and parents directly\n         */\n        // add parent to each \"sub chunk\"\n        chunkGroup.addParent(parentChunkGroup); // add \"sub chunk\" to parent\n\n        parentChunkGroup.addChild(chunkGroup);\n      }\n    }\n    /**\n     * we need to iterate again over the children\n     * to remove this from the child's parents.\n     * This can not be done in the above loop\n     * as it is not guaranteed that `this._parents` contains anything.\n     */\n\n\n    for (const chunkGroup of this._children) {\n      // remove this as parent of every \"sub chunk\"\n      chunkGroup._parents.delete(this);\n    } // cleanup blocks\n\n\n    for (const block of this._blocks) {\n      block.chunkGroup = null;\n    } // remove chunks\n\n\n    for (const chunk of this.chunks) {\n      chunk.removeGroup(this);\n    }\n  }\n\n  sortItems() {\n    this.origins.sort(sortOrigin);\n\n    this._parents.sort();\n\n    this._children.sort();\n  }\n  /**\n   * Sorting predicate which allows current ChunkGroup to be compared against another.\n   * Sorting values are based off of number of chunks in ChunkGroup.\n   *\n   * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n   * @returns {-1|0|1} sort position for comparison\n   */\n\n\n  compareTo(otherGroup) {\n    if (this.chunks.length > otherGroup.chunks.length) return -1;\n    if (this.chunks.length < otherGroup.chunks.length) return 1;\n    const a = this.chunks[Symbol.iterator]();\n    const b = otherGroup.chunks[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const aItem = a.next();\n      const bItem = b.next();\n      if (aItem.done) return 0;\n      const cmp = aItem.value.compareTo(bItem.value);\n      if (cmp !== 0) return cmp;\n    }\n  }\n\n  getChildrenByOrders() {\n    const lists = new Map();\n\n    for (const childGroup of this._children) {\n      // TODO webpack 5 remove this check for options\n      if (typeof childGroup.options === \"object\") {\n        for (const key of Object.keys(childGroup.options)) {\n          if (key.endsWith(\"Order\")) {\n            const name = key.substr(0, key.length - \"Order\".length);\n            let list = lists.get(name);\n\n            if (list === undefined) {\n              lists.set(name, list = []);\n            }\n\n            list.push({\n              order: childGroup.options[key],\n              group: childGroup\n            });\n          }\n        }\n      }\n    }\n\n    const result = Object.create(null);\n\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo\n\n        if (a.group.compareTo) {\n          return a.group.compareTo(b.group);\n        }\n\n        return 0;\n      });\n      result[name] = list.map(i => i.group);\n    }\n\n    return result;\n  }\n  /**\n   * Sets the top-down index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModuleIndex(module, index) {\n    this._moduleIndices.set(module, index);\n  }\n  /**\n   * Gets the top-down index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModuleIndex(module) {\n    return this._moduleIndices.get(module);\n  }\n  /**\n   * Sets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModuleIndex2(module, index) {\n    this._moduleIndices2.set(module, index);\n  }\n  /**\n   * Gets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModuleIndex2(module) {\n    return this._moduleIndices2.get(module);\n  }\n\n  checkConstraints() {\n    const chunk = this;\n\n    for (const child of chunk._children) {\n      if (!child._parents.has(chunk)) {\n        throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);\n      }\n    }\n\n    for (const parentChunk of chunk._parents) {\n      if (!parentChunk._children.has(chunk)) {\n        throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);\n      }\n    }\n  }\n\n}\n\nmodule.exports = ChunkGroup;","map":{"version":3,"names":["SortableSet","require","compareLocations","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","constructor","options","name","undefined","groupDebugId","_children","_parents","_blocks","chunks","origins","_moduleIndices","Map","_moduleIndices2","addOptions","key","Object","keys","endsWith","Math","max","Error","value","x","join","unshiftChunk","chunk","oldIdx","indexOf","splice","unshift","insertChunk","before","idx","pushChunk","push","replaceChunk","oldChunk","newChunk","newIdx","removeChunk","isInitial","addChild","has","add","getChildren","getFromCache","getNumberOfChildren","size","childrenIterable","removeChild","delete","removeParent","addParent","parentChunk","getParents","setParents","newParents","clear","p","getNumberOfParents","hasParent","parent","parentsIterable","getBlocks","getNumberOfBlocks","hasBlock","block","blocksIterable","addBlock","addOrigin","request","containsModule","getFiles","files","Set","file","remove","reason","parentChunkGroup","chunkGroup","removeGroup","sortItems","sort","compareTo","otherGroup","length","Symbol","iterator","aItem","next","bItem","done","cmp","getChildrenByOrders","lists","childGroup","substr","list","get","order","group","result","create","map","i","setModuleIndex","index","getModuleIndex","setModuleIndex2","getModuleIndex2","checkConstraints","child","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/ChunkGroup.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\nconst compareLocations = require(\"./compareLocations\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = options;\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices2 = new Map();\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const key of Object.keys(options)) {\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tthis.options[key] = Math.max(this.options[key], options[key]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string|undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\taddChild(chunk) {\n\t\tif (this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._children.add(chunk);\n\t\treturn true;\n\t}\n\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\tremoveChild(chunk) {\n\t\tif (!this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(chunk);\n\t\tchunk.removeParent(this);\n\t\treturn true;\n\t}\n\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tsetParents(newParents) {\n\t\tthis._parents.clear();\n\t\tfor (const p of newParents) {\n\t\t\tthis._parents.add(p);\n\t\t}\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\tremoveParent(chunk) {\n\t\tif (this._parents.delete(chunk)) {\n\t\t\tchunk.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {Array} - an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\tcontainsModule(module) {\n\t\tfor (const chunk of this.chunks) {\n\t\t\tif (chunk.containsModule(module)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @param {string=} reason reason for removing ChunkGroup\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// cleanup blocks\n\t\tfor (const block of this._blocks) {\n\t\t\tblock.chunkGroup = null;\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t\tthis._parents.sort();\n\t\tthis._children.sort();\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\tconst a = this.chunks[Symbol.iterator]();\n\t\tconst b = otherGroup.chunks[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tconst bItem = b.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst cmp = aItem.value.compareTo(bItem.value);\n\t\t\tif (cmp !== 0) return cmp;\n\t\t}\n\t}\n\n\tgetChildrenByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\t// TODO webpack 5 remove this check for options\n\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex(module, index) {\n\t\tthis._moduleIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex(module) {\n\t\treturn this._moduleIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex2(module, index) {\n\t\tthis._moduleIndices2.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex2(module) {\n\t\treturn this._moduleIndices2.get(module);\n\t}\n\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ChunkGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}