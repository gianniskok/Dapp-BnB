{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  Tapable,\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst MultiWatching = require(\"./MultiWatching\");\n\nconst MultiStats = require(\"./MultiStats\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = class MultiCompiler extends Tapable {\n  constructor(compilers) {\n    super();\n    this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    };\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.compilers = compilers;\n    let doneCompilers = 0;\n    let compilerStats = [];\n    let index = 0;\n\n    for (const compiler of this.compilers) {\n      let compilerDone = false;\n      const compilerIndex = index++; // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      }); // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n\n    this.running = false;\n  }\n\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n\n  validateDependencies(callback) {\n    const edges = new Set();\n    const missing = [];\n\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n\n    for (const source of this.compilers) {\n      if (source.dependencies) {\n        for (const dep of source.dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n\n    if (edges.size > 0) {\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n\n    return true;\n  }\n\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n\n      for (const c of list) {\n        const ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n\n      return readyCompilers;\n    };\n\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n\n    runCompilers(callback);\n  }\n\n  watch(watchOptions, handler) {\n    if (this.running) return handler(new ConcurrentCompilationError());\n    let watchings = [];\n    let allStats = this.compilers.map(() => null);\n    let compilerStatus = this.compilers.map(() => false);\n\n    if (this.validateDependencies(handler)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        let firstRun = true;\n        let watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, (err, stats) => {\n          if (err) handler(err);\n\n          if (stats) {\n            allStats[compilerIdx] = stats;\n            compilerStatus[compilerIdx] = \"new\";\n\n            if (compilerStatus.every(Boolean)) {\n              const freshStats = allStats.filter((s, idx) => {\n                return compilerStatus[idx] === \"new\";\n              });\n              compilerStatus.fill(true);\n              const multiStats = new MultiStats(freshStats);\n              handler(null, multiStats);\n            }\n          }\n\n          if (firstRun && !err) {\n            firstRun = false;\n            callback();\n          }\n        });\n        watchings.push(watching);\n      }, () => {// ignore\n      });\n    }\n\n    return new MultiWatching(watchings, this);\n  }\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    const finalCallback = (err, stats) => {\n      this.running = false;\n\n      if (callback !== undefined) {\n        return callback(err, stats);\n      }\n    };\n\n    const allStats = this.compilers.map(() => null);\n\n    if (this.validateDependencies(callback)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        compiler.run((err, stats) => {\n          if (err) {\n            return callback(err);\n          }\n\n          allStats[compilerIdx] = stats;\n          callback();\n        });\n      }, err => {\n        if (err) {\n          return finalCallback(err);\n        }\n\n        finalCallback(null, new MultiStats(allStats));\n      });\n    }\n  }\n\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["Tapable","SyncHook","MultiHook","require","asyncLib","MultiWatching","MultiStats","ConcurrentCompilationError","module","exports","MultiCompiler","constructor","compilers","hooks","done","invalid","map","c","run","watchClose","watchRun","infrastructureLog","Array","isArray","Object","keys","name","doneCompilers","compilerStats","index","compiler","compilerDone","compilerIndex","tap","stats","length","call","running","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","outputFileSystem","value","getInfrastructureLogger","validateDependencies","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","dependencies","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","watch","watchOptions","handler","watchings","allStats","compilerStatus","compilerIdx","firstRun","watching","Boolean","freshStats","s","idx","fill","multiStats","finalCallback","undefined","purgeInputFileSystem","purge"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/MultiCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { Tapable, SyncHook, MultiHook } = require(\"tapable\");\nconst asyncLib = require(\"neo-async\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst MultiStats = require(\"./MultiStats\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = class MultiCompiler extends Tapable {\n\tconstructor(compilers) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\twatchClose: new SyncHook([]),\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t};\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\t\tthis.compilers = compilers;\n\t\tlet doneCompilers = 0;\n\t\tlet compilerStats = [];\n\t\tlet index = 0;\n\t\tfor (const compiler of this.compilers) {\n\t\t\tlet compilerDone = false;\n\t\t\tconst compilerIndex = index++;\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.running = false;\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\tvalidateDependencies(callback) {\n\t\tconst edges = new Set();\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tif (source.dependencies) {\n\t\t\t\tfor (const dep of source.dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst ready =\n\t\t\t\t\t!c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\twatch(watchOptions, handler) {\n\t\tif (this.running) return handler(new ConcurrentCompilationError());\n\n\t\tlet watchings = [];\n\t\tlet allStats = this.compilers.map(() => null);\n\t\tlet compilerStatus = this.compilers.map(() => false);\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tthis.running = true;\n\t\t\tthis.runWithDependencies(\n\t\t\t\tthis.compilers,\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tconst compilerIdx = this.compilers.indexOf(compiler);\n\t\t\t\t\tlet firstRun = true;\n\t\t\t\t\tlet watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions)\n\t\t\t\t\t\t\t? watchOptions[compilerIdx]\n\t\t\t\t\t\t\t: watchOptions,\n\t\t\t\t\t\t(err, stats) => {\n\t\t\t\t\t\t\tif (err) handler(err);\n\t\t\t\t\t\t\tif (stats) {\n\t\t\t\t\t\t\t\tallStats[compilerIdx] = stats;\n\t\t\t\t\t\t\t\tcompilerStatus[compilerIdx] = \"new\";\n\t\t\t\t\t\t\t\tif (compilerStatus.every(Boolean)) {\n\t\t\t\t\t\t\t\t\tconst freshStats = allStats.filter((s, idx) => {\n\t\t\t\t\t\t\t\t\t\treturn compilerStatus[idx] === \"new\";\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tcompilerStatus.fill(true);\n\t\t\t\t\t\t\t\t\tconst multiStats = new MultiStats(freshStats);\n\t\t\t\t\t\t\t\t\thandler(null, multiStats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (firstRun && !err) {\n\t\t\t\t\t\t\t\tfirstRun = false;\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\twatchings.push(watching);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn new MultiWatching(watchings, this);\n\t}\n\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tthis.running = false;\n\n\t\t\tif (callback !== undefined) {\n\t\t\t\treturn callback(err, stats);\n\t\t\t}\n\t\t};\n\n\t\tconst allStats = this.compilers.map(() => null);\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis.running = true;\n\t\t\tthis.runWithDependencies(\n\t\t\t\tthis.compilers,\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tconst compilerIdx = this.compilers.indexOf(compiler);\n\t\t\t\t\tcompiler.run((err, stats) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallStats[compilerIdx] = stats;\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn finalCallback(err);\n\t\t\t\t\t}\n\t\t\t\t\tfinalCallback(null, new MultiStats(allStats));\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}