{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar util = require('util');\n\nvar braces = require('braces');\n\nvar toRegex = require('to-regex');\n\nvar extend = require('extend-shallow');\n/**\n * Local dependencies\n */\n\n\nvar compilers = require('./lib/compilers');\n\nvar parsers = require('./lib/parsers');\n\nvar cache = require('./lib/cache');\n\nvar utils = require('./lib/utils');\n\nvar MAX_LENGTH = 1024 * 64;\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n  var len = patterns.length;\n\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33\n    /* ! */\n    ) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\n\nmicromatch.match = function (list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  } // if no options were passed, uniquify results and return\n\n\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  } // if `opts.ignore` was defined, diff ignored list\n\n\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\n\nmicromatch.isMatch = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.any = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\n\nmicromatch.not = function (list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n\n    if (equals(str)) {\n      return true;\n    }\n\n    var contains = utils.containsPattern(patterns, options);\n\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {\n    contains: true\n  });\n  return micromatch.any(str, patterns, opts);\n};\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\n\nmicromatch.matchBase = function (pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  } // if pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  } // if pattern is invalid\n\n\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  } // if pattern is a non-glob string\n\n\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n\n    return utils.matchPath(pattern, options);\n  } // if pattern is a glob string\n\n\n  var re = micromatch.makeRe(pattern, options); // if `options.matchBase` or `options.basename` is defined\n\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n    return function (str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = function (pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({\n    capture: true\n  }, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function (string) {\n      var match = re.exec(unixify(string));\n\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function (obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = function (pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n\n    return braces(pattern, options);\n  }\n\n  return memoize('braces', pattern, options, expand);\n};\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\n\nmicromatch.braceExpand = function (pattern, options) {\n  var opts = extend({}, options, {\n    expand: true\n  });\n  return micromatch.braces(pattern, opts);\n};\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\n\nmicromatch.create = function (pattern, options) {\n  return memoize('create', pattern, options, function () {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n\n    return res;\n  });\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nmicromatch.parse = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\n\nmicromatch.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, function () {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\n\nmicromatch.clearCache = function () {\n  micromatch.cache.caches = {};\n};\n/**\n * Returns true if the given value is effectively an empty string\n */\n\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n  return memoize('compose', String(patterns), options, function () {\n    return function (file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  });\n}\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;","map":{"version":3,"names":["util","require","braces","toRegex","extend","compilers","parsers","cache","utils","MAX_LENGTH","micromatch","list","patterns","options","arrayify","len","length","match","omit","keep","idx","pattern","charCodeAt","push","apply","slice","matches","diff","nodupes","unique","Array","isArray","TypeError","unixify","isMatch","memoize","matcher","ele","value","failglob","Error","nonull","nullglob","unescape","ignore","not","str","inspect","isEmptyString","equals","equalsPattern","some","i","every","any","all","opts","map","contains","containsPattern","matchBase","indexOf","basename","matchKeys","obj","isObject","keys","Object","pick","compose","RegExp","test","isString","hasSpecialChars","nocase","toLowerCase","matchPath","re","makeRe","matchBasename","regex","fn","defineProperty","configurable","enumerable","result","capture","string","exec","create","ast_array","output","ast","state","join","expand","nobrace","braceExpand","compile","parse","res","snapdragon","instantiate","define","input","clearCache","caches","val","String","matchers","file","type","key","createKey","has","get","set","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/node_modules/micromatch/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar braces = require('braces');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nmicromatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nmicromatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.any = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return micromatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nmicromatch.matchBase = function(pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = micromatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = function(pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function(obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = function(pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n    return braces(pattern, options);\n  }\n\n  return memoize('braces', pattern, options, expand);\n};\n\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\nmicromatch.braceExpand = function(pattern, options) {\n  var opts = extend({}, options, {expand: true});\n  return micromatch.braces(pattern, opts);\n};\n\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nmicromatch.create = function(pattern, options) {\n  return memoize('create', pattern, options, function() {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n    return res;\n  });\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nmicromatch.parse = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nmicromatch.compile = function(ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, function() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\nmicromatch.clearCache = function() {\n  micromatch.cache.caches = {};\n};\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize('compose', String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}