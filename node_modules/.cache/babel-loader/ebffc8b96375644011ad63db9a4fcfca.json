{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nconst GraphHelpers = require(\"./GraphHelpers\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nconst bySetSize = (a, b) => {\n  return b.size - a.size;\n};\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\n\n\nconst extraceBlockInfoMap = compilation => {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  const blockInfoMap = new Map();\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n\n  const iteratorDependency = d => {\n    // We skip Dependencies without Reference\n    const ref = compilation.getDependencyReference(currentModule, d);\n\n    if (!ref) {\n      return;\n    } // We skip Dependencies without Module pointer\n\n\n    const refModule = ref.module;\n\n    if (!refModule) {\n      return;\n    } // We skip weak Dependencies\n\n\n    if (ref.weak) {\n      return;\n    }\n\n    blockInfoModules.add(refModule);\n  };\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n\n\n  const iteratorBlockPrepare = b => {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n  /** @type {Module} */\n\n\n  let currentModule;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {DependenciesBlock[]} */\n\n  let blockQueue;\n  /** @type {Set<Module>} */\n\n  let blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n\n  let blockInfoBlocks;\n\n  for (const module of compilation.modules) {\n    blockQueue = [module];\n    currentModule = module;\n\n    while (blockQueue.length > 0) {\n      block = blockQueue.pop();\n      blockInfoModules = new Set();\n      blockInfoBlocks = [];\n\n      if (block.variables) {\n        for (const variable of block.variables) {\n          for (const dep of variable.dependencies) iteratorDependency(dep);\n        }\n      }\n\n      if (block.dependencies) {\n        for (const dep of block.dependencies) iteratorDependency(dep);\n      }\n\n      if (block.blocks) {\n        for (const b of block.blocks) iteratorBlockPrepare(b);\n      }\n\n      const blockInfo = {\n        modules: blockInfoModules,\n        blocks: blockInfoBlocks\n      };\n      blockInfoMap.set(block, blockInfo);\n    }\n  }\n\n  return blockInfoMap;\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nconst visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  const {\n    namedChunkGroups\n  } = compilation;\n  logger.time(\"prepare\");\n  const blockInfoMap = extraceBlockInfoMap(compilation);\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n  const chunkGroupCounters = new Map();\n\n  for (const chunkGroup of inputChunkGroups) {\n    chunkGroupCounters.set(chunkGroup, {\n      index: 0,\n      index2: 0\n    });\n  }\n\n  let nextFreeModuleIndex = 0;\n  let nextFreeModuleIndex2 = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n  const blockChunkGroups = new Map();\n  const ADD_AND_ENTER_MODULE = 0;\n  const ENTER_MODULE = 1;\n  const PROCESS_BLOCK = 2;\n  const LEAVE_MODULE = 3;\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n\n  const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n    for (const chunk of chunkGroup.chunks) {\n      const module = chunk.entryModule;\n      queue.push({\n        action: ENTER_MODULE,\n        block: module,\n        module,\n        chunk,\n        chunkGroup\n      });\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  }; // Start with the provided modules/chunks\n\n  /** @type {QueueItem[]} */\n\n\n  let queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n\n  let queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n  /** @type {Module} */\n\n  let module;\n  /** @type {Chunk} */\n\n  let chunk;\n  /** @type {ChunkGroup} */\n\n  let chunkGroup;\n  /** @type {ChunkGroupInfo} */\n\n  let chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {Set<Module>} */\n\n  let minAvailableModules;\n  /** @type {QueueItem[]} */\n\n  let skippedItems; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  const iteratorBlock = b => {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    let c = blockChunkGroups.get(b);\n\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    } // 2. We store the connection for the block\n    // to connect it later if needed\n\n\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    }); // 3. We create/update the chunk group info\n\n    let connectList = queueConnect.get(chunkGroup);\n\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n\n    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal\n\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length) {\n    logger.time(\"visiting\");\n\n    while (queue.length) {\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            } // We connect Module and Chunk when not already done\n\n\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n\n            queue.push({\n              action: LEAVE_MODULE,\n              block,\n              module,\n              chunk,\n              chunkGroup\n            });\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            const blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct\n\n            const skipBuffer = [];\n            const queueBuffer = []; // Traverse all referenced modules\n\n            for (const refModule of blockInfo.modules) {\n              if (chunk.containsModule(refModule)) {\n                // skip early if already connected\n                continue;\n              }\n\n              if (minAvailableModules.has(refModule)) {\n                // already in parent chunks, skip it for now\n                skipBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n                continue;\n              } // enqueue the add and enter to enter in the correct order\n              // this is relevant with circular dependencies\n\n\n              queueBuffer.push({\n                action: ADD_AND_ENTER_MODULE,\n                block: refModule,\n                module: refModule,\n                chunk,\n                chunkGroup\n              });\n            } // Add buffered items in reversed order\n\n\n            for (let i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n\n            for (let i = queueBuffer.length - 1; i >= 0; i--) {\n              queue.push(queueBuffer[i]);\n            } // Traverse all Blocks\n\n\n            for (const block of blockInfo.blocks) iteratorBlock(block);\n\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex2(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n\n            break;\n          }\n      }\n    }\n\n    logger.timeEnd(\"visiting\");\n\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\"); // Figure out new parents for chunk groups\n      // to get new available modules for these children\n\n      for (const [chunkGroup, targets] of queueConnect) {\n        const info = chunkGroupInfoMap.get(chunkGroup);\n        let minAvailableModules = info.minAvailableModules; // 1. Create a new Set of available modules at this points\n\n        const resultingAvailableModules = new Set(minAvailableModules);\n\n        for (const chunk of chunkGroup.chunks) {\n          for (const m of chunk.modulesIterable) {\n            resultingAvailableModules.add(m);\n          }\n        }\n\n        info.resultingAvailableModules = resultingAvailableModules;\n\n        if (info.children === undefined) {\n          info.children = targets;\n        } else {\n          for (const target of targets) {\n            info.children.add(target);\n          }\n        } // 2. Update chunk group info\n\n\n        for (const target of targets) {\n          let chunkGroupInfo = chunkGroupInfoMap.get(target);\n\n          if (chunkGroupInfo === undefined) {\n            chunkGroupInfo = {\n              chunkGroup: target,\n              minAvailableModules: undefined,\n              minAvailableModulesOwned: undefined,\n              availableModulesToBeMerged: [],\n              skippedItems: [],\n              resultingAvailableModules: undefined,\n              children: undefined\n            };\n            chunkGroupInfoMap.set(target, chunkGroupInfo);\n          }\n\n          chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n          outdatedChunkGroupInfo.add(chunkGroupInfo);\n        }\n      }\n\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\"); // Execute the merge\n\n        for (const info of outdatedChunkGroupInfo) {\n          const availableModulesToBeMerged = info.availableModulesToBeMerged;\n          let cachedMinAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n          // It doesn't make sense to traverse a chunk again with more available modules.\n          // This step calculates the minimal available modules and skips traversal when\n          // the list didn't shrink.\n\n          if (availableModulesToBeMerged.length > 1) {\n            availableModulesToBeMerged.sort(bySetSize);\n          }\n\n          let changed = false;\n\n          for (const availableModules of availableModulesToBeMerged) {\n            if (cachedMinAvailableModules === undefined) {\n              cachedMinAvailableModules = availableModules;\n              info.minAvailableModules = cachedMinAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    cachedMinAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } else {\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    // cachedMinAvailableModules need to be modified\n                    // but we don't own it\n                    // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                    /** @type {Set<Module>} */\n                    const newSet = new Set();\n                    const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                    /** @type {IteratorResult<Module>} */\n\n                    let it;\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (module === m) break;\n                      newSet.add(module);\n                    }\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n\n                      if (availableModules.has(module)) {\n                        newSet.add(module);\n                      }\n                    }\n\n                    cachedMinAvailableModules = newSet;\n                    info.minAvailableModulesOwned = true;\n                    info.minAvailableModules = newSet; // Update the cache from the first queue\n                    // if the chunkGroup is currently cached\n\n                    if (chunkGroup === info.chunkGroup) {\n                      minAvailableModules = cachedMinAvailableModules;\n                    }\n\n                    changed = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          availableModulesToBeMerged.length = 0;\n          if (!changed) continue; // 2. Reconsider skipped items\n\n          for (const queueItem of info.skippedItems) {\n            queue.push(queueItem);\n          }\n\n          info.skippedItems.length = 0; // 3. Reconsider children chunk groups\n\n          if (info.children !== undefined) {\n            const chunkGroup = info.chunkGroup;\n\n            for (const c of info.children) {\n              let connectList = queueConnect.get(chunkGroup);\n\n              if (connectList === undefined) {\n                connectList = new Set();\n                queueConnect.set(chunkGroup, connectList);\n              }\n\n              connectList.add(c);\n            }\n          }\n        }\n\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nconst connectChunkGroups = (blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunk.modulesIterable) {\n        if (!availableModules.has(module)) return false;\n      }\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if ( // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(_ref => {\n      let {\n        chunkGroup,\n        originChunkGroupInfo\n      } = _ref;\n      return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n    })) {\n      continue;\n    } // 2. Foreach edge\n\n\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i]; // 3. Connect block with chunk\n\n      GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n      GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        const idx = compilation.chunks.indexOf(chunk);\n        if (idx >= 0) compilation.chunks.splice(idx, 1);\n        chunk.remove(\"unconnected\");\n      }\n\n      chunkGroup.remove(\"unconnected\");\n    }\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\n\n\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  const blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  const allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  const chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  const blocksWithNestedBlocks = new Set(); // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap); // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","GraphHelpers","bySetSize","a","b","size","extraceBlockInfoMap","compilation","blockInfoMap","Map","iteratorDependency","d","ref","getDependencyReference","currentModule","refModule","module","weak","blockInfoModules","add","iteratorBlockPrepare","blockInfoBlocks","push","blockQueue","block","modules","length","pop","Set","variables","variable","dep","dependencies","blocks","blockInfo","set","visitModules","inputChunkGroups","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","logger","getLogger","namedChunkGroups","time","chunkGroupCounters","chunkGroup","index","index2","nextFreeModuleIndex","nextFreeModuleIndex2","blockChunkGroups","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","LEAVE_MODULE","reduceChunkGroupToQueueItem","queue","chunk","chunks","entryModule","action","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","undefined","children","reduce","reverse","queueConnect","outdatedChunkGroupInfo","queueDelayed","timeEnd","chunkGroupInfo","iteratorBlock","c","get","chunkName","isInitial","errors","loc","addChunkInGroup","groupOptions","request","addOptions","addOrigin","originChunkGroupInfo","connectList","queueItem","has","addModule","addChunk","getModuleIndex","setModuleIndex","skipBuffer","queueBuffer","containsModule","i","getModuleIndex2","setModuleIndex2","targets","info","m","modulesIterable","target","clear","cachedMinAvailableModules","sort","changed","availableModules","delete","newSet","iterator","Symbol","it","next","done","value","tempQueue","connectChunkGroups","areModulesAvailable","connections","every","connectDependenciesBlockAndChunkGroup","connectChunkGroupParentAndChild","cleanupUnconnectedGroups","getNumberOfParents","idx","indexOf","splice","remove","buildChunkGraph","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n\t/** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n\tconst blockInfoMap = new Map();\n\n\t/**\n\t * @param {Dependency} d dependency to iterate over\n\t * @returns {void}\n\t */\n\tconst iteratorDependency = d => {\n\t\t// We skip Dependencies without Reference\n\t\tconst ref = compilation.getDependencyReference(currentModule, d);\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip Dependencies without Module pointer\n\t\tconst refModule = ref.module;\n\t\tif (!refModule) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip weak Dependencies\n\t\tif (ref.weak) {\n\t\t\treturn;\n\t\t}\n\n\t\tblockInfoModules.add(refModule);\n\t};\n\n\t/**\n\t * @param {AsyncDependenciesBlock} b blocks to prepare\n\t * @returns {void}\n\t */\n\tconst iteratorBlockPrepare = b => {\n\t\tblockInfoBlocks.push(b);\n\t\tblockQueue.push(b);\n\t};\n\n\t/** @type {Module} */\n\tlet currentModule;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {DependenciesBlock[]} */\n\tlet blockQueue;\n\t/** @type {Set<Module>} */\n\tlet blockInfoModules;\n\t/** @type {AsyncDependenciesBlock[]} */\n\tlet blockInfoBlocks;\n\n\tfor (const module of compilation.modules) {\n\t\tblockQueue = [module];\n\t\tcurrentModule = module;\n\t\twhile (blockQueue.length > 0) {\n\t\t\tblock = blockQueue.pop();\n\t\t\tblockInfoModules = new Set();\n\t\t\tblockInfoBlocks = [];\n\n\t\t\tif (block.variables) {\n\t\t\t\tfor (const variable of block.variables) {\n\t\t\t\t\tfor (const dep of variable.dependencies) iteratorDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\tfor (const dep of block.dependencies) iteratorDependency(dep);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\tfor (const b of block.blocks) iteratorBlockPrepare(b);\n\t\t\t}\n\n\t\t\tconst blockInfo = {\n\t\t\t\tmodules: blockInfoModules,\n\t\t\t\tblocks: blockInfoBlocks\n\t\t\t};\n\t\t\tblockInfoMap.set(block, blockInfo);\n\t\t}\n\t}\n\n\treturn blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tcompilation,\n\tinputChunkGroups,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n\tconst { namedChunkGroups } = compilation;\n\n\tlogger.time(\"prepare\");\n\tconst blockInfoMap = extraceBlockInfoMap(compilation);\n\n\t/** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\tconst chunkGroupCounters = new Map();\n\tfor (const chunkGroup of inputChunkGroups) {\n\t\tchunkGroupCounters.set(chunkGroup, {\n\t\t\tindex: 0,\n\t\t\tindex2: 0\n\t\t});\n\t}\n\n\tlet nextFreeModuleIndex = 0;\n\tlet nextFreeModuleIndex2 = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroup>} */\n\tconst blockChunkGroups = new Map();\n\n\tconst ADD_AND_ENTER_MODULE = 0;\n\tconst ENTER_MODULE = 1;\n\tconst PROCESS_BLOCK = 2;\n\tconst LEAVE_MODULE = 3;\n\n\t/**\n\t * @param {QueueItem[]} queue the queue array (will be mutated)\n\t * @param {ChunkGroup} chunkGroup chunk group\n\t * @returns {QueueItem[]} the queue array again\n\t */\n\tconst reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst module = chunk.entryModule;\n\t\t\tqueue.push({\n\t\t\t\taction: ENTER_MODULE,\n\t\t\t\tblock: module,\n\t\t\t\tmodule,\n\t\t\t\tchunk,\n\t\t\t\tchunkGroup\n\t\t\t});\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, {\n\t\t\tchunkGroup,\n\t\t\tminAvailableModules: new Set(),\n\t\t\tminAvailableModulesOwned: true,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: [],\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t\treturn queue;\n\t};\n\n\t// Start with the provided modules/chunks\n\t/** @type {QueueItem[]} */\n\tlet queue = inputChunkGroups\n\t\t.reduce(reduceChunkGroupToQueueItem, [])\n\t\t.reverse();\n\t/** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\tlogger.timeEnd(\"prepare\");\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {Set<Module>} */\n\tlet minAvailableModules;\n\t/** @type {QueueItem[]} */\n\tlet skippedItems;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet c = blockChunkGroups.get(b);\n\t\tif (c === undefined) {\n\t\t\tc = namedChunkGroups.get(b.chunkName);\n\t\t\tif (c && c.isInitial()) {\n\t\t\t\tcompilation.errors.push(\n\t\t\t\t\tnew AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)\n\t\t\t\t);\n\t\t\t\tc = chunkGroup;\n\t\t\t} else {\n\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\tmodule,\n\t\t\t\t\tb.loc,\n\t\t\t\t\tb.request\n\t\t\t\t);\n\t\t\t\tchunkGroupCounters.set(c, { index: 0, index2: 0 });\n\t\t\t\tblockChunkGroups.set(b, c);\n\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t}\n\t\t\tblockConnections.set(b, []);\n\t\t} else {\n\t\t\t// TODO webpack 5 remove addOptions check\n\t\t\tif (c.addOptions) c.addOptions(b.groupOptions);\n\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t}\n\n\t\t// 2. We store the connection for the block\n\t\t// to connect it later if needed\n\t\tblockConnections.get(b).push({\n\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\tchunkGroup: c\n\t\t});\n\n\t\t// 3. We create/update the chunk group info\n\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\tif (connectList === undefined) {\n\t\t\tconnectList = new Set();\n\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t}\n\t\tconnectList.add(c);\n\n\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\tqueueDelayed.push({\n\t\t\taction: PROCESS_BLOCK,\n\t\t\tblock: b,\n\t\t\tmodule: module,\n\t\t\tchunk: c.chunks[0],\n\t\t\tchunkGroup: c\n\t\t});\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length) {\n\t\tlogger.time(\"visiting\");\n\t\twhile (queue.length) {\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tif (chunkGroup !== queueItem.chunkGroup) {\n\t\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\t\tchunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tminAvailableModules = chunkGroupInfo.minAvailableModules;\n\t\t\t\tskippedItems = chunkGroupInfo.skippedItems;\n\t\t\t}\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (minAvailableModules.has(module)) {\n\t\t\t\t\t\t// already in parent chunks\n\t\t\t\t\t\t// skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n\t\t\t\t\t\tskippedItems.push(queueItem);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk when not already done\n\t\t\t\t\tif (chunk.addModule(module)) {\n\t\t\t\t\t\tmodule.addChunk(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index === null) {\n\t\t\t\t\t\tmodule.index = nextFreeModuleIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: LEAVE_MODULE,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\t// get prepared block info\n\t\t\t\t\tconst blockInfo = blockInfoMap.get(block);\n\n\t\t\t\t\t// Buffer items because order need to be reverse to get indicies correct\n\t\t\t\t\tconst skipBuffer = [];\n\t\t\t\t\tconst queueBuffer = [];\n\t\t\t\t\t// Traverse all referenced modules\n\t\t\t\t\tfor (const refModule of blockInfo.modules) {\n\t\t\t\t\t\tif (chunk.containsModule(refModule)) {\n\t\t\t\t\t\t\t// skip early if already connected\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (minAvailableModules.has(refModule)) {\n\t\t\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\t\t\tskipBuffer.push({\n\t\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// enqueue the add and enter to enter in the correct order\n\t\t\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\t\t\tqueueBuffer.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Add buffered items in reversed order\n\t\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tskippedItems.push(skipBuffer[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Traverse all Blocks\n\t\t\t\t\tfor (const block of blockInfo.blocks) iteratorBlock(block);\n\n\t\t\t\t\tif (blockInfo.blocks.length > 0 && module !== block) {\n\t\t\t\t\t\tblocksWithNestedBlocks.add(block);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex2(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex2(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index2++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index2 === null) {\n\t\t\t\t\t\tmodule.index2 = nextFreeModuleIndex2++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.timeEnd(\"visiting\");\n\n\t\twhile (queueConnect.size > 0) {\n\t\t\tlogger.time(\"calculating available modules\");\n\n\t\t\t// Figure out new parents for chunk groups\n\t\t\t// to get new available modules for these children\n\t\t\tfor (const [chunkGroup, targets] of queueConnect) {\n\t\t\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tlet minAvailableModules = info.minAvailableModules;\n\n\t\t\t\t// 1. Create a new Set of available modules at this points\n\t\t\t\tconst resultingAvailableModules = new Set(minAvailableModules);\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo.resultingAvailableModules = resultingAvailableModules;\n\t\t\t\tif (info.children === undefined) {\n\t\t\t\t\tinfo.children = targets;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const target of targets) {\n\t\t\t\t\t\tinfo.children.add(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. Update chunk group info\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tlet chunkGroupInfo = chunkGroupInfoMap.get(target);\n\t\t\t\t\tif (chunkGroupInfo === undefined) {\n\t\t\t\t\t\tchunkGroupInfo = {\n\t\t\t\t\t\t\tchunkGroup: target,\n\t\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\t\tskippedItems: [],\n\t\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tchunkGroupInfoMap.set(target, chunkGroupInfo);\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupInfo.availableModulesToBeMerged.push(\n\t\t\t\t\t\tresultingAvailableModules\n\t\t\t\t\t);\n\t\t\t\t\toutdatedChunkGroupInfo.add(chunkGroupInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueueConnect.clear();\n\t\t\tlogger.timeEnd(\"calculating available modules\");\n\n\t\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\t\tlogger.time(\"merging available modules\");\n\t\t\t\t// Execute the merge\n\t\t\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\t\t\t// 1. Get minimal available modules\n\t\t\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t\t\t// the list didn't shrink.\n\t\t\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t\t\t}\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\t\t\tconst newSet = new Set();\n\t\t\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[\n\t\t\t\t\t\t\t\t\t\t\tSymbol.iterator\n\t\t\t\t\t\t\t\t\t\t]();\n\t\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\n\t\t\t\t\t\t\t\t\t\t// Update the cache from the first queue\n\t\t\t\t\t\t\t\t\t\t// if the chunkGroup is currently cached\n\t\t\t\t\t\t\t\t\t\tif (chunkGroup === info.chunkGroup) {\n\t\t\t\t\t\t\t\t\t\t\tminAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\t\t\tif (!changed) continue;\n\n\t\t\t\t\t// 2. Reconsider skipped items\n\t\t\t\t\tfor (const queueItem of info.skippedItems) {\n\t\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.skippedItems.length = 0;\n\n\t\t\t\t\t// 3. Reconsider children chunk groups\n\t\t\t\t\tif (info.children !== undefined) {\n\t\t\t\t\t\tconst chunkGroup = info.chunkGroup;\n\t\t\t\t\t\tfor (const c of info.children) {\n\t\t\t\t\t\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\t\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnectList.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toutdatedChunkGroupInfo.clear();\n\t\t\t\tlogger.timeEnd(\"merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indicing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {Set<Module>} availableModules the comparitor set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (!availableModules.has(module)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tGraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tGraphHelpers.connectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tconst idx = compilation.chunks.indexOf(chunk);\n\t\t\t\tif (idx >= 0) compilation.chunks.splice(idx, 1);\n\t\t\t\tchunk.remove(\"unconnected\");\n\t\t\t}\n\t\t\tchunkGroup.remove(\"unconnected\");\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tvisitModules(\n\t\tcompilation,\n\t\tinputChunkGroups,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\n\t// PART TWO\n\n\tconnectChunkGroups(\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\n\t// Cleaup work\n\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}