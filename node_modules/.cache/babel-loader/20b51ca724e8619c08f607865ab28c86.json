{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar define = require('define-property');\n\nvar CacheBase = require('cache-base');\n\nvar Emitter = require('component-emitter');\n\nvar isObject = require('isobject');\n\nvar merge = require('mixin-deep');\n\nvar pascal = require('pascalcase');\n\nvar cu = require('class-utils');\n/**\n * Optionally define a custom `cache` namespace to use.\n */\n\n\nfunction namespace(name) {\n  var Cache = name ? CacheBase.namespace(name) : CacheBase;\n  var fns = [];\n  /**\n   * Create an instance of `Base` with the given `config` and `options`.\n   *\n   * ```js\n   * // initialize with `config` and `options`\n   * var app = new Base({isApp: true}, {abc: true});\n   * app.set('foo', 'bar');\n   *\n   * // values defined with the given `config` object will be on the root of the instance\n   * console.log(app.baz); //=> undefined\n   * console.log(app.foo); //=> 'bar'\n   * // or use `.get`\n   * console.log(app.get('isApp')); //=> true\n   * console.log(app.get('foo')); //=> 'bar'\n   *\n   * // values defined with the given `options` object will be on `app.options\n   * console.log(app.options.abc); //=> true\n   * ```\n   *\n   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.\n   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.\n   * @api public\n   */\n\n  function Base(config, options) {\n    if (!(this instanceof Base)) {\n      return new Base(config, options);\n    }\n\n    Cache.call(this, config);\n    this.is('base');\n    this.initBase(config, options);\n  }\n  /**\n   * Inherit cache-base\n   */\n\n\n  util.inherits(Base, Cache);\n  /**\n   * Add static emitter methods\n   */\n\n  Emitter(Base);\n  /**\n   * Initialize `Base` defaults with the given `config` object\n   */\n\n  Base.prototype.initBase = function (config, options) {\n    this.options = merge({}, this.options, options);\n    this.cache = this.cache || {};\n    this.define('registered', {});\n    if (name) this[name] = {}; // make `app._callbacks` non-enumerable\n\n    this.define('_callbacks', this._callbacks);\n\n    if (isObject(config)) {\n      this.visit('set', config);\n    }\n\n    Base.run(this, 'use', fns);\n  };\n  /**\n   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing\n   * lookups in plugins.\n   *\n   * ```js\n   * app.is('foo');\n   * console.log(app._name);\n   * //=> 'foo'\n   * console.log(app.isFoo);\n   * //=> true\n   * app.is('bar');\n   * console.log(app.isFoo);\n   * //=> true\n   * console.log(app.isBar);\n   * //=> true\n   * console.log(app._name);\n   * //=> 'bar'\n   * ```\n   * @name .is\n   * @param {String} `name`\n   * @return {Boolean}\n   * @api public\n   */\n\n\n  Base.prototype.is = function (name) {\n    if (typeof name !== 'string') {\n      throw new TypeError('expected name to be a string');\n    }\n\n    this.define('is' + pascal(name), true);\n    this.define('_name', name);\n    this.define('_appname', name);\n    return this;\n  };\n  /**\n   * Returns true if a plugin has already been registered on an instance.\n   *\n   * Plugin implementors are encouraged to use this first thing in a plugin\n   * to prevent the plugin from being called more than once on the same\n   * instance.\n   *\n   * ```js\n   * var base = new Base();\n   * base.use(function(app) {\n   *   if (app.isRegistered('myPlugin')) return;\n   *   // do stuff to `app`\n   * });\n   *\n   * // to also record the plugin as being registered\n   * base.use(function(app) {\n   *   if (app.isRegistered('myPlugin', true)) return;\n   *   // do stuff to `app`\n   * });\n   * ```\n   * @name .isRegistered\n   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.\n   * @param {String} `name` The plugin name.\n   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.\n   * @return {Boolean} Returns true if a plugin is already registered.\n   * @api public\n   */\n\n\n  Base.prototype.isRegistered = function (name, register) {\n    if (this.registered.hasOwnProperty(name)) {\n      return true;\n    }\n\n    if (register !== false) {\n      this.registered[name] = true;\n      this.emit('plugin', name);\n    }\n\n    return false;\n  };\n  /**\n   * Define a plugin function to be called immediately upon init. Plugins are chainable\n   * and expose the following arguments to the plugin function:\n   *\n   * - `app`: the current instance of `Base`\n   * - `base`: the [first ancestor instance](#base) of `Base`\n   *\n   * ```js\n   * var app = new Base()\n   *   .use(foo)\n   *   .use(bar)\n   *   .use(baz)\n   * ```\n   * @name .use\n   * @param {Function} `fn` plugin function to call\n   * @return {Object} Returns the item instance for chaining.\n   * @api public\n   */\n\n\n  Base.prototype.use = function (fn) {\n    fn.call(this, this);\n    return this;\n  };\n  /**\n   * The `.define` method is used for adding non-enumerable property on the instance.\n   * Dot-notation is **not supported** with `define`.\n   *\n   * ```js\n   * // arbitrary `render` function using lodash `template`\n   * app.define('render', function(str, locals) {\n   *   return _.template(str)(locals);\n   * });\n   * ```\n   * @name .define\n   * @param {String} `key` The name of the property to define.\n   * @param {any} `value`\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n\n  Base.prototype.define = function (key, val) {\n    if (isObject(key)) {\n      return this.visit('define', key);\n    }\n\n    define(this, key, val);\n    return this;\n  };\n  /**\n   * Mix property `key` onto the Base prototype. If base is inherited using\n   * `Base.extend` this method will be overridden by a new `mixin` method that will\n   * only add properties to the prototype of the inheriting application.\n   *\n   * ```js\n   * app.mixin('foo', function() {\n   *   // do stuff\n   * });\n   * ```\n   * @name .mixin\n   * @param {String} `key`\n   * @param {Object|Array} `val`\n   * @return {Object} Returns the `base` instance for chaining.\n   * @api public\n   */\n\n\n  Base.prototype.mixin = function (key, val) {\n    Base.prototype[key] = val;\n    return this;\n  };\n  /**\n   * Non-enumberable mixin array, used by the static [Base.mixin]() method.\n   */\n\n\n  Base.prototype.mixins = Base.prototype.mixins || [];\n  /**\n   * Getter/setter used when creating nested instances of `Base`, for storing a reference\n   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`\n   * property of a \"child\" instance. The `base` property defaults to the current instance if\n   * no `parent` property is defined.\n   *\n   * ```js\n   * // create an instance of `Base`, this is our first (\"base\") instance\n   * var first = new Base();\n   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later\n   *\n   * // create another instance\n   * var second = new Base();\n   * // create a reference to the first instance (`first`)\n   * second.parent = first;\n   *\n   * // create another instance\n   * var third = new Base();\n   * // create a reference to the previous instance (`second`)\n   * // repeat this pattern every time a \"child\" instance is created\n   * third.parent = second;\n   *\n   * // we can always access the first instance using the `base` property\n   * console.log(first.base.foo);\n   * //=> 'bar'\n   * console.log(second.base.foo);\n   * //=> 'bar'\n   * console.log(third.base.foo);\n   * //=> 'bar'\n   * // and now you know how to get to third base ;)\n   * ```\n   * @name .base\n   * @api public\n   */\n\n  Object.defineProperty(Base.prototype, 'base', {\n    configurable: true,\n    get: function () {\n      return this.parent ? this.parent.base : this;\n    }\n  });\n  /**\n   * Static method for adding global plugin functions that will\n   * be added to an instance when created.\n   *\n   * ```js\n   * Base.use(function(app) {\n   *   app.foo = 'bar';\n   * });\n   * var app = new Base();\n   * console.log(app.foo);\n   * //=> 'bar'\n   * ```\n   * @name #use\n   * @param {Function} `fn` Plugin function to use on each instance.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'use', function (fn) {\n    fns.push(fn);\n    return Base;\n  });\n  /**\n   * Run an array of functions by passing each function\n   * to a method on the given object specified by the given property.\n   *\n   * @param  {Object} `obj` Object containing method to use.\n   * @param  {String} `prop` Name of the method on the object to use.\n   * @param  {Array} `arr` Array of functions to pass to the method.\n   */\n\n  define(Base, 'run', function (obj, prop, arr) {\n    var len = arr.length,\n        i = 0;\n\n    while (len--) {\n      obj[prop](arr[i++]);\n    }\n\n    return Base;\n  });\n  /**\n   * Static method for inheriting the prototype and static methods of the `Base` class.\n   * This method greatly simplifies the process of creating inheritance-based applications.\n   * See [static-extend][] for more details.\n   *\n   * ```js\n   * var extend = cu.extend(Parent);\n   * Parent.extend(Child);\n   *\n   * // optional methods\n   * Parent.extend(Child, {\n   *   foo: function() {},\n   *   bar: function() {}\n   * });\n   * ```\n   * @name #extend\n   * @param {Function} `Ctor` constructor to extend\n   * @param {Object} `methods` Optional prototype properties to mix in.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'extend', cu.extend(Base, function (Ctor, Parent) {\n    Ctor.prototype.mixins = Ctor.prototype.mixins || [];\n    define(Ctor, 'mixin', function (fn) {\n      var mixin = fn(Ctor.prototype, Ctor);\n\n      if (typeof mixin === 'function') {\n        Ctor.prototype.mixins.push(mixin);\n      }\n\n      return Ctor;\n    });\n    define(Ctor, 'mixins', function (Child) {\n      Base.run(Child, 'mixin', Ctor.prototype.mixins);\n      return Ctor;\n    });\n\n    Ctor.prototype.mixin = function (key, value) {\n      Ctor.prototype[key] = value;\n      return this;\n    };\n\n    return Base;\n  }));\n  /**\n   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.\n   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`\n   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is\n   * called (e.g. `Base.mixins(Child)`).\n   *\n   * ```js\n   * Base.mixin(function(proto) {\n   *   proto.foo = function(msg) {\n   *     return 'foo ' + msg;\n   *   };\n   * });\n   * ```\n   * @name #mixin\n   * @param {Function} `fn` Function to call\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'mixin', function (fn) {\n    var mixin = fn(Base.prototype, Base);\n\n    if (typeof mixin === 'function') {\n      Base.prototype.mixins.push(mixin);\n    }\n\n    return Base;\n  });\n  /**\n   * Static method for running global mixin functions against a child constructor.\n   * Mixins must be registered before calling this method.\n   *\n   * ```js\n   * Base.extend(Child);\n   * Base.mixins(Child);\n   * ```\n   * @name #mixins\n   * @param {Function} `Child` Constructor function of a child class\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'mixins', function (Child) {\n    Base.run(Child, 'mixin', Base.prototype.mixins);\n    return Base;\n  });\n  /**\n   * Similar to `util.inherit`, but copies all static properties, prototype properties, and\n   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.\n   *\n   * ```js\n   * Base.inherit(Foo, Bar);\n   * ```\n   * @name #inherit\n   * @param {Function} `Receiver` Receiving (child) constructor\n   * @param {Function} `Provider` Providing (parent) constructor\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'inherit', cu.inherit);\n  define(Base, 'bubble', cu.bubble);\n  return Base;\n}\n/**\n * Expose `Base` with default settings\n */\n\n\nmodule.exports = namespace();\n/**\n * Allow users to define a namespace\n */\n\nmodule.exports.namespace = namespace;","map":{"version":3,"names":["util","require","define","CacheBase","Emitter","isObject","merge","pascal","cu","namespace","name","Cache","fns","Base","config","options","call","is","initBase","inherits","prototype","cache","_callbacks","visit","run","TypeError","isRegistered","register","registered","hasOwnProperty","emit","use","fn","key","val","mixin","mixins","Object","defineProperty","configurable","get","parent","base","push","obj","prop","arr","len","length","i","extend","Ctor","Parent","Child","value","inherit","bubble","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/base/index.js"],"sourcesContent":["'use strict';\n\nvar util = require('util');\nvar define = require('define-property');\nvar CacheBase = require('cache-base');\nvar Emitter = require('component-emitter');\nvar isObject = require('isobject');\nvar merge = require('mixin-deep');\nvar pascal = require('pascalcase');\nvar cu = require('class-utils');\n\n/**\n * Optionally define a custom `cache` namespace to use.\n */\n\nfunction namespace(name) {\n  var Cache = name ? CacheBase.namespace(name) : CacheBase;\n  var fns = [];\n\n  /**\n   * Create an instance of `Base` with the given `config` and `options`.\n   *\n   * ```js\n   * // initialize with `config` and `options`\n   * var app = new Base({isApp: true}, {abc: true});\n   * app.set('foo', 'bar');\n   *\n   * // values defined with the given `config` object will be on the root of the instance\n   * console.log(app.baz); //=> undefined\n   * console.log(app.foo); //=> 'bar'\n   * // or use `.get`\n   * console.log(app.get('isApp')); //=> true\n   * console.log(app.get('foo')); //=> 'bar'\n   *\n   * // values defined with the given `options` object will be on `app.options\n   * console.log(app.options.abc); //=> true\n   * ```\n   *\n   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.\n   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.\n   * @api public\n   */\n\n  function Base(config, options) {\n    if (!(this instanceof Base)) {\n      return new Base(config, options);\n    }\n    Cache.call(this, config);\n    this.is('base');\n    this.initBase(config, options);\n  }\n\n  /**\n   * Inherit cache-base\n   */\n\n  util.inherits(Base, Cache);\n\n  /**\n   * Add static emitter methods\n   */\n\n  Emitter(Base);\n\n  /**\n   * Initialize `Base` defaults with the given `config` object\n   */\n\n  Base.prototype.initBase = function(config, options) {\n    this.options = merge({}, this.options, options);\n    this.cache = this.cache || {};\n    this.define('registered', {});\n    if (name) this[name] = {};\n\n    // make `app._callbacks` non-enumerable\n    this.define('_callbacks', this._callbacks);\n    if (isObject(config)) {\n      this.visit('set', config);\n    }\n    Base.run(this, 'use', fns);\n  };\n\n  /**\n   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing\n   * lookups in plugins.\n   *\n   * ```js\n   * app.is('foo');\n   * console.log(app._name);\n   * //=> 'foo'\n   * console.log(app.isFoo);\n   * //=> true\n   * app.is('bar');\n   * console.log(app.isFoo);\n   * //=> true\n   * console.log(app.isBar);\n   * //=> true\n   * console.log(app._name);\n   * //=> 'bar'\n   * ```\n   * @name .is\n   * @param {String} `name`\n   * @return {Boolean}\n   * @api public\n   */\n\n  Base.prototype.is = function(name) {\n    if (typeof name !== 'string') {\n      throw new TypeError('expected name to be a string');\n    }\n    this.define('is' + pascal(name), true);\n    this.define('_name', name);\n    this.define('_appname', name);\n    return this;\n  };\n\n  /**\n   * Returns true if a plugin has already been registered on an instance.\n   *\n   * Plugin implementors are encouraged to use this first thing in a plugin\n   * to prevent the plugin from being called more than once on the same\n   * instance.\n   *\n   * ```js\n   * var base = new Base();\n   * base.use(function(app) {\n   *   if (app.isRegistered('myPlugin')) return;\n   *   // do stuff to `app`\n   * });\n   *\n   * // to also record the plugin as being registered\n   * base.use(function(app) {\n   *   if (app.isRegistered('myPlugin', true)) return;\n   *   // do stuff to `app`\n   * });\n   * ```\n   * @name .isRegistered\n   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.\n   * @param {String} `name` The plugin name.\n   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.\n   * @return {Boolean} Returns true if a plugin is already registered.\n   * @api public\n   */\n\n  Base.prototype.isRegistered = function(name, register) {\n    if (this.registered.hasOwnProperty(name)) {\n      return true;\n    }\n    if (register !== false) {\n      this.registered[name] = true;\n      this.emit('plugin', name);\n    }\n    return false;\n  };\n\n  /**\n   * Define a plugin function to be called immediately upon init. Plugins are chainable\n   * and expose the following arguments to the plugin function:\n   *\n   * - `app`: the current instance of `Base`\n   * - `base`: the [first ancestor instance](#base) of `Base`\n   *\n   * ```js\n   * var app = new Base()\n   *   .use(foo)\n   *   .use(bar)\n   *   .use(baz)\n   * ```\n   * @name .use\n   * @param {Function} `fn` plugin function to call\n   * @return {Object} Returns the item instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.use = function(fn) {\n    fn.call(this, this);\n    return this;\n  };\n\n  /**\n   * The `.define` method is used for adding non-enumerable property on the instance.\n   * Dot-notation is **not supported** with `define`.\n   *\n   * ```js\n   * // arbitrary `render` function using lodash `template`\n   * app.define('render', function(str, locals) {\n   *   return _.template(str)(locals);\n   * });\n   * ```\n   * @name .define\n   * @param {String} `key` The name of the property to define.\n   * @param {any} `value`\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.define = function(key, val) {\n    if (isObject(key)) {\n      return this.visit('define', key);\n    }\n    define(this, key, val);\n    return this;\n  };\n\n  /**\n   * Mix property `key` onto the Base prototype. If base is inherited using\n   * `Base.extend` this method will be overridden by a new `mixin` method that will\n   * only add properties to the prototype of the inheriting application.\n   *\n   * ```js\n   * app.mixin('foo', function() {\n   *   // do stuff\n   * });\n   * ```\n   * @name .mixin\n   * @param {String} `key`\n   * @param {Object|Array} `val`\n   * @return {Object} Returns the `base` instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.mixin = function(key, val) {\n    Base.prototype[key] = val;\n    return this;\n  };\n\n  /**\n   * Non-enumberable mixin array, used by the static [Base.mixin]() method.\n   */\n\n  Base.prototype.mixins = Base.prototype.mixins || [];\n\n  /**\n   * Getter/setter used when creating nested instances of `Base`, for storing a reference\n   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`\n   * property of a \"child\" instance. The `base` property defaults to the current instance if\n   * no `parent` property is defined.\n   *\n   * ```js\n   * // create an instance of `Base`, this is our first (\"base\") instance\n   * var first = new Base();\n   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later\n   *\n   * // create another instance\n   * var second = new Base();\n   * // create a reference to the first instance (`first`)\n   * second.parent = first;\n   *\n   * // create another instance\n   * var third = new Base();\n   * // create a reference to the previous instance (`second`)\n   * // repeat this pattern every time a \"child\" instance is created\n   * third.parent = second;\n   *\n   * // we can always access the first instance using the `base` property\n   * console.log(first.base.foo);\n   * //=> 'bar'\n   * console.log(second.base.foo);\n   * //=> 'bar'\n   * console.log(third.base.foo);\n   * //=> 'bar'\n   * // and now you know how to get to third base ;)\n   * ```\n   * @name .base\n   * @api public\n   */\n\n  Object.defineProperty(Base.prototype, 'base', {\n    configurable: true,\n    get: function() {\n      return this.parent ? this.parent.base : this;\n    }\n  });\n\n  /**\n   * Static method for adding global plugin functions that will\n   * be added to an instance when created.\n   *\n   * ```js\n   * Base.use(function(app) {\n   *   app.foo = 'bar';\n   * });\n   * var app = new Base();\n   * console.log(app.foo);\n   * //=> 'bar'\n   * ```\n   * @name #use\n   * @param {Function} `fn` Plugin function to use on each instance.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'use', function(fn) {\n    fns.push(fn);\n    return Base;\n  });\n\n  /**\n   * Run an array of functions by passing each function\n   * to a method on the given object specified by the given property.\n   *\n   * @param  {Object} `obj` Object containing method to use.\n   * @param  {String} `prop` Name of the method on the object to use.\n   * @param  {Array} `arr` Array of functions to pass to the method.\n   */\n\n  define(Base, 'run', function(obj, prop, arr) {\n    var len = arr.length, i = 0;\n    while (len--) {\n      obj[prop](arr[i++]);\n    }\n    return Base;\n  });\n\n  /**\n   * Static method for inheriting the prototype and static methods of the `Base` class.\n   * This method greatly simplifies the process of creating inheritance-based applications.\n   * See [static-extend][] for more details.\n   *\n   * ```js\n   * var extend = cu.extend(Parent);\n   * Parent.extend(Child);\n   *\n   * // optional methods\n   * Parent.extend(Child, {\n   *   foo: function() {},\n   *   bar: function() {}\n   * });\n   * ```\n   * @name #extend\n   * @param {Function} `Ctor` constructor to extend\n   * @param {Object} `methods` Optional prototype properties to mix in.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {\n    Ctor.prototype.mixins = Ctor.prototype.mixins || [];\n\n    define(Ctor, 'mixin', function(fn) {\n      var mixin = fn(Ctor.prototype, Ctor);\n      if (typeof mixin === 'function') {\n        Ctor.prototype.mixins.push(mixin);\n      }\n      return Ctor;\n    });\n\n    define(Ctor, 'mixins', function(Child) {\n      Base.run(Child, 'mixin', Ctor.prototype.mixins);\n      return Ctor;\n    });\n\n    Ctor.prototype.mixin = function(key, value) {\n      Ctor.prototype[key] = value;\n      return this;\n    };\n    return Base;\n  }));\n\n  /**\n   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.\n   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`\n   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is\n   * called (e.g. `Base.mixins(Child)`).\n   *\n   * ```js\n   * Base.mixin(function(proto) {\n   *   proto.foo = function(msg) {\n   *     return 'foo ' + msg;\n   *   };\n   * });\n   * ```\n   * @name #mixin\n   * @param {Function} `fn` Function to call\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'mixin', function(fn) {\n    var mixin = fn(Base.prototype, Base);\n    if (typeof mixin === 'function') {\n      Base.prototype.mixins.push(mixin);\n    }\n    return Base;\n  });\n\n  /**\n   * Static method for running global mixin functions against a child constructor.\n   * Mixins must be registered before calling this method.\n   *\n   * ```js\n   * Base.extend(Child);\n   * Base.mixins(Child);\n   * ```\n   * @name #mixins\n   * @param {Function} `Child` Constructor function of a child class\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'mixins', function(Child) {\n    Base.run(Child, 'mixin', Base.prototype.mixins);\n    return Base;\n  });\n\n  /**\n   * Similar to `util.inherit`, but copies all static properties, prototype properties, and\n   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.\n   *\n   * ```js\n   * Base.inherit(Foo, Bar);\n   * ```\n   * @name #inherit\n   * @param {Function} `Receiver` Receiving (child) constructor\n   * @param {Function} `Provider` Providing (parent) constructor\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, 'inherit', cu.inherit);\n  define(Base, 'bubble', cu.bubble);\n  return Base;\n}\n\n/**\n * Expose `Base` with default settings\n */\n\nmodule.exports = namespace();\n\n/**\n * Allow users to define a namespace\n */\n\nmodule.exports.namespace = namespace;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}