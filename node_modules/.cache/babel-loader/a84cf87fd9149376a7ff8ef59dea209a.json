{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\n\nconst SortableSet = require(\"../util/SortableSet\");\n\nconst GraphHelpers = require(\"../GraphHelpers\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nconst contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nconst deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nconst hashFilename = name => {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nconst getRequests = chunk => {\n  let requests = 0;\n\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n\n  return requests;\n};\n\nconst getModulesSize = modules => {\n  let sum = 0;\n\n  for (const m of modules) {\n    sum += m.size();\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n\n  return false;\n};\n\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  const aSizeReduce = a.size * (a.chunks.size - 1);\n  const bSizeReduce = b.size * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  const indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  const aI = modulesA[Symbol.iterator]();\n  const bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const aItem = aI.next();\n    const bItem = bI.next();\n    if (aItem.done) return 0;\n    const aModuleIdentifier = aItem.value.identifier();\n    const bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\n\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\n\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n  constructor(options) {\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  static normalizeOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return {\n      chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n      minSize: options.minSize || 0,\n      enforceSizeThreshold: options.enforceSizeThreshold || 0,\n      maxSize: options.maxSize || 0,\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n        cacheGroups: options.cacheGroups,\n        name: options.name,\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength\n      }),\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      automaticNameMaxLength: options.automaticNameMaxLength || 109,\n      fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n    };\n  }\n\n  static normalizeName(_ref) {\n    let {\n      name,\n      automaticNameDelimiter,\n      automaticNamePrefix,\n      automaticNameMaxLength\n    } = _ref;\n\n    if (name === true) {\n      /** @type {WeakMap<Chunk[], Record<string, string>>} */\n      const cache = new WeakMap();\n\n      const fn = (module, chunks, cacheGroup) => {\n        let cacheEntry = cache.get(chunks);\n\n        if (cacheEntry === undefined) {\n          cacheEntry = {};\n          cache.set(chunks, cacheEntry);\n        } else if (cacheGroup in cacheEntry) {\n          return cacheEntry[cacheGroup];\n        }\n\n        const names = chunks.map(c => c.name);\n\n        if (!names.every(Boolean)) {\n          cacheEntry[cacheGroup] = undefined;\n          return;\n        }\n\n        names.sort();\n        const prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n        const namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n        let name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n        // ENAMETOOLONG error is raised. If the generated name if too\n        // long, it is truncated and a hash is appended. The limit has\n        // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n        // generating a 256+ character string.\n\n        if (name.length > automaticNameMaxLength) {\n          const hashedFilename = hashFilename(name);\n          const sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n          name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n        }\n\n        cacheEntry[cacheGroup] = name;\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"string\") {\n      const fn = () => {\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"function\") return name;\n  }\n\n  static normalizeChunksFilter(chunks) {\n    if (chunks === \"initial\") {\n      return INITIAL_CHUNK_FILTER;\n    }\n\n    if (chunks === \"async\") {\n      return ASYNC_CHUNK_FILTER;\n    }\n\n    if (chunks === \"all\") {\n      return ALL_CHUNK_FILTER;\n    }\n\n    if (typeof chunks === \"function\") return chunks;\n  }\n\n  static normalizeFallbackCacheGroup(_ref2, _ref3) {\n    let {\n      minSize = undefined,\n      maxSize = undefined,\n      automaticNameDelimiter = undefined\n    } = _ref2;\n    let {\n      minSize: defaultMinSize = undefined,\n      maxSize: defaultMaxSize = undefined,\n      automaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n    } = _ref3;\n    return {\n      minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n      maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n      automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n    };\n  }\n\n  static normalizeCacheGroups(_ref4) {\n    let {\n      cacheGroups,\n      name,\n      automaticNameDelimiter,\n      automaticNameMaxLength\n    } = _ref4;\n\n    if (typeof cacheGroups === \"function\") {\n      // TODO webpack 5 remove this\n      if (cacheGroups.length !== 1) {\n        return module => cacheGroups(module, module.getChunks());\n      }\n\n      return cacheGroups;\n    }\n\n    if (cacheGroups && typeof cacheGroups === \"object\") {\n      const fn = module => {\n        let results;\n\n        for (const key of Object.keys(cacheGroups)) {\n          let option = cacheGroups[key];\n          if (option === false) continue;\n\n          if (option instanceof RegExp || typeof option === \"string\") {\n            option = {\n              test: option\n            };\n          }\n\n          if (typeof option === \"function\") {\n            let result = option(module);\n\n            if (result) {\n              if (results === undefined) results = [];\n\n              for (const r of Array.isArray(result) ? result : [result]) {\n                const result = Object.assign({\n                  key\n                }, r);\n                if (result.name) result.getName = () => result.name;\n\n                if (result.chunks) {\n                  result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                }\n\n                results.push(result);\n              }\n            }\n          } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n            if (results === undefined) results = [];\n            results.push({\n              key: key,\n              priority: option.priority,\n              getName: SplitChunksPlugin.normalizeName({\n                name: option.name || name,\n                automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                automaticNamePrefix: option.automaticNamePrefix,\n                automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n              }) || (() => {}),\n              chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n              enforce: option.enforce,\n              minSize: option.minSize,\n              enforceSizeThreshold: option.enforceSizeThreshold,\n              maxSize: option.maxSize,\n              minChunks: option.minChunks,\n              maxAsyncRequests: option.maxAsyncRequests,\n              maxInitialRequests: option.maxInitialRequests,\n              filename: option.filename,\n              reuseExistingChunk: option.reuseExistingChunk\n            });\n          }\n        }\n\n        return results;\n      };\n\n      return fn;\n    }\n\n    const fn = () => {};\n\n    return fn;\n  }\n\n  static checkTest(test, module) {\n    if (test === undefined) return true;\n\n    if (typeof test === \"function\") {\n      if (test.length !== 1) {\n        return test(module, module.getChunks());\n      }\n\n      return test(module);\n    }\n\n    if (typeof test === \"boolean\") return test;\n\n    if (typeof test === \"string\") {\n      if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && chunk.name.startsWith(test)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (test instanceof RegExp) {\n      if (module.nameForCondition && test.test(module.nameForCondition())) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && test.test(chunk.name)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n        const indexMap = new Map();\n        let index = 1;\n\n        for (const chunk of chunks) {\n          indexMap.set(chunk, index++);\n        }\n\n        const getKey = chunks => {\n          return Array.from(chunks, c => indexMap.get(c)).sort(compareNumbers).join();\n        };\n        /** @type {Map<string, Set<Chunk>>} */\n\n\n        const chunkSetsInGraph = new Map();\n\n        for (const module of compilation.modules) {\n          const chunksKey = getKey(module.chunksIterable);\n\n          if (!chunkSetsInGraph.has(chunksKey)) {\n            chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n          }\n        } // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n\n        /** @type {Map<number, Array<Set<Chunk>>>} */\n\n\n        const chunkSetsByCount = new Map();\n\n        for (const chunksSet of chunkSetsInGraph.values()) {\n          const count = chunksSet.size;\n          let array = chunkSetsByCount.get(count);\n\n          if (array === undefined) {\n            array = [];\n            chunkSetsByCount.set(count, array);\n          }\n\n          array.push(chunksSet);\n        } // Create a list of possible combinations\n\n\n        const combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n        const getCombinations = key => {\n          const chunksSet = chunkSetsInGraph.get(key);\n          var array = [chunksSet];\n\n          if (chunksSet.size > 1) {\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n          }\n\n          return array;\n        };\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {string} key a key of the list\n         */\n\n        /**\n         * @typedef {function(Chunk): boolean} ChunkFilterFunction\n         */\n\n        /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n        const selectedChunksCacheByChunksSet = new WeakMap();\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk>} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n\n\n          let entry2 = entry.get(chunkFilter);\n\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n\n            for (const chunk of chunks) {\n              if (chunkFilter(chunk)) selectedChunks.push(chunk);\n            }\n\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n\n          return entry2;\n        };\n        /**\n         * @typedef {Object} ChunksInfoItem\n         * @property {SortableSet} modules\n         * @property {TODO} cacheGroup\n         * @property {number} cacheGroupIndex\n         * @property {string} name\n         * @property {number} size\n         * @property {Set<Chunk>} chunks\n         * @property {Set<Chunk>} reuseableChunks\n         * @property {Set<string>} chunksKeys\n         */\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n        /** @type {Map<string, ChunksInfoItem>} */\n\n\n        const chunksInfoMap = new Map();\n        /**\n         * @param {TODO} cacheGroup the current cache group\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {string} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n          // When it has a name we use the name as key\n          // Elsewise we create the key from chunks and cache group key\n          // This automatically merges equal names\n\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`); // Add module to maps\n\n          let info = chunksInfoMap.get(key);\n\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, sortByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              size: 0,\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n\n          info.modules.add(module);\n          info.size += module.size();\n\n          if (!info.chunksKeys.has(selectedChunksKey)) {\n            info.chunksKeys.add(selectedChunksKey);\n\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        }; // Walk through all modules\n\n\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module);\n\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          } // Prepare some values\n\n\n          const chunksKey = getKey(module.chunksIterable);\n          let combs = combinationsCache.get(chunksKey);\n\n          if (combs === undefined) {\n            combs = getCombinations(chunksKey);\n            combinationsCache.set(chunksKey, combs);\n          }\n\n          let cacheGroupIndex = 0;\n\n          for (const cacheGroupSource of cacheGroups) {\n            const minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : this.options.minSize;\n            const enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : this.options.enforceSizeThreshold;\n            const cacheGroup = {\n              key: cacheGroupSource.key,\n              priority: cacheGroupSource.priority || 0,\n              chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n              minSize,\n              minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : this.options.minSize,\n              enforceSizeThreshold,\n              maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : this.options.maxSize,\n              minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n              maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n              maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n              getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n              filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n              automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n              reuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n              _validateSize: minSize > 0,\n              _conditionalEnforce: enforceSizeThreshold > 0\n            }; // For all combination of chunk selection\n\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n\n            cacheGroupIndex++;\n          }\n        } // Filter items were size < minSize\n\n\n        for (const pair of chunksInfoMap) {\n          const info = pair[1];\n\n          if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n            chunksInfoMap.delete(pair[0]);\n          }\n        }\n        /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n\n        const maxSizeQueueMap = new Map();\n\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n\n            if (bestEntry === undefined) {\n              bestEntry = info;\n              bestEntryKey = key;\n            } else if (compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name; // Variable for the new chunk (lazy created)\n\n          /** @type {Chunk} */\n\n          let newChunk; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n          let isReused = false;\n\n          if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunk.getNumberOfModules() !== item.modules.size) continue;\n              if (chunk.hasEntryModule()) continue;\n\n              for (const module of item.modules) {\n                if (!chunk.containsModule(module)) continue outer;\n              }\n\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n\n              chunkName = undefined;\n              isReused = true;\n            }\n          } // Check if maxRequests condition can be fulfilled\n\n\n          const selectedChunks = Array.from(item.chunks).filter(chunk => {\n            // skip if we address ourself\n            return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n          });\n          const enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold; // Skip when no chunk selected\n\n          if (selectedChunks.length === 0) continue;\n          const usedChunks = new Set(selectedChunks); // Check if maxRequests condition can be fulfilled\n\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunk.containsModule(module)) continue outer;\n            }\n\n            usedChunks.delete(chunk);\n          } // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n\n\n          if (usedChunks.size < selectedChunks.length) {\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n\n            continue;\n          } // Create the new chunk if not reusing one\n\n\n          if (!isReused) {\n            newChunk = compilation.addChunk(chunkName);\n          } // Walk through all chunks\n\n\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          } // Add a note to the chunk\n\n\n          newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`; // If the chosen name is already an entry point we remove the entry point\n\n            const entrypoint = compilation.entrypoints.get(chunkName);\n\n            if (entrypoint) {\n              compilation.entrypoints.delete(chunkName);\n              entrypoint.remove();\n              newChunk.entryModule = undefined;\n            }\n          }\n\n          if (item.cacheGroup.filename) {\n            if (!newChunk.isOnlyInitial()) {\n              throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + `(cache group: ${item.cacheGroup.key})`);\n            }\n\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n\n          if (!isReused) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (typeof module.chunkCondition === \"function\") {\n                if (!module.chunkCondition(newChunk)) continue;\n              } // Add module to new chunk\n\n\n              GraphHelpers.connectChunkAndModule(newChunk, module); // Remove module from used chunks\n\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          }\n\n          if (item.cacheGroup.maxSize > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n              maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          } // remove all modules from other entries and update size\n\n\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              const oldSize = info.modules.size;\n\n              for (const module of item.modules) {\n                info.modules.delete(module);\n              }\n\n              if (info.modules.size !== oldSize) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n\n                info.size = getModulesSize(info.modules);\n\n                if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n                  chunksInfoMap.delete(key);\n                }\n\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                }\n              }\n            }\n          }\n        }\n\n        const incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n        for (const chunk of compilation.chunks.slice()) {\n          const {\n            minSize,\n            maxSize,\n            automaticNameDelimiter,\n            keys\n          } = maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n          if (!maxSize) continue;\n\n          if (minSize > maxSize) {\n            const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\n            if (!incorrectMinMaxSizeSet.has(warningKey)) {\n              incorrectMinMaxSizeSet.add(warningKey);\n              compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n            }\n          }\n\n          const results = deterministicGroupingForModules({\n            maxSize: Math.max(minSize, maxSize),\n            minSize,\n            items: chunk.modulesIterable,\n\n            getKey(module) {\n              const ident = contextify(compilation.options.context, module.identifier());\n              const name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident);\n              return fullKey.replace(/[\\\\/?]/g, \"_\");\n            },\n\n            getSize(module) {\n              return module.size();\n            }\n\n          });\n          results.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n            }\n\n            let newPart;\n\n            if (i !== results.length - 1) {\n              newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n              for (const module of group.items) {\n                if (typeof module.chunkCondition === \"function\") {\n                  if (!module.chunkCondition(newPart)) continue;\n                } // Add module to new chunk\n\n\n                GraphHelpers.connectChunkAndModule(newPart, module); // Remove module from used chunks\n\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newPart]);\n              }\n            } else {\n              // change the chunk to be a part\n              newPart = chunk;\n              chunk.name = name;\n            }\n          }\n        }\n      });\n    });\n  }\n\n};","map":{"version":3,"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","SplitChunksPlugin","constructor","options","normalizeOptions","chunksFilter","normalizeChunksFilter","minSize","enforceSizeThreshold","maxSize","minChunks","maxAsyncRequests","maxInitialRequests","hidePathInfo","filename","undefined","getCacheGroups","normalizeCacheGroups","cacheGroups","automaticNameDelimiter","automaticNameMaxLength","fallbackCacheGroup","normalizeFallbackCacheGroup","normalizeName","automaticNamePrefix","cache","WeakMap","fn","cacheEntry","get","set","names","map","c","every","Boolean","prefix","namePrefix","join","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","results","key","Object","keys","option","RegExp","test","result","r","Array","isArray","assign","getName","push","checkTest","enforce","reuseExistingChunk","nameForCondition","startsWith","chunksIterable","apply","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","getKey","from","chunkSetsInGraph","chunksKey","Set","chunkSetsByCount","chunksSet","values","count","array","combinationsCache","getCombinations","setArray","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","info","reuseableChunks","chunksKeys","add","combs","cacheGroupSource","minSizeForMaxSize","Infinity","_validateSize","_conditionalEnforce","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","filter","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","concat","oldSize","incorrectMinMaxSizeSet","warningKey","warnings","items","modulesIterable","ident","context","replace","fullKey","getSize","i","group","newPart"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tenforceSizeThreshold: options.enforceSizeThreshold || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tenforceSizeThreshold: option.enforceSizeThreshold,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {number} cacheGroupIndex\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst minSize =\n\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.minSize;\n\t\t\t\t\t\t\tconst enforceSizeThreshold =\n\t\t\t\t\t\t\t\tcacheGroupSource.enforceSizeThreshold !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.enforceSizeThreshold\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.enforceSizeThreshold;\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tenforceSizeThreshold,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n\t\t\t\t\t\t\t\t_validateSize: minSize > 0,\n\t\t\t\t\t\t\t\t_conditionalEnforce: enforceSizeThreshold > 0\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst selectedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\titem.size >= item.cacheGroup.enforceSizeThreshold;\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (selectedChunks.length === 0) continue;\n\n\t\t\t\t\t\tconst usedChunks = new Set(selectedChunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < selectedChunks.length) {\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}