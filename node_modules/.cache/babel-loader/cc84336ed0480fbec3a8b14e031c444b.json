{"ast":null,"code":"'use strict';\n\nvar use = require('use');\n\nvar util = require('util');\n\nvar Cache = require('map-cache');\n\nvar define = require('define-property');\n\nvar debug = require('debug')('snapdragon:parser');\n\nvar Position = require('./position');\n\nvar utils = require('./utils');\n/**\n * Create a new `Parser` with the given `input` and `options`.\n * @param {String} `input`\n * @param {Object} `options`\n * @api public\n */\n\n\nfunction Parser(options) {\n  debug('initializing', __filename);\n  this.options = utils.extend({\n    source: 'string'\n  }, options);\n  this.init(this.options);\n  use(this);\n}\n/**\n * Prototype methods\n */\n\n\nParser.prototype = {\n  constructor: Parser,\n  init: function (options) {\n    this.orig = '';\n    this.input = '';\n    this.parsed = '';\n    this.column = 1;\n    this.line = 1;\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = 'root';\n    var pos = this.position();\n    this.bos = pos({\n      type: 'bos',\n      val: ''\n    });\n    this.ast = {\n      type: 'root',\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n    define(this.bos, 'parent', this.ast);\n    this.nodes = [this.ast];\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n\n  /**\n   * Throw a formatted error with the cursor column and `msg`.\n   * @param {String} `msg` Message to use in the Error.\n   */\n  error: function (msg, node) {\n    var pos = node.position || {\n      start: {\n        column: 0,\n        line: 0\n      }\n    };\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Parser` instance.\n   *\n   * ```js\n   * parser.define('foo', 'bar');\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Parser instance for chaining.\n   * @api public\n   */\n  define: function (key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n  position: function () {\n    var start = {\n      line: this.line,\n      column: this.column\n    };\n    var self = this;\n    return function (node) {\n      define(node, 'position', new Position(start, self));\n      return node;\n    };\n  },\n\n  /**\n   * Set parser `name` with the given `fn`\n   * @param {String} `name`\n   * @param {Function} `fn`\n   * @api public\n   */\n  set: function (type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n\n  /**\n   * Get parser `name`\n   * @param {String} `name`\n   * @api public\n   */\n  get: function (name) {\n    return this.parsers[name];\n  },\n\n  /**\n   * Push a `token` onto the `type` stack.\n   *\n   * @param {String} `type`\n   * @return {Object} `token`\n   * @api public\n   */\n  push: function (type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n\n  /**\n   * Pop a token off of the `type` stack\n   * @param {String} `type`\n   * @returns {Object} Returns a token\n   * @api public\n   */\n  pop: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n\n  /**\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\n   *\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n  isInside: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length > 0;\n  },\n\n  /**\n   * Return true if `node` is the given `type`.\n   *\n   * ```js\n   * parser.isType(node, 'brace');\n   * ```\n   * @param {Object} `node`\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n  isType: function (node, type) {\n    return node && node.type === type;\n  },\n\n  /**\n   * Get the previous AST node\n   * @return {Object}\n   */\n  prev: function (n) {\n    return this.stack.length > 0 ? utils.last(this.stack, n) : utils.last(this.nodes, n);\n  },\n\n  /**\n   * Update line and column based on `str`.\n   */\n  consume: function (len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Update column based on `str`.\n   */\n  updatePosition: function (str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n\n  /**\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\n   * @param {RegExp} `regex`\n   * @return {Object}\n   */\n  match: function (regex) {\n    var m = regex.exec(this.input);\n\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n\n  /**\n   * Capture `type` with the given regex.\n   * @param {String} `type`\n   * @param {RegExp} `regex`\n   * @return {Function}\n   */\n  capture: function (type, regex) {\n    if (typeof regex === 'function') {\n      return this.set.apply(this, arguments);\n    }\n\n    this.regex.set(type, regex);\n    this.set(type, function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n\n      if (m[1]) {\n        node.inner = m[1];\n      }\n\n      define(node, 'inside', this.stack.length > 0);\n      define(node, 'parent', prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n\n  /**\n   * Create a parser with open and close for parens,\n   * brackets or braces\n   */\n  capturePair: function (type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n    /**\n     * Open\n     */\n\n    this.set(type + '.open', function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + '.open',\n        val: val,\n        rest: this.input\n      });\n\n      if (typeof m[1] !== 'undefined') {\n        open.inner = m[1];\n      }\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n      define(node, 'rest', this.input);\n      define(node, 'parsed', parsed);\n      define(node, 'prefix', m[1]);\n      define(node, 'parent', prev);\n      define(open, 'parent', node);\n\n      if (typeof fn === 'function') {\n        fn.call(this, open, node);\n      }\n\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n    /**\n     * Close\n     */\n\n    this.set(type + '.close', function () {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + '.close',\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"' + type + '\"');\n        }\n\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n\n      if (node.suffix === '\\\\') {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n\n      parent.nodes.push(node);\n      define(node, 'parent', parent);\n    });\n    return this;\n  },\n\n  /**\n   * Capture end-of-string\n   */\n  eos: function () {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n\n    while (prev.type !== 'root' && !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\n      }\n\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n\n      visit(prev, function (node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n      prev = prev.parent;\n    }\n\n    var tok = pos({\n      type: 'eos',\n      val: this.append || ''\n    });\n    define(tok, 'parent', this.ast);\n    return tok;\n  },\n\n  /**\n   * Run parsers to advance the cursor position\n   */\n  next: function () {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if (tok = this.parsers[this.types[idx]].call(this)) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Parse the given string.\n   * @return {Array}\n   */\n  parse: function (input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input; // get the next AST ndoe\n\n      var node = self.next();\n\n      if (node) {\n        var prev = self.prev();\n\n        if (prev) {\n          define(node, 'parent', prev);\n\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      } // if we got here but input is not changed, throw an error\n\n\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }\n};\n/**\n * Visit `node` with the given `fn`\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n\n  return node;\n}\n/**\n * Map visit over array of `nodes`.\n */\n\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    visit(nodes[idx], fn);\n  }\n}\n\nfunction hasOpen(node) {\n  return node.nodes && node.nodes[0].type === node.type + '.open';\n}\n\nfunction hasClose(node) {\n  return node.nodes && utils.last(node.nodes).type === node.type + '.close';\n}\n\nfunction hasDelims(node) {\n  return hasOpen(node) && hasClose(node);\n}\n/**\n * Expose `Parser`\n */\n\n\nmodule.exports = Parser;","map":{"version":3,"names":["use","require","util","Cache","define","debug","Position","utils","Parser","options","__filename","extend","source","init","prototype","constructor","orig","input","parsed","column","line","regex","errors","parsers","types","sets","fns","currentType","pos","position","bos","type","val","ast","nodes","count","setCount","stack","error","msg","node","start","message","err","Error","reason","silent","push","key","self","set","fn","indexOf","bind","get","name","token","pop","isInside","length","isType","prev","n","last","consume","len","substr","updatePosition","str","lines","match","i","lastIndexOf","m","exec","capture","apply","arguments","rest","inner","capturePair","openRegex","closeRegex","specialChars","open","call","parent","suffix","strict","escaped","eos","visited","SyntaxError","inspect","hasDelims","visit","tok","append","next","idx","parse","TypeError","hasOwnProperty","slice","mapVisit","hasOpen","hasClose","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/snapdragon/lib/parser.js"],"sourcesContent":["'use strict';\n\nvar use = require('use');\nvar util = require('util');\nvar Cache = require('map-cache');\nvar define = require('define-property');\nvar debug = require('debug')('snapdragon:parser');\nvar Position = require('./position');\nvar utils = require('./utils');\n\n/**\n * Create a new `Parser` with the given `input` and `options`.\n * @param {String} `input`\n * @param {Object} `options`\n * @api public\n */\n\nfunction Parser(options) {\n  debug('initializing', __filename);\n  this.options = utils.extend({source: 'string'}, options);\n  this.init(this.options);\n  use(this);\n}\n\n/**\n * Prototype methods\n */\n\nParser.prototype = {\n  constructor: Parser,\n\n  init: function(options) {\n    this.orig = '';\n    this.input = '';\n    this.parsed = '';\n\n    this.column = 1;\n    this.line = 1;\n\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = 'root';\n\n    var pos = this.position();\n    this.bos = pos({type: 'bos', val: ''});\n\n    this.ast = {\n      type: 'root',\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n\n    define(this.bos, 'parent', this.ast);\n    this.nodes = [this.ast];\n\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n\n  /**\n   * Throw a formatted error with the cursor column and `msg`.\n   * @param {String} `msg` Message to use in the Error.\n   */\n\n  error: function(msg, node) {\n    var pos = node.position || {start: {column: 0, line: 0}};\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Parser` instance.\n   *\n   * ```js\n   * parser.define('foo', 'bar');\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Parser instance for chaining.\n   * @api public\n   */\n\n  define: function(key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  position: function() {\n    var start = { line: this.line, column: this.column };\n    var self = this;\n\n    return function(node) {\n      define(node, 'position', new Position(start, self));\n      return node;\n    };\n  },\n\n  /**\n   * Set parser `name` with the given `fn`\n   * @param {String} `name`\n   * @param {Function} `fn`\n   * @api public\n   */\n\n  set: function(type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n\n  /**\n   * Get parser `name`\n   * @param {String} `name`\n   * @api public\n   */\n\n  get: function(name) {\n    return this.parsers[name];\n  },\n\n  /**\n   * Push a `token` onto the `type` stack.\n   *\n   * @param {String} `type`\n   * @return {Object} `token`\n   * @api public\n   */\n\n  push: function(type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n\n  /**\n   * Pop a token off of the `type` stack\n   * @param {String} `type`\n   * @returns {Object} Returns a token\n   * @api public\n   */\n\n  pop: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n\n  /**\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\n   *\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isInside: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length > 0;\n  },\n\n  /**\n   * Return true if `node` is the given `type`.\n   *\n   * ```js\n   * parser.isType(node, 'brace');\n   * ```\n   * @param {Object} `node`\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isType: function(node, type) {\n    return node && node.type === type;\n  },\n\n  /**\n   * Get the previous AST node\n   * @return {Object}\n   */\n\n  prev: function(n) {\n    return this.stack.length > 0\n      ? utils.last(this.stack, n)\n      : utils.last(this.nodes, n);\n  },\n\n  /**\n   * Update line and column based on `str`.\n   */\n\n  consume: function(len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Update column based on `str`.\n   */\n\n  updatePosition: function(str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n\n  /**\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\n   * @param {RegExp} `regex`\n   * @return {Object}\n   */\n\n  match: function(regex) {\n    var m = regex.exec(this.input);\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n\n  /**\n   * Capture `type` with the given regex.\n   * @param {String} `type`\n   * @param {RegExp} `regex`\n   * @return {Function}\n   */\n\n  capture: function(type, regex) {\n    if (typeof regex === 'function') {\n      return this.set.apply(this, arguments);\n    }\n\n    this.regex.set(type, regex);\n    this.set(type, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n\n      if (m[1]) {\n        node.inner = m[1];\n      }\n\n      define(node, 'inside', this.stack.length > 0);\n      define(node, 'parent', prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n\n  /**\n   * Create a parser with open and close for parens,\n   * brackets or braces\n   */\n\n  capturePair: function(type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n\n    /**\n     * Open\n     */\n\n    this.set(type + '.open', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + '.open',\n        val: val,\n        rest: this.input\n      });\n\n      if (typeof m[1] !== 'undefined') {\n        open.inner = m[1];\n      }\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n\n      define(node, 'rest', this.input);\n      define(node, 'parsed', parsed);\n      define(node, 'prefix', m[1]);\n      define(node, 'parent', prev);\n      define(open, 'parent', node);\n\n      if (typeof fn === 'function') {\n        fn.call(this, open, node);\n      }\n\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n\n    /**\n     * Close\n     */\n\n    this.set(type + '.close', function() {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + '.close',\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"' + type + '\"');\n        }\n\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n\n      if (node.suffix === '\\\\') {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n\n      parent.nodes.push(node);\n      define(node, 'parent', parent);\n    });\n\n    return this;\n  },\n\n  /**\n   * Capture end-of-string\n   */\n\n  eos: function() {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n\n    while (prev.type !== 'root' && !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\n      }\n\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n\n      visit(prev, function(node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n\n      prev = prev.parent;\n    }\n\n    var tok = pos({\n      type: 'eos',\n      val: this.append || ''\n    });\n\n    define(tok, 'parent', this.ast);\n    return tok;\n  },\n\n  /**\n   * Run parsers to advance the cursor position\n   */\n\n  next: function() {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Parse the given string.\n   * @return {Array}\n   */\n\n  parse: function(input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, 'parent', prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }\n};\n\n/**\n * Visit `node` with the given `fn`\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  return node;\n}\n\n/**\n * Map visit over array of `nodes`.\n */\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n  while (++idx < len) {\n    visit(nodes[idx], fn);\n  }\n}\n\nfunction hasOpen(node) {\n  return node.nodes && node.nodes[0].type === (node.type + '.open');\n}\n\nfunction hasClose(node) {\n  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');\n}\n\nfunction hasDelims(node) {\n  return hasOpen(node) && hasClose(node);\n}\n\n/**\n * Expose `Parser`\n */\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}