{"ast":null,"code":"\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\n\n\nconst getName = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let r = \"\";\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charAt(i);\n    const cb = b.charAt(i);\n    r += ca;\n\n    if (ca === cb) {\n      continue;\n    }\n\n    return r;\n  }\n\n  return a;\n};\n/**\n * @template T\n */\n\n\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {number} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   */\n  constructor(nodes, similarities) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = nodes.reduce((size, node) => size + node.size, 0);\n    /** @type {string} */\n\n    this.key = undefined;\n  }\n\n}\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = _ref => {\n  let {\n    maxSize,\n    minSize,\n    items,\n    getSize,\n    getKey\n  } = _ref;\n\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n  /** @type {Node<T>[]} */\n\n  const initialNodes = []; // lexically ordering of keys\n\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n\n  for (const node of nodes) {\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n\n    /** @type {number[]} */\n    const similarities = [];\n\n    for (let i = 1; i < initialNodes.length; i++) {\n      const a = initialNodes[i - 1];\n      const b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n\n    const initialGroup = new Group(initialNodes, similarities);\n\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        const smallestGroup = result.reduce((min, group) => min.size > group.size ? group : min);\n\n        for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\n        smallestGroup.nodes.sort((a, b) => {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      const queue = [initialGroup];\n\n      while (queue.length) {\n        const group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        let left = 0;\n        let leftSize = 0;\n\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n\n        let right = group.nodes.length - 1;\n        let rightSize = 0;\n\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          let best = left - 1;\n          let bestSimilarity = group.similarities[best];\n\n          for (let i = left; i <= right; i++) {\n            const similarity = group.similarities[i];\n\n            if (similarity < bestSimilarity) {\n              best = i;\n              bestSimilarity = similarity;\n            }\n          }\n\n          left = best + 1;\n          right = best;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        const rightSimilaries = [];\n\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilaries.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilaries));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        const leftSimilaries = [];\n\n        for (let i = 1; i < left; i++) {\n          leftSimilaries.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n    const first = group.nodes[0];\n    const last = group.nodes[group.nodes.length - 1];\n    let name = getName(first.key, last.key);\n    group.key = name;\n  } // return the results\n\n\n  return result.map(group => {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","r","charAt","Node","constructor","item","key","size","Group","nodes","similarities","reduce","node","undefined","module","exports","maxSize","minSize","items","getSize","getKey","result","Array","from","initialNodes","sort","push","initialGroup","smallestGroup","group","queue","pop","left","leftSize","right","rightSize","best","bestSimilarity","rightNodes","rightSimilaries","leftNodes","leftSimilaries","first","last","name","map"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet r = \"\";\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charAt(i);\n\t\tconst cb = b.charAt(i);\n\t\tr += ca;\n\t\tif (ca === cb) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r;\n\t}\n\treturn a;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {number} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t */\n\tconstructor(nodes, similarities) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = nodes.reduce((size, node) => size + node.size, 0);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\tfor (const node of nodes) {\n\t\tif (node.size >= maxSize) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\t// calculate similarities between lexically adjacent nodes\n\t\t/** @type {number[]} */\n\t\tconst similarities = [];\n\t\tfor (let i = 1; i < initialNodes.length; i++) {\n\t\t\tconst a = initialNodes[i - 1];\n\t\t\tconst b = initialNodes[i];\n\t\t\tsimilarities.push(similarity(a.key, b.key));\n\t\t}\n\n\t\tconst initialGroup = new Group(initialNodes, similarities);\n\n\t\tif (initialGroup.size < minSize) {\n\t\t\t// We hit an edgecase where the working set is already smaller than minSize\n\t\t\t// We merge it with the smallest result node to keep minSize intact\n\t\t\tif (result.length > 0) {\n\t\t\t\tconst smallestGroup = result.reduce((min, group) =>\n\t\t\t\t\tmin.size > group.size ? group : min\n\t\t\t\t);\n\t\t\t\tfor (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\t\t\t\tsmallestGroup.nodes.sort((a, b) => {\n\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// There are no other nodes\n\t\t\t\t// We use all nodes and have to accept that it's smaller than minSize\n\t\t\t\tresult.push(initialGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (group.size < maxSize) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 0;\n\t\t\t\tlet leftSize = 0;\n\t\t\t\twhile (leftSize <= minSize) {\n\t\t\t\t\tleftSize += group.nodes[left].size;\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 1;\n\t\t\t\tlet rightSize = 0;\n\t\t\t\twhile (rightSize <= minSize) {\n\t\t\t\t\trightSize += group.nodes[right].size;\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the group here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\tlet best = left - 1;\n\t\t\t\t\tlet bestSimilarity = group.similarities[best];\n\t\t\t\t\tfor (let i = left; i <= right; i++) {\n\t\t\t\t\t\tconst similarity = group.similarities[i];\n\t\t\t\t\t\tif (similarity < bestSimilarity) {\n\t\t\t\t\t\t\tbest = i;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft = best + 1;\n\t\t\t\t\tright = best;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilaries = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilaries));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilaries = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilaries));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tconst first = group.nodes[0];\n\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\tlet name = getName(first.key, last.key);\n\t\tgroup.key = name;\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}