{"ast":null,"code":"'use strict';\n\nvar Node = require('snapdragon-node');\n\nvar utils = require('./utils');\n/**\n * Braces parsers\n */\n\n\nmodule.exports = function (braces, options) {\n  braces.parser.set('bos', function () {\n    if (!this.parsed) {\n      this.ast = this.nodes[0] = new Node(this.ast);\n    }\n  })\n  /**\n   * Character parsers\n   */\n  .set('escape', function () {\n    var pos = this.position();\n    var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: m[0]\n    }));\n\n    if (node.val === '\\\\\\\\') {\n      return node;\n    }\n\n    if (node.val === '${') {\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n        node.val += ch;\n\n        if (ch === '\\\\') {\n          node.val += str[++idx];\n          continue;\n        }\n\n        if (ch === '}') {\n          break;\n        }\n      }\n    }\n\n    if (this.options.unescape !== false) {\n      node.val = node.val.replace(/\\\\([{}])/g, '$1');\n    }\n\n    if (last.val === '\"' && this.input.charAt(0) === '\"') {\n      last.val = node.val;\n      this.consume(1);\n      return;\n    }\n\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Brackets: \"[...]\" (basic, this is overridden by\n   * other parsers in more advanced implementations)\n   */\n  .set('bracket', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n    var negated = m[1] ? '^' : '';\n    var inner = m[2] || '';\n    var close = m[3] || '';\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var esc = this.input.slice(0, 2);\n\n    if (inner === '' && esc === '\\\\]') {\n      inner += esc;\n      this.consume(2);\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n\n        if (ch === ']') {\n          close = ch;\n          break;\n        }\n\n        inner += ch;\n      }\n    }\n\n    return pos(new Node({\n      type: 'bracket',\n      val: val,\n      escaped: close !== ']',\n      negated: negated,\n      inner: inner,\n      close: close\n    }));\n  })\n  /**\n   * Empty braces (we capture these early to\n   * speed up processing in the compiler)\n   */\n  .set('multiplier', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n    if (!m) return;\n    this.multiplier = true;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      match: m,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Open\n   */\n  .set('brace.open', function () {\n    var pos = this.position();\n    var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes); // if the last parsed character was an extglob character\n    // we need to _not optimize_ the brace pattern because\n    // it might be mistaken for an extglob by a downstream parser\n\n    if (last && last.val && isExtglobChar(last.val.slice(-1))) {\n      last.optimize = false;\n    }\n\n    var open = pos(new Node({\n      type: 'brace.open',\n      val: m[0]\n    }));\n    var node = pos(new Node({\n      type: 'brace',\n      nodes: []\n    }));\n    node.push(open);\n    prev.push(node);\n    this.push('brace', node);\n  })\n  /**\n   * Close\n   */\n  .set('brace.close', function () {\n    var pos = this.position();\n    var m = this.match(/^\\}/);\n    if (!m || !m[0]) return;\n    var brace = this.pop('brace');\n    var node = pos(new Node({\n      type: 'brace.close',\n      val: m[0]\n    }));\n\n    if (!this.isType(brace, 'brace')) {\n      if (this.options.strict) {\n        throw new Error('missing opening \"{\"');\n      }\n\n      node.type = 'text';\n      node.multiplier = 0;\n      node.escaped = true;\n      return node;\n    }\n\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n\n    if (last.text) {\n      var lastNode = utils.last(last.nodes);\n\n      if (lastNode.val === ')' && /[!@*?+]\\(/.test(last.text)) {\n        var open = last.nodes[0];\n        var text = last.nodes[1];\n\n        if (open.type === 'brace.open' && text && text.type === 'text') {\n          text.optimize = false;\n        }\n      }\n    }\n\n    if (brace.nodes.length > 2) {\n      var first = brace.nodes[1];\n\n      if (first.type === 'text' && first.val === ',') {\n        brace.nodes.splice(1, 1);\n        brace.nodes.push(first);\n      }\n    }\n\n    brace.push(node);\n  })\n  /**\n   * Capture boundary characters\n   */\n  .set('boundary', function () {\n    var pos = this.position();\n    var m = this.match(/^[$^](?!\\{)/);\n    if (!m) return;\n    return pos(new Node({\n      type: 'text',\n      val: m[0]\n    }));\n  })\n  /**\n   * One or zero, non-comma characters wrapped in braces\n   */\n  .set('nobrace', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{[^,]?\\}/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    return pos(new Node({\n      type: 'text',\n      multiplier: 0,\n      val: val\n    }));\n  })\n  /**\n   * Text\n   */\n  .set('text', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  });\n};\n/**\n * Returns true if the character is an extglob character.\n */\n\n\nfunction isExtglobChar(ch) {\n  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';\n}\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length > 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n    isEscaped = a === '\"' && b === '\"' || a === \"'\" && b === \"'\" || a === '`' && b === '`';\n  }\n\n  if (isEscaped && options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n\n    if (!match || match.indexOf('}') === -1) {\n      match = node.match[0];\n    } // replace each set with a single \",\"\n\n\n    var val = match.replace(/\\{/g, ',').replace(/\\}/g, '');\n    node.multiplier *= val.length;\n    node.val = '';\n  }\n\n  var simpleText = last.type === 'text' && last.multiplier === 1 && node.multiplier === 1 && node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}","map":{"version":3,"names":["Node","require","utils","module","exports","braces","options","parser","set","parsed","ast","nodes","pos","position","m","match","prev","last","node","type","multiplier","val","str","input","idx","ch","consume","unescape","replace","charAt","concatNodes","call","isInside","negated","inner","close","text","esc","slice","escaped","isExtglobChar","optimize","open","push","brace","pop","isType","strict","Error","lastNode","test","length","first","splice","parent","orig","isEscaped","a","b","indexOf","simpleText"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/node_modules/braces/lib/parsers.js"],"sourcesContent":["'use strict';\n\nvar Node = require('snapdragon-node');\nvar utils = require('./utils');\n\n/**\n * Braces parsers\n */\n\nmodule.exports = function(braces, options) {\n  braces.parser\n    .set('bos', function() {\n      if (!this.parsed) {\n        this.ast = this.nodes[0] = new Node(this.ast);\n      }\n    })\n\n    /**\n     * Character parsers\n     */\n\n    .set('escape', function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        val: m[0]\n      }));\n\n      if (node.val === '\\\\\\\\') {\n        return node;\n      }\n\n      if (node.val === '${') {\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          node.val += ch;\n          if (ch === '\\\\') {\n            node.val += str[++idx];\n            continue;\n          }\n          if (ch === '}') {\n            break;\n          }\n        }\n      }\n\n      if (this.options.unescape !== false) {\n        node.val = node.val.replace(/\\\\([{}])/g, '$1');\n      }\n\n      if (last.val === '\"' && this.input.charAt(0) === '\"') {\n        last.val = node.val;\n        this.consume(1);\n        return;\n      }\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Brackets: \"[...]\" (basic, this is overridden by\n     * other parsers in more advanced implementations)\n     */\n\n    .set('bracket', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n      var negated = m[1] ? '^' : '';\n      var inner = m[2] || '';\n      var close = m[3] || '';\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === '' && esc === '\\\\]') {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === ']') {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos(new Node({\n        type: 'bracket',\n        val: val,\n        escaped: close !== ']',\n        negated: negated,\n        inner: inner,\n        close: close\n      }));\n    })\n\n    /**\n     * Empty braces (we capture these early to\n     * speed up processing in the compiler)\n     */\n\n    .set('multiplier', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n      if (!m) return;\n\n      this.multiplier = true;\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        match: m,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Open\n     */\n\n    .set('brace.open', function() {\n      var pos = this.position();\n      var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      // if the last parsed character was an extglob character\n      // we need to _not optimize_ the brace pattern because\n      // it might be mistaken for an extglob by a downstream parser\n      if (last && last.val && isExtglobChar(last.val.slice(-1))) {\n        last.optimize = false;\n      }\n\n      var open = pos(new Node({\n        type: 'brace.open',\n        val: m[0]\n      }));\n\n      var node = pos(new Node({\n        type: 'brace',\n        nodes: []\n      }));\n\n      node.push(open);\n      prev.push(node);\n      this.push('brace', node);\n    })\n\n    /**\n     * Close\n     */\n\n    .set('brace.close', function() {\n      var pos = this.position();\n      var m = this.match(/^\\}/);\n      if (!m || !m[0]) return;\n\n      var brace = this.pop('brace');\n      var node = pos(new Node({\n        type: 'brace.close',\n        val: m[0]\n      }));\n\n      if (!this.isType(brace, 'brace')) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"{\"');\n        }\n        node.type = 'text';\n        node.multiplier = 0;\n        node.escaped = true;\n        return node;\n      }\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n      if (last.text) {\n        var lastNode = utils.last(last.nodes);\n        if (lastNode.val === ')' && /[!@*?+]\\(/.test(last.text)) {\n          var open = last.nodes[0];\n          var text = last.nodes[1];\n          if (open.type === 'brace.open' && text && text.type === 'text') {\n            text.optimize = false;\n          }\n        }\n      }\n\n      if (brace.nodes.length > 2) {\n        var first = brace.nodes[1];\n        if (first.type === 'text' && first.val === ',') {\n          brace.nodes.splice(1, 1);\n          brace.nodes.push(first);\n        }\n      }\n\n      brace.push(node);\n    })\n\n    /**\n     * Capture boundary characters\n     */\n\n    .set('boundary', function() {\n      var pos = this.position();\n      var m = this.match(/^[$^](?!\\{)/);\n      if (!m) return;\n      return pos(new Node({\n        type: 'text',\n        val: m[0]\n      }));\n    })\n\n    /**\n     * One or zero, non-comma characters wrapped in braces\n     */\n\n    .set('nobrace', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^\\{[^,]?\\}/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      return pos(new Node({\n        type: 'text',\n        multiplier: 0,\n        val: val\n      }));\n    })\n\n    /**\n     * Text\n     */\n\n    .set('text', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    });\n};\n\n/**\n * Returns true if the character is an extglob character.\n */\n\nfunction isExtglobChar(ch) {\n  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';\n}\n\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length > 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n\n    isEscaped = (a === '\"' && b === '\"')\n      || (a === \"'\" && b === \"'\")\n      || (a === '`' && b === '`');\n  }\n\n  if (isEscaped && options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n    if (!match || match.indexOf('}') === -1) {\n      match = node.match[0];\n    }\n\n    // replace each set with a single \",\"\n    var val = match.replace(/\\{/g, ',').replace(/\\}/g, '');\n    node.multiplier *= val.length;\n    node.val = '';\n  }\n\n  var simpleText = last.type === 'text'\n    && last.multiplier === 1\n    && node.multiplier === 1\n    && node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}\n"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,iBAAD,CAAlB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;AAEA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,UAASC,MAAT,EAAiBC,OAAjB,EAA0B;EACzCD,MAAM,CAACE,MAAP,CACGC,GADH,CACO,KADP,EACc,YAAW;IACrB,IAAI,CAAC,KAAKC,MAAV,EAAkB;MAChB,KAAKC,GAAL,GAAW,KAAKC,KAAL,CAAW,CAAX,IAAgB,IAAIX,IAAJ,CAAS,KAAKU,GAAd,CAA3B;IACD;EACF,CALH;EAOE;AACJ;AACA;EATE,CAWGF,GAXH,CAWO,QAXP,EAWiB,YAAW;IACxB,IAAII,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,iBAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,IAAIE,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIC,IAAI,GAAGf,KAAK,CAACe,IAAN,CAAWD,IAAI,CAACL,KAAhB,CAAX;IAEA,IAAIO,IAAI,GAAGN,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,MADgB;MAEtBC,UAAU,EAAE,CAFU;MAGtBC,GAAG,EAAEP,CAAC,CAAC,CAAD;IAHgB,CAAT,CAAD,CAAd;;IAMA,IAAII,IAAI,CAACG,GAAL,KAAa,MAAjB,EAAyB;MACvB,OAAOH,IAAP;IACD;;IAED,IAAIA,IAAI,CAACG,GAAL,KAAa,IAAjB,EAAuB;MACrB,IAAIC,GAAG,GAAG,KAAKC,KAAf;MACA,IAAIC,GAAG,GAAG,CAAC,CAAX;MACA,IAAIC,EAAJ;;MAEA,OAAQA,EAAE,GAAGH,GAAG,CAAC,EAAEE,GAAH,CAAhB,EAA0B;QACxB,KAAKE,OAAL,CAAa,CAAb;QACAR,IAAI,CAACG,GAAL,IAAYI,EAAZ;;QACA,IAAIA,EAAE,KAAK,IAAX,EAAiB;UACfP,IAAI,CAACG,GAAL,IAAYC,GAAG,CAAC,EAAEE,GAAH,CAAf;UACA;QACD;;QACD,IAAIC,EAAE,KAAK,GAAX,EAAgB;UACd;QACD;MACF;IACF;;IAED,IAAI,KAAKnB,OAAL,CAAaqB,QAAb,KAA0B,KAA9B,EAAqC;MACnCT,IAAI,CAACG,GAAL,GAAWH,IAAI,CAACG,GAAL,CAASO,OAAT,CAAiB,WAAjB,EAA8B,IAA9B,CAAX;IACD;;IAED,IAAIX,IAAI,CAACI,GAAL,KAAa,GAAb,IAAoB,KAAKE,KAAL,CAAWM,MAAX,CAAkB,CAAlB,MAAyB,GAAjD,EAAsD;MACpDZ,IAAI,CAACI,GAAL,GAAWH,IAAI,CAACG,GAAhB;MACA,KAAKK,OAAL,CAAa,CAAb;MACA;IACD;;IAED,OAAOI,WAAW,CAACC,IAAZ,CAAiB,IAAjB,EAAuBnB,GAAvB,EAA4BM,IAA5B,EAAkCF,IAAlC,EAAwCV,OAAxC,CAAP;EACD,CA1DH;EA4DE;AACJ;AACA;AACA;EA/DE,CAiEGE,GAjEH,CAiEO,SAjEP,EAiEkB,YAAW;IACzB,IAAIwB,QAAQ,GAAG,KAAKA,QAAL,CAAc,OAAd,CAAf;IACA,IAAIpB,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,8CAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,IAAIE,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIK,GAAG,GAAGP,CAAC,CAAC,CAAD,CAAX;IACA,IAAImB,OAAO,GAAGnB,CAAC,CAAC,CAAD,CAAD,GAAO,GAAP,GAAa,EAA3B;IACA,IAAIoB,KAAK,GAAGpB,CAAC,CAAC,CAAD,CAAD,IAAQ,EAApB;IACA,IAAIqB,KAAK,GAAGrB,CAAC,CAAC,CAAD,CAAD,IAAQ,EAApB;;IAEA,IAAIkB,QAAQ,IAAIhB,IAAI,CAACG,IAAL,KAAc,OAA9B,EAAuC;MACrCH,IAAI,CAACoB,IAAL,GAAYpB,IAAI,CAACoB,IAAL,IAAa,EAAzB;MACApB,IAAI,CAACoB,IAAL,IAAaf,GAAb;IACD;;IAED,IAAIgB,GAAG,GAAG,KAAKd,KAAL,CAAWe,KAAX,CAAiB,CAAjB,EAAoB,CAApB,CAAV;;IACA,IAAIJ,KAAK,KAAK,EAAV,IAAgBG,GAAG,KAAK,KAA5B,EAAmC;MACjCH,KAAK,IAAIG,GAAT;MACA,KAAKX,OAAL,CAAa,CAAb;MAEA,IAAIJ,GAAG,GAAG,KAAKC,KAAf;MACA,IAAIC,GAAG,GAAG,CAAC,CAAX;MACA,IAAIC,EAAJ;;MAEA,OAAQA,EAAE,GAAGH,GAAG,CAAC,EAAEE,GAAH,CAAhB,EAA0B;QACxB,KAAKE,OAAL,CAAa,CAAb;;QACA,IAAID,EAAE,KAAK,GAAX,EAAgB;UACdU,KAAK,GAAGV,EAAR;UACA;QACD;;QACDS,KAAK,IAAIT,EAAT;MACD;IACF;;IAED,OAAOb,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MAClBmB,IAAI,EAAE,SADY;MAElBE,GAAG,EAAEA,GAFa;MAGlBkB,OAAO,EAAEJ,KAAK,KAAK,GAHD;MAIlBF,OAAO,EAAEA,OAJS;MAKlBC,KAAK,EAAEA,KALW;MAMlBC,KAAK,EAAEA;IANW,CAAT,CAAD,CAAV;EAQD,CA7GH;EA+GE;AACJ;AACA;AACA;EAlHE,CAoHG3B,GApHH,CAoHO,YApHP,EAoHqB,YAAW;IAC5B,IAAIwB,QAAQ,GAAG,KAAKA,QAAL,CAAc,OAAd,CAAf;IACA,IAAIpB,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,sBAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,KAAKM,UAAL,GAAkB,IAAlB;IACA,IAAIJ,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIK,GAAG,GAAGP,CAAC,CAAC,CAAD,CAAX;;IAEA,IAAIkB,QAAQ,IAAIhB,IAAI,CAACG,IAAL,KAAc,OAA9B,EAAuC;MACrCH,IAAI,CAACoB,IAAL,GAAYpB,IAAI,CAACoB,IAAL,IAAa,EAAzB;MACApB,IAAI,CAACoB,IAAL,IAAaf,GAAb;IACD;;IAED,IAAIH,IAAI,GAAGN,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,MADgB;MAEtBC,UAAU,EAAE,CAFU;MAGtBL,KAAK,EAAED,CAHe;MAItBO,GAAG,EAAEA;IAJiB,CAAT,CAAD,CAAd;IAOA,OAAOS,WAAW,CAACC,IAAZ,CAAiB,IAAjB,EAAuBnB,GAAvB,EAA4BM,IAA5B,EAAkCF,IAAlC,EAAwCV,OAAxC,CAAP;EACD,CA3IH;EA6IE;AACJ;AACA;EA/IE,CAiJGE,GAjJH,CAiJO,YAjJP,EAiJqB,YAAW;IAC5B,IAAII,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,yBAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,IAAIE,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIC,IAAI,GAAGf,KAAK,CAACe,IAAN,CAAWD,IAAI,CAACL,KAAhB,CAAX,CAN4B,CAQ5B;IACA;IACA;;IACA,IAAIM,IAAI,IAAIA,IAAI,CAACI,GAAb,IAAoBmB,aAAa,CAACvB,IAAI,CAACI,GAAL,CAASiB,KAAT,CAAe,CAAC,CAAhB,CAAD,CAArC,EAA2D;MACzDrB,IAAI,CAACwB,QAAL,GAAgB,KAAhB;IACD;;IAED,IAAIC,IAAI,GAAG9B,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,YADgB;MAEtBE,GAAG,EAAEP,CAAC,CAAC,CAAD;IAFgB,CAAT,CAAD,CAAd;IAKA,IAAII,IAAI,GAAGN,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,OADgB;MAEtBR,KAAK,EAAE;IAFe,CAAT,CAAD,CAAd;IAKAO,IAAI,CAACyB,IAAL,CAAUD,IAAV;IACA1B,IAAI,CAAC2B,IAAL,CAAUzB,IAAV;IACA,KAAKyB,IAAL,CAAU,OAAV,EAAmBzB,IAAnB;EACD,CA7KH;EA+KE;AACJ;AACA;EAjLE,CAmLGV,GAnLH,CAmLO,aAnLP,EAmLsB,YAAW;IAC7B,IAAII,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,KAAX,CAAR;IACA,IAAI,CAACD,CAAD,IAAM,CAACA,CAAC,CAAC,CAAD,CAAZ,EAAiB;IAEjB,IAAI8B,KAAK,GAAG,KAAKC,GAAL,CAAS,OAAT,CAAZ;IACA,IAAI3B,IAAI,GAAGN,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,aADgB;MAEtBE,GAAG,EAAEP,CAAC,CAAC,CAAD;IAFgB,CAAT,CAAD,CAAd;;IAKA,IAAI,CAAC,KAAKgC,MAAL,CAAYF,KAAZ,EAAmB,OAAnB,CAAL,EAAkC;MAChC,IAAI,KAAKtC,OAAL,CAAayC,MAAjB,EAAyB;QACvB,MAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;MACD;;MACD9B,IAAI,CAACC,IAAL,GAAY,MAAZ;MACAD,IAAI,CAACE,UAAL,GAAkB,CAAlB;MACAF,IAAI,CAACqB,OAAL,GAAe,IAAf;MACA,OAAOrB,IAAP;IACD;;IAED,IAAIF,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIC,IAAI,GAAGf,KAAK,CAACe,IAAN,CAAWD,IAAI,CAACL,KAAhB,CAAX;;IACA,IAAIM,IAAI,CAACmB,IAAT,EAAe;MACb,IAAIa,QAAQ,GAAG/C,KAAK,CAACe,IAAN,CAAWA,IAAI,CAACN,KAAhB,CAAf;;MACA,IAAIsC,QAAQ,CAAC5B,GAAT,KAAiB,GAAjB,IAAwB,YAAY6B,IAAZ,CAAiBjC,IAAI,CAACmB,IAAtB,CAA5B,EAAyD;QACvD,IAAIM,IAAI,GAAGzB,IAAI,CAACN,KAAL,CAAW,CAAX,CAAX;QACA,IAAIyB,IAAI,GAAGnB,IAAI,CAACN,KAAL,CAAW,CAAX,CAAX;;QACA,IAAI+B,IAAI,CAACvB,IAAL,KAAc,YAAd,IAA8BiB,IAA9B,IAAsCA,IAAI,CAACjB,IAAL,KAAc,MAAxD,EAAgE;UAC9DiB,IAAI,CAACK,QAAL,GAAgB,KAAhB;QACD;MACF;IACF;;IAED,IAAIG,KAAK,CAACjC,KAAN,CAAYwC,MAAZ,GAAqB,CAAzB,EAA4B;MAC1B,IAAIC,KAAK,GAAGR,KAAK,CAACjC,KAAN,CAAY,CAAZ,CAAZ;;MACA,IAAIyC,KAAK,CAACjC,IAAN,KAAe,MAAf,IAAyBiC,KAAK,CAAC/B,GAAN,KAAc,GAA3C,EAAgD;QAC9CuB,KAAK,CAACjC,KAAN,CAAY0C,MAAZ,CAAmB,CAAnB,EAAsB,CAAtB;QACAT,KAAK,CAACjC,KAAN,CAAYgC,IAAZ,CAAiBS,KAAjB;MACD;IACF;;IAEDR,KAAK,CAACD,IAAN,CAAWzB,IAAX;EACD,CA9NH;EAgOE;AACJ;AACA;EAlOE,CAoOGV,GApOH,CAoOO,UApOP,EAoOmB,YAAW;IAC1B,IAAII,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,aAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IACR,OAAOF,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MAClBmB,IAAI,EAAE,MADY;MAElBE,GAAG,EAAEP,CAAC,CAAC,CAAD;IAFY,CAAT,CAAD,CAAV;EAID,CA5OH;EA8OE;AACJ;AACA;EAhPE,CAkPGN,GAlPH,CAkPO,SAlPP,EAkPkB,YAAW;IACzB,IAAIwB,QAAQ,GAAG,KAAKA,QAAL,CAAc,OAAd,CAAf;IACA,IAAIpB,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,YAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,IAAIE,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIK,GAAG,GAAGP,CAAC,CAAC,CAAD,CAAX;;IAEA,IAAIkB,QAAQ,IAAIhB,IAAI,CAACG,IAAL,KAAc,OAA9B,EAAuC;MACrCH,IAAI,CAACoB,IAAL,GAAYpB,IAAI,CAACoB,IAAL,IAAa,EAAzB;MACApB,IAAI,CAACoB,IAAL,IAAaf,GAAb;IACD;;IAED,OAAOT,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MAClBmB,IAAI,EAAE,MADY;MAElBC,UAAU,EAAE,CAFM;MAGlBC,GAAG,EAAEA;IAHa,CAAT,CAAD,CAAV;EAKD,CArQH;EAuQE;AACJ;AACA;EAzQE,CA2QGb,GA3QH,CA2QO,MA3QP,EA2Qe,YAAW;IACtB,IAAIwB,QAAQ,GAAG,KAAKA,QAAL,CAAc,OAAd,CAAf;IACA,IAAIpB,GAAG,GAAG,KAAKC,QAAL,EAAV;IACA,IAAIC,CAAC,GAAG,KAAKC,KAAL,CAAW,qBAAX,CAAR;IACA,IAAI,CAACD,CAAL,EAAQ;IAER,IAAIE,IAAI,GAAG,KAAKA,IAAL,EAAX;IACA,IAAIK,GAAG,GAAGP,CAAC,CAAC,CAAD,CAAX;;IAEA,IAAIkB,QAAQ,IAAIhB,IAAI,CAACG,IAAL,KAAc,OAA9B,EAAuC;MACrCH,IAAI,CAACoB,IAAL,GAAYpB,IAAI,CAACoB,IAAL,IAAa,EAAzB;MACApB,IAAI,CAACoB,IAAL,IAAaf,GAAb;IACD;;IAED,IAAIH,IAAI,GAAGN,GAAG,CAAC,IAAIZ,IAAJ,CAAS;MACtBmB,IAAI,EAAE,MADgB;MAEtBC,UAAU,EAAE,CAFU;MAGtBC,GAAG,EAAEA;IAHiB,CAAT,CAAD,CAAd;IAMA,OAAOS,WAAW,CAACC,IAAZ,CAAiB,IAAjB,EAAuBnB,GAAvB,EAA4BM,IAA5B,EAAkCF,IAAlC,EAAwCV,OAAxC,CAAP;EACD,CAhSH;AAiSD,CAlSD;AAoSA;AACA;AACA;;;AAEA,SAASkC,aAAT,CAAuBf,EAAvB,EAA2B;EACzB,OAAOA,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAArB,IAA4BA,EAAE,KAAK,GAAnC,IAA0CA,EAAE,KAAK,GAAjD,IAAwDA,EAAE,KAAK,GAAtE;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASK,WAAT,CAAqBlB,GAArB,EAA0BM,IAA1B,EAAgCoC,MAAhC,EAAwChD,OAAxC,EAAiD;EAC/CY,IAAI,CAACqC,IAAL,GAAYrC,IAAI,CAACG,GAAjB;EACA,IAAIL,IAAI,GAAG,KAAKA,IAAL,EAAX;EACA,IAAIC,IAAI,GAAGf,KAAK,CAACe,IAAN,CAAWD,IAAI,CAACL,KAAhB,CAAX;EACA,IAAI6C,SAAS,GAAG,KAAhB;;EAEA,IAAItC,IAAI,CAACG,GAAL,CAAS8B,MAAT,GAAkB,CAAtB,EAAyB;IACvB,IAAIM,CAAC,GAAGvC,IAAI,CAACG,GAAL,CAASQ,MAAT,CAAgB,CAAhB,CAAR;IACA,IAAI6B,CAAC,GAAGxC,IAAI,CAACG,GAAL,CAASiB,KAAT,CAAe,CAAC,CAAhB,CAAR;IAEAkB,SAAS,GAAIC,CAAC,KAAK,GAAN,IAAaC,CAAC,KAAK,GAApB,IACND,CAAC,KAAK,GAAN,IAAaC,CAAC,KAAK,GADb,IAEND,CAAC,KAAK,GAAN,IAAaC,CAAC,KAAK,GAFzB;EAGD;;EAED,IAAIF,SAAS,IAAIlD,OAAO,CAACqB,QAAR,KAAqB,KAAtC,EAA6C;IAC3CT,IAAI,CAACG,GAAL,GAAWH,IAAI,CAACG,GAAL,CAASiB,KAAT,CAAe,CAAf,EAAkBpB,IAAI,CAACG,GAAL,CAAS8B,MAAT,GAAkB,CAApC,CAAX;IACAjC,IAAI,CAACqB,OAAL,GAAe,IAAf;EACD;;EAED,IAAIrB,IAAI,CAACH,KAAT,EAAgB;IACd,IAAIA,KAAK,GAAGG,IAAI,CAACH,KAAL,CAAW,CAAX,CAAZ;;IACA,IAAI,CAACA,KAAD,IAAUA,KAAK,CAAC4C,OAAN,CAAc,GAAd,MAAuB,CAAC,CAAtC,EAAyC;MACvC5C,KAAK,GAAGG,IAAI,CAACH,KAAL,CAAW,CAAX,CAAR;IACD,CAJa,CAMd;;;IACA,IAAIM,GAAG,GAAGN,KAAK,CAACa,OAAN,CAAc,KAAd,EAAqB,GAArB,EAA0BA,OAA1B,CAAkC,KAAlC,EAAyC,EAAzC,CAAV;IACAV,IAAI,CAACE,UAAL,IAAmBC,GAAG,CAAC8B,MAAvB;IACAjC,IAAI,CAACG,GAAL,GAAW,EAAX;EACD;;EAED,IAAIuC,UAAU,GAAG3C,IAAI,CAACE,IAAL,KAAc,MAAd,IACZF,IAAI,CAACG,UAAL,KAAoB,CADR,IAEZF,IAAI,CAACE,UAAL,KAAoB,CAFR,IAGZF,IAAI,CAACG,GAHV;;EAKA,IAAIuC,UAAJ,EAAgB;IACd3C,IAAI,CAACI,GAAL,IAAYH,IAAI,CAACG,GAAjB;IACA;EACD;;EAEDL,IAAI,CAAC2B,IAAL,CAAUzB,IAAV;AACD"},"metadata":{},"sourceType":"script"}