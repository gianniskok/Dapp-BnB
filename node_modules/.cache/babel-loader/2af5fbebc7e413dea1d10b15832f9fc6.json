{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\n\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\n\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokens.comment) {\n        eatToken();\n\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n\n      eatTokenOfType(tokens.openParen);\n      var offset;\n\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              consequent.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              alternate.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          testInstrs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokens.closeParen && ( // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n            // $FlowIgnore\n            args.push(parseFuncInstr());\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          fnBody.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n\n        eatToken();\n        return t.start(_index2);\n      }\n\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return t.program(body);\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","codeFrameFromSource","t","parse32I","parseString","tokens","keywords","hasPlugin","name","Error","isKeyword","token","id","type","keyword","value","tokenToString","concat","identifierFromToken","_token$loc","loc","end","start","withLoc","identifier","parse","tokensList","source","current","getUniqueName","getUniqueNameGenerator","state","registredExportedElements","walk","eatToken","getEndLoc","currentToken","lastToken","getStartLoc","eatTokenOfType","parseExportIndex","index","number","_index","numberLiteralFromRaw","lookaheadAndCheck","len","arguments","tokenAhead","expectedToken","undefined","maybeIgnoreComment","comment","parseMemory","limits","limit","string","withRaw","openParen","data","stringInitializer","closeParen","export","_name","push","exportType","max","memory","parseData","memidx","offset","valtype","dot","numberLiteral","objectInstruction","_numberLiteral","instruction","byteArray","memIndexLiteral","parseTable","elemIndices","elemType","elem","exportName","anyfunc","min","parseInt","table","parseImport","moduleName","descr","func","fnParams","fnResult","typeRef","fnName","parseTypeReference","param","apply","parseFuncParam","result","parseFuncResult","funcImportDescr","signature","global","globalType","_valtype","moduleImport","parseBlock","label","blockResult","instr","parseFuncInstr","blockInstruction","parseIf","testInstrs","consequent","alternate","then","else","ifInstruction","parseLoop","loopInstruction","parseCallIndirect","params","results","instrs","callIndirectInstruction","parseExport","moduleExportDescr","parseModuleExportDescr","moduleExport","startLoc","node","endLoc","parseModule","isBinary","isQuote","moduleFields","blob","binaryModule","quoteModule","forEach","decl","module","parseFuncInstrArguments","args","namedArgs","signaturePtr","key","equal","signatureLength","vector","Infinity","valtypeLiteral","stringLiteral","_name2","object","TypeError","_endLoc","signatureForOpcode","_parseFuncInstrArgume","_args","_namedArgs","loop","block","call_indirect","call","indexLiteral","instrArgs","callInstruction","if","parseFunc","fnBody","parseFuncExport","funcId","parseType","typeInstruction","ref","parseGlobal","importing","import","_name3","mut","init","parseElem","tableIndex","funcs","parseStart","_index2","_endLoc2","_node","_endLoc3","_node2","_endLoc4","_node3","_endLoc5","_node4","_endLoc6","_node5","_endLoc7","_node6","_endLoc8","_node7","_endLoc9","_node8","_endLoc10","_node9","_endLoc11","_node10","_endLoc12","_node11","_endLoc13","_node12","_endLoc14","_startLoc","builder","opts","leadingComment","blockComment","_node13","_endLoc15","body","program"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/@webassemblyjs/wast-parser/esm/grammar.js"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\n\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\n\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokens.comment) {\n        eatToken();\n\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n\n      eatTokenOfType(tokens.openParen);\n      var offset;\n\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                consequent.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                alternate.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            testInstrs.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n            continue;\n          }\n\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokens.closeParen && ( // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n              // $FlowIgnore\n              args.push(parseFuncInstr());\n            } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            fnBody.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n\n        eatToken();\n        return t.start(_index2);\n      }\n\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return t.program(body);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}