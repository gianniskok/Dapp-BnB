{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst Transform = require('stream').Transform;\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst SsriOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  error: {\n    default: false\n  },\n  integrity: {},\n  options: {\n    default: []\n  },\n  pickAlgorithm: {\n    default: () => getPrioritizedHash\n  },\n  Promise: {\n    default: () => Promise\n  },\n  sep: {\n    default: ' '\n  },\n  single: {\n    default: false\n  },\n  size: {},\n  strict: {\n    default: false\n  }\n});\n\nclass Hash {\n  get isHash() {\n    return true;\n  }\n\n  constructor(hash, opts) {\n    opts = SsriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim(); // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n  }\n\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!( // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      (this.options || []).every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n\n}\n\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n    let sep = opts.sep || ' ';\n\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n\n  concat(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n\n  match(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  pickAlgorithm(opts) {\n    opts = SsriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);\n    }\n\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n\n}\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const istream = integrityStream(opts);\n  return new P((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new P((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts) {\n  opts = SsriOpts(opts); // For verification\n\n  const sri = opts.integrity && parse(opts.integrity, opts);\n  const goodSri = sri && Object.keys(sri).length;\n  const algorithm = goodSri && sri.pickAlgorithm(opts);\n  const digests = goodSri && sri[algorithm]; // Calculating stream\n\n  const algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));\n  const hashes = algorithms.map(crypto.createHash);\n  let streamSize = 0;\n  const stream = new Transform({\n    transform(chunk, enc, cb) {\n      streamSize += chunk.length;\n      hashes.forEach(h => h.update(chunk, enc));\n      cb(null, chunk, enc);\n    }\n\n  }).on('end', () => {\n    const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`;\n    }).join(' '), opts); // Integrity verification mode\n\n    const match = goodSri && newSri.match(sri, opts);\n\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`);\n      err.code = 'EBADSIZE';\n      err.found = streamSize;\n      err.expected = opts.size;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = digests;\n      err.algorithm = algorithm;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else {\n      stream.emit('size', streamSize);\n      stream.emit('integrity', newSri);\n      match && stream.emit('verified', match);\n    }\n  });\n  return stream;\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options.length ? `?${opts.options.join('?')}` : '';\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n\n          acc[algo].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"names":["crypto","require","figgyPudding","Transform","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","SsriOpts","algorithms","default","error","integrity","options","pickAlgorithm","getPrioritizedHash","Promise","sep","single","size","strict","Hash","isHash","constructor","hash","opts","source","trim","match","some","a","algorithm","digest","rawOpts","slice","split","hexDigest","Buffer","from","toString","toJSON","x","every","opt","length","join","Integrity","isIntegrity","replace","Object","keys","map","k","prototype","call","filter","concat","other","stringify","parse","algo","find","otherhash","Error","JSON","reduce","acc","module","exports","sri","_parse","fullSri","string","push","obj","fromHex","optString","fromData","data","createHash","update","fromStream","stream","P","istream","integrityStream","resolve","reject","pipe","on","s","checkData","assign","code","newSri","err","found","expected","checkStream","checker","goodSri","digests","Array","Set","hashes","streamSize","transform","chunk","enc","cb","forEach","h","i","emit","create","createIntegrity","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/node_modules/ssri/index.js"],"sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst Transform = require('stream').Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst SsriOpts = figgyPudding({\n  algorithms: {default: ['sha512']},\n  error: {default: false},\n  integrity: {},\n  options: {default: []},\n  pickAlgorithm: {default: () => getPrioritizedHash},\n  Promise: {default: () => Promise},\n  sep: {default: ' '},\n  single: {default: false},\n  size: {},\n  strict: {default: false}\n})\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = SsriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    opts = SsriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = SsriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = SsriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts)\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = SsriOpts(opts)\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({algorithm, digest})\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = SsriOpts(opts)\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = Array.from(\n    new Set(opts.algorithms.concat(algorithm ? [algorithm] : []))\n  )\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}