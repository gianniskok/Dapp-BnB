{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nconst NullFactory = require(\"./NullFactory\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Parser\")} Parser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\n\nclass RuntimeValue {\n  constructor(fn, fileDependencies) {\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n\n  exec(parser) {\n    if (this.fileDependencies === true) {\n      parser.state.module.buildInfo.cacheable = false;\n    } else {\n      for (const fileDependency of this.fileDependencies) {\n        parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n      }\n    }\n\n    return this.fn({\n      module: parser.state.module\n    });\n  }\n\n}\n\nconst stringifyObj = (obj, parser) => {\n  return \"Object({\" + Object.keys(obj).map(key => {\n    const code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\n\n\nconst toCode = (code, parser) => {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n\n  return code + \"\";\n};\n\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n\n  static runtimeValue(fn, fileDependencies) {\n    return new RuntimeValue(fn, fileDependencies);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler Webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(\"DefinePlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      /**\n       * Handler\n       * @param {Parser} parser Parser\n       * @returns {void}\n       */\n\n      const handler = parser => {\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n\n\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n          });\n        };\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n\n\n        const applyDefine = (key, code) => {\n          const isTypeof = /^typeof\\s+/.test(key);\n          if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n              const strCode = toCode(code, parser);\n\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n\n\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n          parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => new BasicEvaluatedExpression().setTruthy().setRange(expr.range));\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.evaluateToString(\"object\")(expr);\n          });\n          parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n            const strCode = stringifyObj(obj, parser);\n\n            if (/__webpack_require__/.test(strCode)) {\n              return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n            } else {\n              return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n          });\n        };\n\n        walkDefinitions(definitions, \"\");\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = DefinePlugin;","map":{"version":3,"names":["ConstDependency","require","BasicEvaluatedExpression","ParserHelpers","NullFactory","RuntimeValue","constructor","fn","fileDependencies","exec","parser","state","module","buildInfo","cacheable","fileDependency","add","stringifyObj","obj","Object","keys","map","key","code","JSON","stringify","toCode","join","undefined","RegExp","toString","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","approve","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","toConstantDependencyWithWebpackRequire","toConstantDependency","evaluateTypeof","typeofCode","typeof","isString","string","bind","setTruthy","evaluateToString","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/DefinePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n\tconstructor(fn, fileDependencies) {\n\t\tthis.fn = fn;\n\t\tthis.fileDependencies = fileDependencies || [];\n\t}\n\n\texec(parser) {\n\t\tif (this.fileDependencies === true) {\n\t\t\tparser.state.module.buildInfo.cacheable = false;\n\t\t} else {\n\t\t\tfor (const fileDependency of this.fileDependencies) {\n\t\t\t\tparser.state.module.buildInfo.fileDependencies.add(fileDependency);\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({ module: parser.state.module });\n\t}\n}\n\nconst stringifyObj = (obj, parser) => {\n\treturn (\n\t\t\"Object({\" +\n\t\tObject.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn JSON.stringify(key) + \":\" + toCode(code, parser);\n\t\t\t})\n\t\t\t.join(\",\") +\n\t\t\"})\"\n\t);\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(code.exec(parser), parser);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(code, parser);\n\t}\n\treturn code + \"\";\n};\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\tstatic runtimeValue(fn, fileDependencies) {\n\t\treturn new RuntimeValue(fn, fileDependencies);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler Webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {Parser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(fullKey)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(toCode(code, parser));\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\tconst strCode = toCode(code, parser);\n\t\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr =>\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression().setTruthy().setRange(expr.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\"object\")(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst strCode = stringifyObj(obj, parser);\n\n\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(\"object\")\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,gCAAD,CAA/B;;AACA,MAAMC,wBAAwB,GAAGD,OAAO,CAAC,4BAAD,CAAxC;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,eAAD,CAA3B;AAEA;;AACA;;AACA;;AACA;;;AAEA,MAAMI,YAAN,CAAmB;EAClBC,WAAW,CAACC,EAAD,EAAKC,gBAAL,EAAuB;IACjC,KAAKD,EAAL,GAAUA,EAAV;IACA,KAAKC,gBAAL,GAAwBA,gBAAgB,IAAI,EAA5C;EACA;;EAEDC,IAAI,CAACC,MAAD,EAAS;IACZ,IAAI,KAAKF,gBAAL,KAA0B,IAA9B,EAAoC;MACnCE,MAAM,CAACC,KAAP,CAAaC,MAAb,CAAoBC,SAApB,CAA8BC,SAA9B,GAA0C,KAA1C;IACA,CAFD,MAEO;MACN,KAAK,MAAMC,cAAX,IAA6B,KAAKP,gBAAlC,EAAoD;QACnDE,MAAM,CAACC,KAAP,CAAaC,MAAb,CAAoBC,SAApB,CAA8BL,gBAA9B,CAA+CQ,GAA/C,CAAmDD,cAAnD;MACA;IACD;;IAED,OAAO,KAAKR,EAAL,CAAQ;MAAEK,MAAM,EAAEF,MAAM,CAACC,KAAP,CAAaC;IAAvB,CAAR,CAAP;EACA;;AAhBiB;;AAmBnB,MAAMK,YAAY,GAAG,CAACC,GAAD,EAAMR,MAAN,KAAiB;EACrC,OACC,aACAS,MAAM,CAACC,IAAP,CAAYF,GAAZ,EACEG,GADF,CACMC,GAAG,IAAI;IACX,MAAMC,IAAI,GAAGL,GAAG,CAACI,GAAD,CAAhB;IACA,OAAOE,IAAI,CAACC,SAAL,CAAeH,GAAf,IAAsB,GAAtB,GAA4BI,MAAM,CAACH,IAAD,EAAOb,MAAP,CAAzC;EACA,CAJF,EAKEiB,IALF,CAKO,GALP,CADA,GAOA,IARD;AAUA,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMD,MAAM,GAAG,CAACH,IAAD,EAAOb,MAAP,KAAkB;EAChC,IAAIa,IAAI,KAAK,IAAb,EAAmB;IAClB,OAAO,MAAP;EACA;;EACD,IAAIA,IAAI,KAAKK,SAAb,EAAwB;IACvB,OAAO,WAAP;EACA;;EACD,IAAIL,IAAI,YAAYlB,YAApB,EAAkC;IACjC,OAAOqB,MAAM,CAACH,IAAI,CAACd,IAAL,CAAUC,MAAV,CAAD,EAAoBA,MAApB,CAAb;EACA;;EACD,IAAIa,IAAI,YAAYM,MAAhB,IAA0BN,IAAI,CAACO,QAAnC,EAA6C;IAC5C,OAAOP,IAAI,CAACO,QAAL,EAAP;EACA;;EACD,IAAI,OAAOP,IAAP,KAAgB,UAAhB,IAA8BA,IAAI,CAACO,QAAvC,EAAiD;IAChD,OAAO,MAAMP,IAAI,CAACO,QAAL,EAAN,GAAwB,GAA/B;EACA;;EACD,IAAI,OAAOP,IAAP,KAAgB,QAApB,EAA8B;IAC7B,OAAON,YAAY,CAACM,IAAD,EAAOb,MAAP,CAAnB;EACA;;EACD,OAAOa,IAAI,GAAG,EAAd;AACA,CApBD;;AAsBA,MAAMQ,YAAN,CAAmB;EAClB;AACD;AACA;AACA;EACCzB,WAAW,CAAC0B,WAAD,EAAc;IACxB,KAAKA,WAAL,GAAmBA,WAAnB;EACA;;EAEkB,OAAZC,YAAY,CAAC1B,EAAD,EAAKC,gBAAL,EAAuB;IACzC,OAAO,IAAIH,YAAJ,CAAiBE,EAAjB,EAAqBC,gBAArB,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC0B,KAAK,CAACC,QAAD,EAAW;IACf,MAAMH,WAAW,GAAG,KAAKA,WAAzB;IACAG,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CACC,cADD,EAEC,CAACD,WAAD,WAA0C;MAAA,IAA5B;QAAEE;MAAF,CAA4B;MACzCF,WAAW,CAACG,mBAAZ,CAAgCC,GAAhC,CAAoCzC,eAApC,EAAqD,IAAII,WAAJ,EAArD;MACAiC,WAAW,CAACK,mBAAZ,CAAgCD,GAAhC,CACCzC,eADD,EAEC,IAAIA,eAAe,CAAC2C,QAApB,EAFD;MAKA;AACJ;AACA;AACA;AACA;;MACI,MAAMC,OAAO,GAAGlC,MAAM,IAAI;QACzB;AACL;AACA;AACA;AACA;AACA;QACK,MAAMmC,eAAe,GAAG,CAACb,WAAD,EAAcc,MAAd,KAAyB;UAChD3B,MAAM,CAACC,IAAP,CAAYY,WAAZ,EAAyBe,OAAzB,CAAiCzB,GAAG,IAAI;YACvC,MAAMC,IAAI,GAAGS,WAAW,CAACV,GAAD,CAAxB;;YACA,IACCC,IAAI,IACJ,OAAOA,IAAP,KAAgB,QADhB,IAEA,EAAEA,IAAI,YAAYlB,YAAlB,CAFA,IAGA,EAAEkB,IAAI,YAAYM,MAAlB,CAJD,EAKE;cACDgB,eAAe,CAACtB,IAAD,EAAOuB,MAAM,GAAGxB,GAAT,GAAe,GAAtB,CAAf;cACA0B,iBAAiB,CAACF,MAAM,GAAGxB,GAAV,EAAeC,IAAf,CAAjB;cACA;YACA;;YACD0B,cAAc,CAACH,MAAD,EAASxB,GAAT,CAAd;YACA4B,WAAW,CAACJ,MAAM,GAAGxB,GAAV,EAAeC,IAAf,CAAX;UACA,CAdD;QAeA,CAhBD;QAkBA;AACL;AACA;AACA;AACA;AACA;;;QACK,MAAM0B,cAAc,GAAG,CAACH,MAAD,EAASxB,GAAT,KAAiB;UACvC,MAAM6B,WAAW,GAAG7B,GAAG,CAAC8B,KAAJ,CAAU,GAAV,CAApB;UACAD,WAAW,CAACE,KAAZ,CAAkB,CAAlB,EAAqBN,OAArB,CAA6B,CAACO,CAAD,EAAIC,CAAJ,KAAU;YACtC,MAAMC,OAAO,GAAGV,MAAM,GAAGK,WAAW,CAACE,KAAZ,CAAkB,CAAlB,EAAqBE,CAAC,GAAG,CAAzB,EAA4B5B,IAA5B,CAAiC,GAAjC,CAAzB;YACAjB,MAAM,CAAC0B,KAAP,CAAaqB,SAAb,CACEC,GADF,CACMF,OADN,EAEElB,GAFF,CAEM,cAFN,EAEsBnC,aAAa,CAACwD,OAFpC;UAGA,CALD;QAMA,CARD;QAUA;AACL;AACA;AACA;AACA;AACA;;;QACK,MAAMT,WAAW,GAAG,CAAC5B,GAAD,EAAMC,IAAN,KAAe;UAClC,MAAMqC,QAAQ,GAAG,aAAaC,IAAb,CAAkBvC,GAAlB,CAAjB;UACA,IAAIsC,QAAJ,EAActC,GAAG,GAAGA,GAAG,CAACwC,OAAJ,CAAY,YAAZ,EAA0B,EAA1B,CAAN;UACd,IAAIC,OAAO,GAAG,KAAd;UACA,IAAIC,aAAa,GAAG,KAApB;;UACA,IAAI,CAACJ,QAAL,EAAe;YACdlD,MAAM,CAAC0B,KAAP,CAAaqB,SAAb,CACEC,GADF,CACMpC,GADN,EAEEgB,GAFF,CAEM,cAFN,EAEsBnC,aAAa,CAACwD,OAFpC;YAGAjD,MAAM,CAAC0B,KAAP,CAAa6B,kBAAb,CACEP,GADF,CACMpC,GADN,EAEEgB,GAFF,CAEM,cAFN,EAEsB4B,IAAI,IAAI;cAC5B;AACT;AACA;AACA;AACA;AACA;AACA;AACA;cACS,IAAIH,OAAJ,EAAa;cACbA,OAAO,GAAG,IAAV;cACA,MAAMI,GAAG,GAAGzD,MAAM,CAAC0D,QAAP,CAAgB1C,MAAM,CAACH,IAAD,EAAOb,MAAP,CAAtB,CAAZ;cACAqD,OAAO,GAAG,KAAV;cACAI,GAAG,CAACE,QAAJ,CAAaH,IAAI,CAACI,KAAlB;cACA,OAAOH,GAAP;YACA,CAjBF;YAkBAzD,MAAM,CAAC0B,KAAP,CAAamC,UAAb,CAAwBb,GAAxB,CAA4BpC,GAA5B,EAAiCgB,GAAjC,CAAqC,cAArC,EAAqD4B,IAAI,IAAI;cAC5D,MAAMM,OAAO,GAAG9C,MAAM,CAACH,IAAD,EAAOb,MAAP,CAAtB;;cACA,IAAI,sBAAsBmD,IAAtB,CAA2BW,OAA3B,CAAJ,EAAyC;gBACxC,OAAOrE,aAAa,CAACsE,sCAAd,CACN/D,MADM,EAEN8D,OAFM,EAGLN,IAHK,CAAP;cAIA,CALD,MAKO;gBACN,OAAO/D,aAAa,CAACuE,oBAAd,CACNhE,MADM,EAEN8D,OAFM,EAGLN,IAHK,CAAP;cAIA;YACD,CAbD;UAcA;;UACDxD,MAAM,CAAC0B,KAAP,CAAauC,cAAb,CAA4BjB,GAA5B,CAAgCpC,GAAhC,EAAqCgB,GAArC,CAAyC,cAAzC,EAAyD4B,IAAI,IAAI;YAChE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;YACO,IAAIF,aAAJ,EAAmB;YACnBA,aAAa,GAAG,IAAhB;YACA,MAAMY,UAAU,GAAGhB,QAAQ,GACxBlC,MAAM,CAACH,IAAD,EAAOb,MAAP,CADkB,GAExB,aAAagB,MAAM,CAACH,IAAD,EAAOb,MAAP,CAAnB,GAAoC,GAFvC;YAGA,MAAMyD,GAAG,GAAGzD,MAAM,CAAC0D,QAAP,CAAgBQ,UAAhB,CAAZ;YACAZ,aAAa,GAAG,KAAhB;YACAG,GAAG,CAACE,QAAJ,CAAaH,IAAI,CAACI,KAAlB;YACA,OAAOH,GAAP;UACA,CAlBD;UAmBAzD,MAAM,CAAC0B,KAAP,CAAayC,MAAb,CAAoBnB,GAApB,CAAwBpC,GAAxB,EAA6BgB,GAA7B,CAAiC,cAAjC,EAAiD4B,IAAI,IAAI;YACxD,MAAMU,UAAU,GAAGhB,QAAQ,GACxBlC,MAAM,CAACH,IAAD,EAAOb,MAAP,CADkB,GAExB,aAAagB,MAAM,CAACH,IAAD,EAAOb,MAAP,CAAnB,GAAoC,GAFvC;YAGA,MAAMyD,GAAG,GAAGzD,MAAM,CAAC0D,QAAP,CAAgBQ,UAAhB,CAAZ;YACA,IAAI,CAACT,GAAG,CAACW,QAAJ,EAAL,EAAqB;YACrB,OAAO3E,aAAa,CAACuE,oBAAd,CACNhE,MADM,EAENc,IAAI,CAACC,SAAL,CAAe0C,GAAG,CAACY,MAAnB,CAFM,EAGLC,IAHK,CAGAtE,MAHA,EAGQwD,IAHR,CAAP;UAIA,CAVD;QAWA,CAxED;QA0EA;AACL;AACA;AACA;AACA;AACA;;;QACK,MAAMlB,iBAAiB,GAAG,CAAC1B,GAAD,EAAMJ,GAAN,KAAc;UACvCR,MAAM,CAAC0B,KAAP,CAAaqB,SAAb,CACEC,GADF,CACMpC,GADN,EAEEgB,GAFF,CAEM,cAFN,EAEsBnC,aAAa,CAACwD,OAFpC;UAGAjD,MAAM,CAAC0B,KAAP,CAAa6B,kBAAb,CACEP,GADF,CACMpC,GADN,EAEEgB,GAFF,CAEM,cAFN,EAEsB4B,IAAI,IACxB,IAAIhE,wBAAJ,GAA+B+E,SAA/B,GAA2CZ,QAA3C,CAAoDH,IAAI,CAACI,KAAzD,CAHF;UAKA5D,MAAM,CAAC0B,KAAP,CAAauC,cAAb,CAA4BjB,GAA5B,CAAgCpC,GAAhC,EAAqCgB,GAArC,CAAyC,cAAzC,EAAyD4B,IAAI,IAAI;YAChE,OAAO/D,aAAa,CAAC+E,gBAAd,CAA+B,QAA/B,EAAyChB,IAAzC,CAAP;UACA,CAFD;UAGAxD,MAAM,CAAC0B,KAAP,CAAamC,UAAb,CAAwBb,GAAxB,CAA4BpC,GAA5B,EAAiCgB,GAAjC,CAAqC,cAArC,EAAqD4B,IAAI,IAAI;YAC5D,MAAMM,OAAO,GAAGvD,YAAY,CAACC,GAAD,EAAMR,MAAN,CAA5B;;YAEA,IAAI,sBAAsBmD,IAAtB,CAA2BW,OAA3B,CAAJ,EAAyC;cACxC,OAAOrE,aAAa,CAACsE,sCAAd,CACN/D,MADM,EAEN8D,OAFM,EAGLN,IAHK,CAAP;YAIA,CALD,MAKO;cACN,OAAO/D,aAAa,CAACuE,oBAAd,CACNhE,MADM,EAEN8D,OAFM,EAGLN,IAHK,CAAP;YAIA;UACD,CAdD;UAeAxD,MAAM,CAAC0B,KAAP,CAAayC,MAAb,CAAoBnB,GAApB,CAAwBpC,GAAxB,EAA6BgB,GAA7B,CAAiC,cAAjC,EAAiD4B,IAAI,IAAI;YACxD,OAAO/D,aAAa,CAACuE,oBAAd,CACNhE,MADM,EAENc,IAAI,CAACC,SAAL,CAAe,QAAf,CAFM,EAGLyC,IAHK,CAAP;UAIA,CALD;QAMA,CAjCD;;QAmCArB,eAAe,CAACb,WAAD,EAAc,EAAd,CAAf;MACA,CAnKD;;MAqKAO,mBAAmB,CAACH,KAApB,CAA0B1B,MAA1B,CACEgD,GADF,CACM,iBADN,EAEEpB,GAFF,CAEM,cAFN,EAEsBM,OAFtB;MAGAL,mBAAmB,CAACH,KAApB,CAA0B1B,MAA1B,CACEgD,GADF,CACM,oBADN,EAEEpB,GAFF,CAEM,cAFN,EAEsBM,OAFtB;MAGAL,mBAAmB,CAACH,KAApB,CAA0B1B,MAA1B,CACEgD,GADF,CACM,gBADN,EAEEpB,GAFF,CAEM,cAFN,EAEsBM,OAFtB;IAGA,CA5LF;EA8LA;;AAlNiB;;AAoNnBhC,MAAM,CAACuE,OAAP,GAAiBpD,YAAjB"},"metadata":{},"sourceType":"script"}