{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\n\nconst {\n  Tapable,\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\n\nconst util = require(\"util\");\n\nconst vm = require(\"vm\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nclass Parser extends Tapable {\n  constructor(options) {\n    let sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    super();\n    this.hooks = {\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      assigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n      callAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    const HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n\n    this._pluginCompat.tap(\"Parser\", options => {\n      for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n        const regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        const match = regexp.exec(options.name);\n\n        if (match) {\n          if (match[1]) {\n            this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          } else {\n            this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          }\n\n          return true;\n        }\n      }\n    });\n\n    this.options = options;\n    this.sourceType = sourceType;\n    this.scope = undefined;\n    this.state = undefined;\n    this.comments = undefined;\n    this.initializeEvaluating();\n  }\n\n  initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n      }\n\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n      }\n\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n      let left;\n      let leftAsBool;\n      let right;\n\n      if (expr.operator === \"&&\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        if (leftAsBool !== true) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      } else if (expr.operator === \"||\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        if (leftAsBool !== false) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n      let left;\n      let right;\n      let res;\n\n      if (expr.operator === \"+\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftprefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixright\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number - right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"*\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number * right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"/\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number / right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"**\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(Math.pow(left.number, right.number));\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string === right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number === right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool === right.bool);\n        }\n      } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string !== right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number !== right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool !== right.bool);\n        }\n      } else if (expr.operator === \"&\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number & right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"|\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number | right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"^\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number ^ right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >>> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"<<\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number << right.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n      if (expr.operator === \"typeof\") {\n        let res;\n        let name;\n\n        if (expr.argument.type === \"Identifier\") {\n          name = this.scope.renames.get(expr.argument.name) || expr.argument.name;\n\n          if (!this.scope.definitions.has(name)) {\n            const hook = this.hooks.evaluateTypeof.get(name);\n\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n\n        if (expr.argument.type === \"MemberExpression\") {\n          const exprName = this.getNameForExpression(expr.argument);\n\n          if (exprName && exprName.free) {\n            const hook = this.hooks.evaluateTypeof.get(exprName.name);\n\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n\n        if (expr.argument.type === \"FunctionExpression\") {\n          return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n        }\n\n        const arg = this.evaluateExpression(expr.argument);\n\n        if (arg.isString() || arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n\n        if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n\n        if (argument.isBoolean()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n        }\n\n        if (argument.isTruthy()) {\n          return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n        }\n\n        if (argument.isFalsy()) {\n          return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n        }\n\n        if (argument.isString()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n        }\n\n        if (argument.isNumber()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n        }\n      } else if (expr.operator === \"~\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (!argument.isNumber()) return;\n        const res = new BasicEvaluatedExpression();\n        res.setNumber(~argument.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(expr.name) || expr.name;\n\n      if (!this.scope.definitions.has(expr.name)) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      } else {\n        const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\n        if (hook !== undefined) {\n          return hook.call(expr);\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(\"this\");\n\n      if (name) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n      let exprName = this.getNameForExpression(expression);\n\n      if (exprName) {\n        if (exprName.free) {\n          const hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\n          if (hook !== undefined) {\n            const result = hook.call(expression);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n        } else {\n          const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\n          if (hook !== undefined) {\n            return hook.call(expression);\n          }\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n      if (expr.callee.type !== \"MemberExpression\") return;\n      if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n      const param = this.evaluateExpression(expr.callee.object);\n      if (!param) return;\n      const property = expr.callee.property.name || expr.callee.property.value;\n      const hook = this.hooks.evaluateCallExpressionMember.get(property);\n\n      if (hook !== undefined) {\n        return hook.call(expr, param);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      arg1 = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      arg2 = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n    });\n    [\"substr\", \"substring\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n            str = param.string;\n\n        switch (expr.arguments.length) {\n          case 1:\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n\n          case 2:\n            {\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n\n          default:\n            return;\n        }\n\n        return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n      });\n    });\n    /**\n     * @param {string} kind \"cooked\" | \"raw\"\n     * @param {TODO} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      const quasis = [];\n      const parts = [];\n\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n\n          if (typeof exprAsString === \"string\") {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n\n          parts.push(expr);\n        }\n\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n\n      return {\n        quasis,\n        parts\n      };\n    };\n\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n      if (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const argExpr = this.evaluateExpression(expr.arguments[i]);\n\n        if (!argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          break;\n        }\n\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n      }\n\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n\n      return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        if (!consequent || !alternate) return;\n        res = new BasicEvaluatedExpression();\n\n        if (consequent.isConditional()) {\n          res.setOptions(consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n\n        if (alternate.isConditional()) {\n          res.addOptions(alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n      }\n\n      res.setRange(expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n      const items = expr.elements.map(element => {\n        return element !== null && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n    });\n  }\n\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n\n    if (result && result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n\n  walkClass(classy) {\n    if (classy.superClass) this.walkExpression(classy.superClass);\n\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n\n      for (const methodDefinition of classy.body.body) {\n        if (methodDefinition.type === \"MethodDefinition\") {\n          this.walkMethodDefinition(methodDefinition);\n        }\n      }\n\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }\n\n  walkMethodDefinition(methodDefinition) {\n    if (methodDefinition.computed && methodDefinition.key) {\n      this.walkExpression(methodDefinition.key);\n    }\n\n    if (methodDefinition.value) {\n      this.walkExpression(methodDefinition.value);\n    }\n  } // Prewalking iterates the scope for variable declarations\n\n\n  prewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.prewalkStatement(statement);\n    }\n  } // Block-Prewalking iterates the scope for block variable declarations\n\n\n  blockPrewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPrewalkStatement(statement);\n    }\n  } // Walking iterates the statements and expressions and processes them\n\n\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n\n  prewalkStatement(statement) {\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.prewalkBlockStatement(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.prewalkDoWhileStatement(statement);\n        break;\n\n      case \"ExportAllDeclaration\":\n        this.prewalkExportAllDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.prewalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.prewalkExportNamedDeclaration(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.prewalkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.prewalkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.prewalkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.prewalkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.prewalkIfStatement(statement);\n        break;\n\n      case \"ImportDeclaration\":\n        this.prewalkImportDeclaration(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.prewalkLabeledStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.prewalkSwitchStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.prewalkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.prewalkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.prewalkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.prewalkWithStatement(statement);\n        break;\n    }\n  }\n\n  blockPrewalkStatement(statement) {\n    switch (statement.type) {\n      case \"VariableDeclaration\":\n        this.blockPrewalkVariableDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.blockPrewalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.blockPrewalkExportNamedDeclaration(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.blockPrewalkClassDeclaration(statement);\n        break;\n    }\n  }\n\n  walkStatement(statement) {\n    if (this.hooks.statement.call(statement) !== undefined) return;\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n  } // Real Statements\n\n\n  prewalkBlockStatement(statement) {\n    this.prewalkStatements(statement.body);\n  }\n\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      this.blockPrewalkStatements(body);\n      this.walkStatements(body);\n    });\n  }\n\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n\n  prewalkIfStatement(statement) {\n    this.prewalkStatement(statement.consequent);\n\n    if (statement.alternate) {\n      this.prewalkStatement(statement.alternate);\n    }\n  }\n\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    }\n  }\n\n  prewalkLabeledStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n\n    this.walkStatement(statement.body);\n  }\n\n  prewalkWithStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkStatement(statement.body);\n  }\n\n  prewalkSwitchStatement(statement) {\n    this.prewalkSwitchCases(statement.cases);\n  }\n\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  prewalkTryStatement(statement) {\n    this.prewalkStatement(statement.block);\n  }\n\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n\n  prewalkWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkStatement(statement.body);\n  }\n\n  prewalkDoWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkDoWhileStatement(statement) {\n    this.walkStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n\n  prewalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.prewalkStatement(statement.init);\n      }\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPrewalkVariableDeclaration(statement.init);\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n\n  prewalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n\n  prewalkForOfStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  } // Declarations\n\n\n  prewalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        this.prewalkStatement(statement.body);\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  prewalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n      this.scope.renames.set(name, null);\n      this.scope.definitions.add(name);\n\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, \"default\", name);\n          break;\n\n        case \"ImportSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n          break;\n\n        case \"ImportNamespaceSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, null, name);\n          break;\n      }\n    }\n  }\n\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n\n        break;\n\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n\n  blockPrewalkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.blockPrewalkStatement(statement.declaration);\n    }\n  }\n\n  prewalkExportNamedDeclaration(statement) {\n    let source;\n\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.prewalkStatement(statement.declaration);\n        let index = 0;\n        this.enterDeclaration(statement.declaration, def => {\n          this.hooks.exportSpecifier.call(statement, def, def, index++);\n        });\n      }\n    }\n\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name;\n\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n\n  blockPrewalkExportDefaultDeclaration(statement) {\n    if (statement.declaration.type === \"ClassDeclaration\") {\n      this.blockPrewalkClassDeclaration(statement.declaration);\n    }\n  }\n\n  prewalkExportDefaultDeclaration(statement) {\n    this.prewalkStatement(statement.declaration);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n    }\n  }\n\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\") {\n        this.walkFunctionDeclaration(statement.declaration);\n      } else if (statement.declaration.type === \"ClassDeclaration\") {\n        this.walkClassDeclaration(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n      }\n    }\n  }\n\n  prewalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n  }\n\n  prewalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n\n    this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n\n  blockPrewalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n    this._prewalkVariableDeclaration(statement, hookMap);\n  }\n\n  _prewalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.enterPattern(declarator.id, (name, decl) => {\n              let hook = hookMap.get(name);\n\n              if (hook === undefined || !hook.call(decl)) {\n                hook = this.hooks.varDeclaration.get(name);\n\n                if (hook === undefined || !hook.call(decl)) {\n                  this.scope.renames.set(name, null);\n                  this.scope.definitions.add(name);\n                }\n              }\n            });\n            break;\n          }\n      }\n    }\n  }\n\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                  this.scope.definitions.delete(declarator.id.name);\n                }\n\n                break;\n              }\n            }\n\n            this.walkPattern(declarator.id);\n            if (declarator.init) this.walkExpression(declarator.init);\n            break;\n          }\n      }\n    }\n  }\n\n  blockPrewalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n\n  prewalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.prewalkStatements(switchCase.consequent);\n    }\n  }\n\n  walkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n\n      if (switchCase.test) {\n        this.walkExpression(switchCase.test);\n      }\n\n      this.walkStatements(switchCase.consequent);\n    }\n  }\n\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.scope.renames.set(ident, null);\n          this.scope.definitions.add(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n\n      this.prewalkStatement(catchClause.body);\n      this.walkStatement(catchClause.body);\n    });\n  }\n\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n\n  walkAwaitExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        continue;\n      }\n\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n\n      if (prop.shorthand) {\n        this.scope.inShorthand = true;\n      }\n\n      this.walkExpression(prop.value);\n\n      if (prop.shorthand) {\n        this.scope.inShorthand = false;\n      }\n    }\n  }\n\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = expression.params; // Add function name in scope for recursive calls\n\n    if (expression.id) {\n      scopeParams.push(expression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkArrowFunctionExpression(expression) {\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n  }\n\n  walkSequenceExpression(expression) {\n    if (expression.expressions) this.walkExpressions(expression.expressions);\n  }\n\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const exprName = this.getNameForExpression(expression.argument);\n\n      if (exprName && exprName.free) {\n        const hook = this.hooks.typeof.get(exprName.name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n\n    this.walkExpression(expression.argument);\n  }\n\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n\n  walkBinaryExpression(expression) {\n    this.walkLeftRightExpression(expression);\n  }\n\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n\n  walkAssignmentExpression(expression) {\n    const renameIdentifier = this.getRenameIdentifier(expression.right);\n\n    if (expression.left.type === \"Identifier\" && renameIdentifier) {\n      const hook = this.hooks.canRename.get(renameIdentifier);\n\n      if (hook !== undefined && hook.call(expression.right)) {\n        // renaming \"a = b;\"\n        const hook = this.hooks.rename.get(renameIdentifier);\n\n        if (hook === undefined || !hook.call(expression.right)) {\n          this.scope.renames.set(expression.left.name, renameIdentifier);\n          this.scope.definitions.delete(expression.left.name);\n        }\n\n        return;\n      }\n    }\n\n    if (expression.left.type === \"Identifier\") {\n      const assignedHook = this.hooks.assigned.get(expression.left.name);\n\n      if (assignedHook === undefined || !assignedHook.call(expression)) {\n        this.walkExpression(expression.right);\n      }\n\n      this.scope.renames.set(expression.left.name, null);\n      const assignHook = this.hooks.assign.get(expression.left.name);\n\n      if (assignHook === undefined || !assignHook.call(expression)) {\n        this.walkExpression(expression.left);\n      }\n\n      return;\n    }\n\n    this.walkExpression(expression.right);\n    this.walkPattern(expression.left);\n    this.enterPattern(expression.left, (name, decl) => {\n      this.scope.renames.set(name, null);\n    });\n  }\n\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n\n  walkNewExpression(expression) {\n    const callee = this.evaluateExpression(expression.callee);\n\n    if (callee.isIdentifier()) {\n      const hook = this.hooks.new.get(callee.identifier);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result === true) {\n          return;\n        }\n      }\n    }\n\n    this.walkExpression(expression.callee);\n\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.walkExpression(expression.tag);\n    }\n\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n\n  _walkIIFE(functionExpression, options, currentThis) {\n    const renameArgOrThis = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n\n      if (renameIdentifier) {\n        const hook = this.hooks.canRename.get(renameIdentifier);\n\n        if (hook !== undefined && hook.call(argOrThis)) {\n          const hook = this.hooks.rename.get(renameIdentifier);\n\n          if (hook === undefined || !hook.call(argOrThis)) {\n            return renameIdentifier;\n          }\n        }\n      }\n\n      this.walkExpression(argOrThis);\n    };\n\n    const params = functionExpression.params;\n    const renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n    const args = options.map(renameArgOrThis);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = params.filter((identifier, idx) => !args[idx]); // Add function name in scope for recursive calls\n\n    if (functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis) {\n        this.scope.renames.set(\"this\", renameThis);\n      }\n\n      for (let i = 0; i < args.length; i++) {\n        const param = args[i];\n        if (!param) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.scope.renames.set(params[i].name, param);\n      }\n\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        this.prewalkStatement(functionExpression.body);\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkCallExpression(expression) {\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n      // (function() { }.call/bind(?, ))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type === \"FunctionExpression\") {\n      // (function() { }())\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else if (expression.callee.type === \"Import\") {\n      let result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    } else {\n      const callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        const callHook = this.hooks.call.get(callee.identifier);\n\n        if (callHook !== undefined) {\n          let result = callHook.call(expression);\n          if (result === true) return;\n        }\n\n        let identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\n        if (identifier !== callee.identifier) {\n          const callAnyHook = this.hooks.callAnyMember.get(identifier);\n\n          if (callAnyHook !== undefined) {\n            let result = callAnyHook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n\n      if (expression.callee) this.walkExpression(expression.callee);\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkMemberExpression(expression) {\n    const exprName = this.getNameForExpression(expression);\n\n    if (exprName && exprName.free) {\n      const expressionHook = this.hooks.expression.get(exprName.name);\n\n      if (expressionHook !== undefined) {\n        const result = expressionHook.call(expression);\n        if (result === true) return;\n      }\n\n      const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n\n      if (expressionAnyMemberHook !== undefined) {\n        const result = expressionAnyMemberHook.call(expression);\n        if (result === true) return;\n      }\n    }\n\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  walkThisExpression(expression) {\n    const expressionHook = this.hooks.expression.get(\"this\");\n\n    if (expressionHook !== undefined) {\n      expressionHook.call(expression);\n    }\n  }\n\n  walkIdentifier(expression) {\n    if (!this.scope.definitions.has(expression.name)) {\n      const hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) return;\n      }\n    }\n  }\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    this.scope.renames.set(\"this\", null);\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n\n    if (hasThis) {\n      this.scope.renames.set(\"this\", null);\n    }\n\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  } // TODO webpack 5: remove this methods\n  // only for backward-compat\n\n\n  detectStrictMode(statements) {\n    this.detectMode(statements);\n  }\n\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n    if (isLiteral && statements[0].expression.value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n\n    if (isLiteral && statements[0].expression.value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n\n      case \"Property\":\n        this.enterPattern(pattern.value, onIdent);\n        break;\n    }\n  }\n\n  enterIdentifier(pattern, onIdent) {\n    onIdent(pattern.name, pattern);\n  }\n\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      this.enterPattern(element, onIdent);\n    }\n  }\n\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result !== undefined) {\n          if (result) {\n            result.setExpression(expression);\n          }\n\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e); // ignore error\n    }\n\n    return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n  }\n\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n\n        break;\n\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n\n        break;\n\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n\n  parse(source, initialState) {\n    let ast;\n    let comments;\n\n    if (typeof source === \"object\" && source !== null) {\n      ast = source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = Parser.parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments\n      });\n    }\n\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedSetMap(),\n      renames: new StackedSetMap()\n    };\n    const state = this.state = initialState || {};\n    this.comments = comments;\n\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.detectMode(ast.body);\n      this.prewalkStatements(ast.body);\n      this.blockPrewalkStatements(ast.body);\n      this.walkStatements(ast.body);\n    }\n\n    this.scope = oldScope;\n    this.state = oldState;\n    this.comments = oldComments;\n    return state;\n  }\n\n  evaluate(source) {\n    const ast = Parser.parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    }); // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    } // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n\n\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n\n  getComments(range) {\n    return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);\n  }\n\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n\n    let options = {};\n    let errors = [];\n\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          const val = vm.runInNewContext(`(function(){return {${value}};})()`);\n          Object.assign(options, val);\n        } catch (e) {\n          e.comment = comment;\n          errors.push(e);\n        }\n      }\n    }\n\n    return {\n      options,\n      errors\n    };\n  }\n\n  getNameForExpression(expression) {\n    let expr = expression;\n    const exprName = [];\n\n    while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n      exprName.push(expr.computed ? expr.property.value : expr.property.name);\n      expr = expr.object;\n    }\n\n    let free;\n\n    if (expr.type === \"Identifier\") {\n      free = !this.scope.definitions.has(expr.name);\n      exprName.push(this.scope.renames.get(expr.name) || expr.name);\n    } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n      free = true;\n      exprName.push(this.scope.renames.get(\"this\"));\n    } else if (expr.type === \"ThisExpression\") {\n      free = this.scope.topLevelScope;\n      exprName.push(\"this\");\n    } else {\n      return null;\n    }\n\n    let prefix = \"\";\n\n    for (let i = exprName.length - 1; i >= 2; i--) {\n      prefix += exprName[i] + \".\";\n    }\n\n    if (exprName.length > 1) {\n      prefix += exprName[1];\n    }\n\n    const name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n    const nameGeneral = prefix;\n    return {\n      name,\n      nameGeneral,\n      free\n    };\n  }\n\n  static parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    const parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n\n    if (type === \"auto\") {\n      parserOptions.sourceType = \"module\";\n    } else if (parserOptions.sourceType === \"script\") {\n      parserOptions.allowReturnOutsideFunction = true;\n    }\n\n    let ast;\n    let error;\n    let threw = false;\n\n    try {\n      ast = acornParser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n      parserOptions.allowReturnOutsideFunction = true;\n\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n\n      try {\n        ast = acornParser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {\n        threw = true;\n      }\n    }\n\n    if (threw) {\n      throw error;\n    }\n\n    return ast;\n  }\n\n} // TODO remove in webpack 5\n\n\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":{"version":3,"names":["acorn","require","Tapable","SyncBailHook","HookMap","util","vm","BasicEvaluatedExpression","StackedSetMap","acornParser","Parser","joinRanges","startRange","endRange","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","constructor","hooks","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","statement","statementIf","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","canRename","rename","assigned","assign","typeof","importCall","call","callAnyMember","new","expression","expressionAnyMember","expressionConditionalOperator","expressionLogicalOperator","program","HOOK_MAP_COMPAT_CONFIG","_pluginCompat","tap","name","Object","keys","regexp","match","exec","fn","bind","scope","undefined","state","comments","initializeEvaluating","for","expr","value","setNumber","setRange","range","setString","setBoolean","setNull","setRegExp","left","leftAsBool","right","operator","evaluateExpression","asBool","res","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","concat","Math","pow","isBoolean","bool","argument","type","renames","get","definitions","has","hook","exprName","getNameForExpression","free","arg","isArray","isConstArray","isRegExp","isTruthy","isFalsy","result","setIdentifier","callee","property","computed","param","object","arguments","length","arg1","arg2","regExp","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","parts","i","quasiExpr","quasi","prevExpr","expressions","exprAsString","asString","setExpression","push","part","node","setTemplateString","tag","identifier","stringSuffix","hasUnknownParams","argExpr","newString","newRange","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","getRenameIdentifier","isIdentifier","walkClass","classy","superClass","walkExpression","body","wasTopLevel","topLevelScope","methodDefinition","walkMethodDefinition","key","prewalkStatements","statements","index","len","prewalkStatement","blockPrewalkStatements","blockPrewalkStatement","walkStatements","walkStatement","prewalkBlockStatement","prewalkDoWhileStatement","prewalkExportAllDeclaration","prewalkExportDefaultDeclaration","prewalkExportNamedDeclaration","prewalkForInStatement","prewalkForOfStatement","prewalkForStatement","prewalkFunctionDeclaration","prewalkIfStatement","prewalkImportDeclaration","prewalkLabeledStatement","prewalkSwitchStatement","prewalkTryStatement","prewalkVariableDeclaration","prewalkWhileStatement","prewalkWithStatement","blockPrewalkVariableDeclaration","blockPrewalkExportDefaultDeclaration","blockPrewalkExportNamedDeclaration","blockPrewalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","inBlockScope","prewalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","inTry","handler","walkCatchClause","finalizer","init","update","walkPattern","id","set","add","inFunctionScope","params","detectMode","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarator","declarations","enterPattern","def","specifierIndex","exported","_prewalkVariableDeclaration","hookMap","decl","renameIdentifier","delete","switchCases","switchCase","catchClause","ident","pattern","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkLogicalExpression","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","shorthand","inShorthand","scopeParams","walkLeftRightExpression","assignedHook","assignHook","_walkIIFE","functionExpression","currentThis","renameArgOrThis","argOrThis","renameThis","args","filter","idx","slice","callHook","callAnyHook","expressionHook","expressionAnyMemberHook","nameGeneral","inScope","oldScope","isStrict","isAsmJs","createChild","enterPatterns","hasThis","detectStrictMode","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","initialState","ast","oldState","oldComments","getComments","comment","parseCommentOptions","val","runInNewContext","parserOptions","create","allowReturnOutsideFunction","error","threw","Array","defineProperty","prototype","configurable","deprecate","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/Parser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\nconst { Tapable, SyncBailHook, HookMap } = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: 11,\n\tsourceType: \"module\",\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass Parser extends Tapable {\n\tconstructor(options, sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\tassigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tcallAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"])\n\t\t};\n\t\tconst HOOK_MAP_COMPAT_CONFIG = {\n\t\t\tevaluateTypeof: /^evaluate typeof (.+)$/,\n\t\t\tevaluateIdentifier: /^evaluate Identifier (.+)$/,\n\t\t\tevaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n\t\t\tevaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n\t\t\tevaluate: /^evaluate (.+)$/,\n\t\t\tlabel: /^label (.+)$/,\n\t\t\tvarDeclarationLet: /^var-let (.+)$/,\n\t\t\tvarDeclarationConst: /^var-const (.+)$/,\n\t\t\tvarDeclarationVar: /^var-var (.+)$/,\n\t\t\tvarDeclaration: /^var (.+)$/,\n\t\t\tcanRename: /^can-rename (.+)$/,\n\t\t\trename: /^rename (.+)$/,\n\t\t\ttypeof: /^typeof (.+)$/,\n\t\t\tassigned: /^assigned (.+)$/,\n\t\t\tassign: /^assign (.+)$/,\n\t\t\tcallAnyMember: /^call (.+)\\.\\*$/,\n\t\t\tcall: /^call (.+)$/,\n\t\t\tnew: /^new (.+)$/,\n\t\t\texpressionConditionalOperator: /^expression \\?:$/,\n\t\t\texpressionAnyMember: /^expression (.+)\\.\\*$/,\n\t\t\texpression: /^expression (.+)$/\n\t\t};\n\t\tthis._pluginCompat.tap(\"Parser\", options => {\n\t\t\tfor (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n\t\t\t\tconst regexp = HOOK_MAP_COMPAT_CONFIG[name];\n\t\t\t\tconst match = regexp.exec(options.name);\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.options = options;\n\t\tthis.sourceType = sourceType;\n\t\tthis.scope = undefined;\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.initializeEvaluating();\n\t}\n\n\tinitializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet leftAsBool;\n\t\t\tlet right;\n\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== true) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== false) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet right;\n\t\t\tlet res;\n\t\t\tif (expr.operator === \"+\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (left.isString()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"leftprefix\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixright\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number - right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number * right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number / right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(Math.pow(left.number, right.number));\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"==\" || expr.operator === \"===\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string === right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number === right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool === right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string !== right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number !== right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool !== right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number & right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number | right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number ^ right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >>> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number << right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\tlet res;\n\t\t\t\tlet name;\n\t\t\t\tif (expr.argument.type === \"Identifier\") {\n\t\t\t\t\tname =\n\t\t\t\t\t\tthis.scope.renames.get(expr.argument.name) || expr.argument.name;\n\t\t\t\t\tif (!this.scope.definitions.has(name)) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"MemberExpression\") {\n\t\t\t\t\tconst exprName = this.getNameForExpression(expr.argument);\n\t\t\t\t\tif (exprName && exprName.free) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(exprName.name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"FunctionExpression\") {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\tif (arg.isString() || arg.isWrapped()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (argument.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.bool)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isTruthy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(false)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isFalsy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(true)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isString()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.string)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.number)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (!argument.isNumber()) return;\n\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(~argument.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(expr.name) || expr.name;\n\t\t\tif (!this.scope.definitions.has(expr.name)) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t} else {\n\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(\"this\");\n\t\t\tif (name) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n\t\t\tlet exprName = this.getNameForExpression(expression);\n\t\t\tif (exprName) {\n\t\t\t\tif (exprName.free) {\n\t\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setIdentifier(exprName.name)\n\t\t\t\t\t\t.setRange(expression.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.callee.type !== \"MemberExpression\") return;\n\t\t\tif (\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tconst param = this.evaluateExpression(expr.callee.object);\n\t\t\tif (!param) return;\n\t\t\tconst property = expr.callee.property.name || expr.callee.property.value;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\targ1 = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\targ2 = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1, arg2))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {string} kind \"cooked\" | \"raw\"\n\t\t * @param {TODO} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\tconst quasis = [];\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (typeof exprAsString === \"string\") {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n\t\t\tif (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst argExpr = this.evaluateExpression(expr.arguments[i]);\n\t\t\t\t\tif (!argExpr.isString() && !argExpr.isNumber()) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\tconst conditionValue = condition.asBool();\n\t\t\tlet res;\n\t\t\tif (conditionValue === undefined) {\n\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t}\n\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t);\n\t\t\t}\n\t\t\tres.setRange(expr.range);\n\t\t\treturn res;\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\treturn element !== null && this.evaluateExpression(element);\n\t\t\t});\n\t\t\tif (!items.every(Boolean)) return;\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setItems(items)\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\twalkClass(classy) {\n\t\tif (classy.superClass) this.walkExpression(classy.superClass);\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\tthis.scope.topLevelScope = false;\n\t\t\tfor (const methodDefinition of classy.body.body) {\n\t\t\t\tif (methodDefinition.type === \"MethodDefinition\") {\n\t\t\t\t\tthis.walkMethodDefinition(methodDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t}\n\t}\n\n\twalkMethodDefinition(methodDefinition) {\n\t\tif (methodDefinition.computed && methodDefinition.key) {\n\t\t\tthis.walkExpression(methodDefinition.key);\n\t\t}\n\t\tif (methodDefinition.value) {\n\t\t\tthis.walkExpression(methodDefinition.value);\n\t\t}\n\t}\n\n\t// Prewalking iterates the scope for variable declarations\n\tprewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.prewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block-Prewalking iterates the scope for block variable declarations\n\tblockPrewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPrewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tprewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.prewalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.prewalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.prewalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.prewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.prewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.prewalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.prewalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.prewalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.prewalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.prewalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.prewalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.prewalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.prewalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.prewalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.prewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.prewalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.prewalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPrewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPrewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPrewalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkStatement(statement) {\n\t\tif (this.hooks.statement.call(statement) !== undefined) return;\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Real Statements\n\tprewalkBlockStatement(statement) {\n\t\tthis.prewalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tthis.blockPrewalkStatements(body);\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tprewalkIfStatement(statement) {\n\t\tthis.prewalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.prewalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkLabeledStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkWithStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkSwitchStatement(statement) {\n\t\tthis.prewalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tprewalkTryStatement(statement) {\n\t\tthis.prewalkStatement(statement.block);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tprewalkWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkDoWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tprewalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.prewalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForOfStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tprewalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tthis.prewalkStatement(statement.body);\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tprewalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tthis.scope.renames.set(name, null);\n\t\t\tthis.scope.definitions.add(name);\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, \"default\", name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(\n\t\t\t\t\t\tstatement,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, null, name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.blockPrewalkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.prewalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPrewalkExportDefaultDeclaration(statement) {\n\t\tif (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\tthis.blockPrewalkClassDeclaration(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportDefaultDeclaration(statement) {\n\t\tthis.prewalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\"\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (statement.declaration.type === \"FunctionDeclaration\") {\n\t\t\t\tthis.walkFunctionDeclaration(statement.declaration);\n\t\t\t} else if (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\t\tthis.walkClassDeclaration(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n\t}\n\n\tprewalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPrewalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._prewalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_prewalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(name, null);\n\t\t\t\t\t\t\t\tthis.scope.definitions.add(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(\n\t\t\t\t\t\t\t\t\tdeclarator.id.name,\n\t\t\t\t\t\t\t\t\tthis.scope.renames.get(renameIdentifier) || renameIdentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.scope.definitions.delete(declarator.id.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPrewalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tprewalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.prewalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\n\t\t\tif (switchCase.test) {\n\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t}\n\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.scope.renames.set(ident, null);\n\t\t\t\t\tthis.scope.definitions.add(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tthis.prewalkStatement(catchClause.body);\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\tthis.walkExpression(prop.argument);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop.computed) {\n\t\t\t\tthis.walkExpression(prop.key);\n\t\t\t}\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = true;\n\t\t\t}\n\t\t\tthis.walkExpression(prop.value);\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t}\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t}\n\n\twalkSequenceExpression(expression) {\n\t\tif (expression.expressions) this.walkExpressions(expression.expressions);\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst exprName = this.getNameForExpression(expression.argument);\n\t\t\tif (exprName && exprName.free) {\n\t\t\t\tconst hook = this.hooks.typeof.get(exprName.name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\tif (expression.left.type === \"Identifier\" && renameIdentifier) {\n\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\tif (hook !== undefined && hook.call(expression.right)) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\tif (hook === undefined || !hook.call(expression.right)) {\n\t\t\t\t\tthis.scope.renames.set(expression.left.name, renameIdentifier);\n\t\t\t\t\tthis.scope.definitions.delete(expression.left.name);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst assignedHook = this.hooks.assigned.get(expression.left.name);\n\t\t\tif (assignedHook === undefined || !assignedHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t\tthis.scope.renames.set(expression.left.name, null);\n\t\t\tconst assignHook = this.hooks.assign.get(expression.left.name);\n\t\t\tif (assignHook === undefined || !assignHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.walkExpression(expression.right);\n\t\tthis.walkPattern(expression.left);\n\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\tthis.scope.renames.set(name, null);\n\t\t});\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\tif (callee.isIdentifier()) {\n\t\t\tconst hook = this.hooks.new.get(callee.identifier);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst renameArgOrThis = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\tif (hook !== undefined && hook.call(argOrThis)) {\n\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\tif (hook === undefined || !hook.call(argOrThis)) {\n\t\t\t\t\t\treturn renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst params = functionExpression.params;\n\t\tconst renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n\t\tconst args = options.map(renameArgOrThis);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis) {\n\t\t\t\tthis.scope.renames.set(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tconst param = args[i];\n\t\t\t\tif (!param) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.scope.renames.set(params[i].name, param);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tthis.prewalkStatement(functionExpression.body);\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkCallExpression(expression) {\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type === \"FunctionExpression\" &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0\n\t\t) {\n\t\t\t// (function() { }.call/bind(?, ))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (expression.callee.type === \"FunctionExpression\") {\n\t\t\t// (function() { }())\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else if (expression.callee.type === \"Import\") {\n\t\t\tlet result = this.hooks.importCall.call(expression);\n\t\t\tif (result === true) return;\n\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t} else {\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst callHook = this.hooks.call.get(callee.identifier);\n\t\t\t\tif (callHook !== undefined) {\n\t\t\t\t\tlet result = callHook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t\tlet identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\t\t\t\tif (identifier !== callee.identifier) {\n\t\t\t\t\tconst callAnyHook = this.hooks.callAnyMember.get(identifier);\n\t\t\t\t\tif (callAnyHook !== undefined) {\n\t\t\t\t\t\tlet result = callAnyHook.call(expression);\n\t\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expression.callee) this.walkExpression(expression.callee);\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprName = this.getNameForExpression(expression);\n\t\tif (exprName && exprName.free) {\n\t\t\tconst expressionHook = this.hooks.expression.get(exprName.name);\n\t\t\tif (expressionHook !== undefined) {\n\t\t\t\tconst result = expressionHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t\tconst expressionAnyMemberHook = this.hooks.expressionAnyMember.get(\n\t\t\t\texprName.nameGeneral\n\t\t\t);\n\t\t\tif (expressionAnyMemberHook !== undefined) {\n\t\t\t\tconst result = expressionAnyMemberHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tconst expressionHook = this.hooks.expression.get(\"this\");\n\t\tif (expressionHook !== undefined) {\n\t\t\texpressionHook.call(expression);\n\t\t}\n\t}\n\n\twalkIdentifier(expression) {\n\t\tif (!this.scope.definitions.has(expression.name)) {\n\t\t\tconst hook = this.hooks.expression.get(\n\t\t\t\tthis.scope.renames.get(expression.name) || expression.name\n\t\t\t);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tthis.scope.renames.set(\"this\", null);\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.scope.renames.set(\"this\", null);\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t// TODO webpack 5: remove this methods\n\t// only for backward-compat\n\tdetectStrictMode(statements) {\n\t\tthis.detectMode(statements);\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tonIdent(pattern.name, pattern);\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\tparse(source, initialState) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tif (typeof source === \"object\" && source !== null) {\n\t\t\tast = source;\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = Parser.parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedSetMap(),\n\t\t\trenames: new StackedSetMap()\n\t\t};\n\t\tconst state = (this.state = initialState || {});\n\t\tthis.comments = comments;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.prewalkStatements(ast.body);\n\t\t\tthis.blockPrewalkStatements(ast.body);\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.scope = oldScope;\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = Parser.parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\tgetComments(range) {\n\t\treturn this.comments.filter(\n\t\t\tcomment => comment.range[0] >= range[0] && comment.range[1] <= range[1]\n\t\t);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\tgetNameForExpression(expression) {\n\t\tlet expr = expression;\n\t\tconst exprName = [];\n\t\twhile (\n\t\t\texpr.type === \"MemberExpression\" &&\n\t\t\texpr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")\n\t\t) {\n\t\t\texprName.push(expr.computed ? expr.property.value : expr.property.name);\n\t\t\texpr = expr.object;\n\t\t}\n\t\tlet free;\n\t\tif (expr.type === \"Identifier\") {\n\t\t\tfree = !this.scope.definitions.has(expr.name);\n\t\t\texprName.push(this.scope.renames.get(expr.name) || expr.name);\n\t\t} else if (\n\t\t\texpr.type === \"ThisExpression\" &&\n\t\t\tthis.scope.renames.get(\"this\")\n\t\t) {\n\t\t\tfree = true;\n\t\t\texprName.push(this.scope.renames.get(\"this\"));\n\t\t} else if (expr.type === \"ThisExpression\") {\n\t\t\tfree = this.scope.topLevelScope;\n\t\t\texprName.push(\"this\");\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tlet prefix = \"\";\n\t\tfor (let i = exprName.length - 1; i >= 2; i--) {\n\t\t\tprefix += exprName[i] + \".\";\n\t\t}\n\t\tif (exprName.length > 1) {\n\t\t\tprefix += exprName[1];\n\t\t}\n\t\tconst name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n\t\tconst nameGeneral = prefix;\n\t\treturn {\n\t\t\tname,\n\t\t\tnameGeneral,\n\t\t\tfree\n\t\t};\n\t}\n\n\tstatic parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\tconst parserOptions = Object.assign(\n\t\t\tObject.create(null),\n\t\t\tdefaultParserOptions,\n\t\t\toptions\n\t\t);\n\n\t\tif (type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"module\";\n\t\t} else if (parserOptions.sourceType === \"script\") {\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t}\n\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\tthrew = true;\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn ast;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {TODO} range Range\n\t\t * @returns {void}\n\t\t * @this {Parser}\n\t\t */\n\t\tfunction(range) {\n\t\t\treturn this.parseCommentOptions(range).options;\n\t\t},\n\t\t\"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\"\n\t)\n});\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}