{"ast":null,"code":"'use strict';\n\nvar regexNot = require('regex-not');\n\nvar toRegex = require('to-regex');\n/**\n * Characters to use in negation regex (we want to \"not\" match\n * characters that are matched by other parsers)\n */\n\n\nvar cached;\nvar NOT_REGEX = '[\\\\[!*+?$^\"\\'.\\\\\\\\/]+';\nvar not = createTextRegex(NOT_REGEX);\n/**\n * Nanomatch parsers\n */\n\nmodule.exports = function (nanomatch, options) {\n  var parser = nanomatch.parser;\n  var opts = parser.options;\n  parser.state = {\n    slashes: 0,\n    paths: []\n  };\n  parser.ast.state = parser.state;\n  parser\n  /**\n   * Beginning-of-string\n   */\n  .capture('prefix', function () {\n    if (this.parsed) return;\n    var m = this.match(/^\\.[\\\\/]/);\n    if (!m) return;\n    this.state.strictOpen = !!this.options.strictOpen;\n    this.state.addPrefix = true;\n  })\n  /**\n   * Escape: \"\\\\.\"\n   */\n  .capture('escape', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(/^(?:\\\\(.)|([$^]))/);\n    if (!m) return;\n    return pos({\n      type: 'escape',\n      val: m[2] || m[1]\n    });\n  })\n  /**\n   * Quoted strings\n   */\n  .capture('quoted', function () {\n    var pos = this.position();\n    var m = this.match(/^[\"']/);\n    if (!m) return;\n    var quote = m[0];\n\n    if (this.input.indexOf(quote) === -1) {\n      return pos({\n        type: 'escape',\n        val: quote\n      });\n    }\n\n    var tok = advanceTo(this.input, quote);\n    this.consume(tok.len);\n    return pos({\n      type: 'quoted',\n      val: tok.esc\n    });\n  })\n  /**\n   * Negations: \"!\"\n   */\n  .capture('not', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(this.notRegex || /^!+/);\n    if (!m) return;\n    var val = m[0];\n    var isNegated = val.length % 2 === 1;\n\n    if (parsed === '' && !isNegated) {\n      val = '';\n    } // if nothing has been parsed, we know `!` is at the start,\n    // so we need to wrap the result in a negation regex\n\n\n    if (parsed === '' && isNegated && this.options.nonegate !== true) {\n      this.bos.val = '(?!^(?:';\n      this.append = ')$).*';\n      val = '';\n    }\n\n    return pos({\n      type: 'not',\n      val: val\n    });\n  })\n  /**\n   * Dot: \".\"\n   */\n  .capture('dot', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\.+/);\n    if (!m) return;\n    var val = m[0];\n    this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');\n    return pos({\n      type: 'dot',\n      dotfiles: this.state.dot,\n      val: val\n    });\n  })\n  /**\n   * Plus: \"+\"\n   */\n  .capture('plus', /^\\+(?!\\()/)\n  /**\n   * Question mark: \"?\"\n   */\n  .capture('qmark', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\?+(?!\\()/);\n    if (!m) return;\n    this.state.metachar = true;\n    this.state.qmark = true;\n    return pos({\n      type: 'qmark',\n      parsed: parsed,\n      val: m[0]\n    });\n  })\n  /**\n   * Globstar: \"**\"\n   */\n  .capture('globstar', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\*{2}(?![*(])(?=[,)/]|$)/);\n    if (!m) return;\n    var type = opts.noglobstar !== true ? 'globstar' : 'star';\n    var node = pos({\n      type: type,\n      parsed: parsed\n    });\n    this.state.metachar = true;\n\n    while (this.input.slice(0, 4) === '/**/') {\n      this.input = this.input.slice(3);\n    }\n\n    node.isInside = {\n      brace: this.isInside('brace'),\n      paren: this.isInside('paren')\n    };\n\n    if (type === 'globstar') {\n      this.state.globstar = true;\n      node.val = '**';\n    } else {\n      this.state.star = true;\n      node.val = '*';\n    }\n\n    return node;\n  })\n  /**\n   * Star: \"*\"\n   */\n  .capture('star', function () {\n    var pos = this.position();\n    var starRe = /^(?:\\*(?![*(])|[*]{3,}(?!\\()|[*]{2}(?![(/]|$)|\\*(?=\\*\\())/;\n    var m = this.match(starRe);\n    if (!m) return;\n    this.state.metachar = true;\n    this.state.star = true;\n    return pos({\n      type: 'star',\n      val: m[0]\n    });\n  })\n  /**\n   * Slash: \"/\"\n   */\n  .capture('slash', function () {\n    var pos = this.position();\n    var m = this.match(/^\\//);\n    if (!m) return;\n    this.state.slashes++;\n    return pos({\n      type: 'slash',\n      val: m[0]\n    });\n  })\n  /**\n   * Backslash: \"\\\\\"\n   */\n  .capture('backslash', function () {\n    var pos = this.position();\n    var m = this.match(/^\\\\(?![*+?(){}[\\]'\"])/);\n    if (!m) return;\n    var val = m[0];\n\n    if (this.isInside('bracket')) {\n      val = '\\\\';\n    } else if (val.length > 1) {\n      val = '\\\\\\\\';\n    }\n\n    return pos({\n      type: 'backslash',\n      val: val\n    });\n  })\n  /**\n   * Square: \"[.]\"\n   */\n  .capture('square', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(/^\\[([^!^\\\\])\\]/);\n    if (!m) return;\n    return pos({\n      type: 'square',\n      val: m[1]\n    });\n  })\n  /**\n   * Brackets: \"[...]\" (basic, this can be overridden by other parsers)\n   */\n  .capture('bracket', function () {\n    var pos = this.position();\n    var m = this.match(/^(?:\\[([!^]?)([^\\]]+|\\]-)(\\]|[^*+?]+)|\\[)/);\n    if (!m) return;\n    var val = m[0];\n    var negated = m[1] ? '^' : '';\n    var inner = (m[2] || '').replace(/\\\\\\\\+/, '\\\\\\\\');\n    var close = m[3] || '';\n\n    if (m[2] && inner.length < m[2].length) {\n      val = val.replace(/\\\\\\\\+/, '\\\\\\\\');\n    }\n\n    var esc = this.input.slice(0, 2);\n\n    if (inner === '' && esc === '\\\\]') {\n      inner += esc;\n      this.consume(2);\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n\n        if (ch === ']') {\n          close = ch;\n          break;\n        }\n\n        inner += ch;\n      }\n    }\n\n    return pos({\n      type: 'bracket',\n      val: val,\n      escaped: close !== ']',\n      negated: negated,\n      inner: inner,\n      close: close\n    });\n  })\n  /**\n   * Text\n   */\n  .capture('text', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(not);\n    if (!m || !m[0]) return;\n    return pos({\n      type: 'text',\n      val: m[0]\n    });\n  });\n  /**\n   * Allow custom parsers to be passed on options\n   */\n\n  if (options && typeof options.parsers === 'function') {\n    options.parsers(nanomatch.parser);\n  }\n};\n/**\n * Advance to the next non-escaped character\n */\n\n\nfunction advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = {\n    len: 1,\n    val: '',\n    esc: ''\n  };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n\n  return tok;\n}\n/**\n * Create text regex\n */\n\n\nfunction createTextRegex(pattern) {\n  if (cached) return cached;\n  var opts = {\n    contains: true,\n    strictClose: false\n  };\n  var not = regexNot.create(pattern, opts);\n  var re = toRegex('^(?:[*]\\\\((?=.)|' + not + ')', opts);\n  return cached = re;\n}\n/**\n * Expose negation string\n */\n\n\nmodule.exports.not = NOT_REGEX;","map":{"version":3,"names":["regexNot","require","toRegex","cached","NOT_REGEX","not","createTextRegex","module","exports","nanomatch","options","parser","opts","state","slashes","paths","ast","capture","parsed","m","match","strictOpen","addPrefix","isInside","pos","position","type","val","quote","input","indexOf","tok","advanceTo","consume","len","esc","notRegex","isNegated","length","nonegate","bos","append","dot","slice","dotfiles","metachar","qmark","noglobstar","node","brace","paren","globstar","star","starRe","negated","inner","replace","close","str","idx","ch","escaped","parsers","endChar","charAt","advance","pattern","contains","strictClose","create","re"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/nanomatch/lib/parsers.js"],"sourcesContent":["'use strict';\n\nvar regexNot = require('regex-not');\nvar toRegex = require('to-regex');\n\n/**\n * Characters to use in negation regex (we want to \"not\" match\n * characters that are matched by other parsers)\n */\n\nvar cached;\nvar NOT_REGEX = '[\\\\[!*+?$^\"\\'.\\\\\\\\/]+';\nvar not = createTextRegex(NOT_REGEX);\n\n/**\n * Nanomatch parsers\n */\n\nmodule.exports = function(nanomatch, options) {\n  var parser = nanomatch.parser;\n  var opts = parser.options;\n\n  parser.state = {\n    slashes: 0,\n    paths: []\n  };\n\n  parser.ast.state = parser.state;\n  parser\n\n    /**\n     * Beginning-of-string\n     */\n\n    .capture('prefix', function() {\n      if (this.parsed) return;\n      var m = this.match(/^\\.[\\\\/]/);\n      if (!m) return;\n      this.state.strictOpen = !!this.options.strictOpen;\n      this.state.addPrefix = true;\n    })\n\n    /**\n     * Escape: \"\\\\.\"\n     */\n\n    .capture('escape', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|([$^]))/);\n      if (!m) return;\n\n      return pos({\n        type: 'escape',\n        val: m[2] || m[1]\n      });\n    })\n\n    /**\n     * Quoted strings\n     */\n\n    .capture('quoted', function() {\n      var pos = this.position();\n      var m = this.match(/^[\"']/);\n      if (!m) return;\n\n      var quote = m[0];\n      if (this.input.indexOf(quote) === -1) {\n        return pos({\n          type: 'escape',\n          val: quote\n        });\n      }\n\n      var tok = advanceTo(this.input, quote);\n      this.consume(tok.len);\n\n      return pos({\n        type: 'quoted',\n        val: tok.esc\n      });\n    })\n\n    /**\n     * Negations: \"!\"\n     */\n\n    .capture('not', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(this.notRegex || /^!+/);\n      if (!m) return;\n      var val = m[0];\n\n      var isNegated = (val.length % 2) === 1;\n      if (parsed === '' && !isNegated) {\n        val = '';\n      }\n\n      // if nothing has been parsed, we know `!` is at the start,\n      // so we need to wrap the result in a negation regex\n      if (parsed === '' && isNegated && this.options.nonegate !== true) {\n        this.bos.val = '(?!^(?:';\n        this.append = ')$).*';\n        val = '';\n      }\n      return pos({\n        type: 'not',\n        val: val\n      });\n    })\n\n    /**\n     * Dot: \".\"\n     */\n\n    .capture('dot', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\.+/);\n      if (!m) return;\n\n      var val = m[0];\n      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');\n\n      return pos({\n        type: 'dot',\n        dotfiles: this.state.dot,\n        val: val\n      });\n    })\n\n    /**\n     * Plus: \"+\"\n     */\n\n    .capture('plus', /^\\+(?!\\()/)\n\n    /**\n     * Question mark: \"?\"\n     */\n\n    .capture('qmark', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\?+(?!\\()/);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.qmark = true;\n\n      return pos({\n        type: 'qmark',\n        parsed: parsed,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Globstar: \"**\"\n     */\n\n    .capture('globstar', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\*{2}(?![*(])(?=[,)/]|$)/);\n      if (!m) return;\n\n      var type = opts.noglobstar !== true ? 'globstar' : 'star';\n      var node = pos({type: type, parsed: parsed});\n      this.state.metachar = true;\n\n      while (this.input.slice(0, 4) === '/**/') {\n        this.input = this.input.slice(3);\n      }\n\n      node.isInside = {\n        brace: this.isInside('brace'),\n        paren: this.isInside('paren')\n      };\n\n      if (type === 'globstar') {\n        this.state.globstar = true;\n        node.val = '**';\n\n      } else {\n        this.state.star = true;\n        node.val = '*';\n      }\n\n      return node;\n    })\n\n    /**\n     * Star: \"*\"\n     */\n\n    .capture('star', function() {\n      var pos = this.position();\n      var starRe = /^(?:\\*(?![*(])|[*]{3,}(?!\\()|[*]{2}(?![(/]|$)|\\*(?=\\*\\())/;\n      var m = this.match(starRe);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.star = true;\n      return pos({\n        type: 'star',\n        val: m[0]\n      });\n    })\n\n    /**\n     * Slash: \"/\"\n     */\n\n    .capture('slash', function() {\n      var pos = this.position();\n      var m = this.match(/^\\//);\n      if (!m) return;\n\n      this.state.slashes++;\n      return pos({\n        type: 'slash',\n        val: m[0]\n      });\n    })\n\n    /**\n     * Backslash: \"\\\\\"\n     */\n\n    .capture('backslash', function() {\n      var pos = this.position();\n      var m = this.match(/^\\\\(?![*+?(){}[\\]'\"])/);\n      if (!m) return;\n\n      var val = m[0];\n\n      if (this.isInside('bracket')) {\n        val = '\\\\';\n      } else if (val.length > 1) {\n        val = '\\\\\\\\';\n      }\n\n      return pos({\n        type: 'backslash',\n        val: val\n      });\n    })\n\n    /**\n     * Square: \"[.]\"\n     */\n\n    .capture('square', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(/^\\[([^!^\\\\])\\]/);\n      if (!m) return;\n\n      return pos({\n        type: 'square',\n        val: m[1]\n      });\n    })\n\n    /**\n     * Brackets: \"[...]\" (basic, this can be overridden by other parsers)\n     */\n\n    .capture('bracket', function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]+|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var val = m[0];\n      var negated = m[1] ? '^' : '';\n      var inner = (m[2] || '').replace(/\\\\\\\\+/, '\\\\\\\\');\n      var close = m[3] || '';\n\n      if (m[2] && inner.length < m[2].length) {\n        val = val.replace(/\\\\\\\\+/, '\\\\\\\\');\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === '' && esc === '\\\\]') {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === ']') {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos({\n        type: 'bracket',\n        val: val,\n        escaped: close !== ']',\n        negated: negated,\n        inner: inner,\n        close: close\n      });\n    })\n\n    /**\n     * Text\n     */\n\n    .capture('text', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(not);\n      if (!m || !m[0]) return;\n\n      return pos({\n        type: 'text',\n        val: m[0]\n      });\n    });\n\n  /**\n   * Allow custom parsers to be passed on options\n   */\n\n  if (options && typeof options.parsers === 'function') {\n    options.parsers(nanomatch.parser);\n  }\n};\n\n/**\n * Advance to the next non-escaped character\n */\n\nfunction advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = { len: 1, val: '', esc: '' };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n  return tok;\n}\n\n/**\n * Create text regex\n */\n\nfunction createTextRegex(pattern) {\n  if (cached) return cached;\n  var opts = {contains: true, strictClose: false};\n  var not = regexNot.create(pattern, opts);\n  var re = toRegex('^(?:[*]\\\\((?=.)|' + not + ')', opts);\n  return (cached = re);\n}\n\n/**\n * Expose negation string\n */\n\nmodule.exports.not = NOT_REGEX;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}