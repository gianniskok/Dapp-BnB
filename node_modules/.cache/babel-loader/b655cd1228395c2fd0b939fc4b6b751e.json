{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n  const items = type.split(\"+\");\n  const t = items.shift();\n  return {\n    type: t === \"*\" ? null : t,\n    features: items\n  };\n}\n\nfunction isTypeMatched(baseType, testedType) {\n  if (typeof baseType === \"string\") baseType = parseType(baseType);\n  if (typeof testedType === \"string\") testedType = parseType(testedType);\n  if (testedType.type && testedType.type !== baseType.type) return false;\n  return testedType.features.every(requiredFeature => {\n    return baseType.features.indexOf(requiredFeature) >= 0;\n  });\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n  baseType = baseType.split(\"/\");\n  testedType = testedType.split(\"/\");\n  if (baseType.length !== testedType.length) return false;\n\n  for (let i = 0; i < baseType.length; i++) {\n    if (!isTypeMatched(baseType[i], testedType[i])) return false;\n  }\n\n  return true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n  return context.supportedResourceTypes && context.supportedResourceTypes.some(supportedType => {\n    return isResourceTypeMatched(supportedType, type);\n  });\n}\n\nfunction isEnvironment(context, env) {\n  return context.environments && context.environments.every(environment => {\n    return isTypeMatched(environment, env);\n  });\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n  const regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n  return regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n  const regExp = getGlobRegExp(glob);\n  return regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n  return !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n  const items = condition.split(\"|\");\n  return items.some(function testFn(item) {\n    item = item.trim();\n    const inverted = /^!/.test(item);\n    if (inverted) return !testFn(item.substr(1));\n\n    if (/^[a-z]+:/.test(item)) {\n      // match named condition\n      const match = /^([a-z]+):\\s*/.exec(item);\n      const value = item.substr(match[0].length);\n      const name = match[1];\n\n      switch (name) {\n        case \"referrer\":\n          return isGlobMatched(value, context.referrer);\n\n        default:\n          return false;\n      }\n    } else if (item.indexOf(\"/\") >= 0) {\n      // match supported type\n      return isResourceTypeSupported(context, item);\n    } else {\n      // match environment\n      return isEnvironment(context, item);\n    }\n  });\n}\n\nfunction isKeyMatched(context, key) {\n  for (;;) {\n    const match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n    if (!match) return key;\n    key = key.substr(match[0].length);\n    const condition = match[1];\n\n    if (!isConditionMatched(context, condition)) {\n      return false;\n    }\n  }\n}\n\nfunction getField(context, configuration, field) {\n  let value;\n  Object.keys(configuration).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (pureKey === field) {\n      value = configuration[key];\n    }\n  });\n  return value;\n}\n\nfunction getMain(context, configuration) {\n  return getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n  return getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n  const modulesField = getField(context, configuration, \"modules\");\n  if (!modulesField) return request;\n  let newRequest = request;\n  const keys = Object.keys(modulesField);\n  let iteration = 0;\n  let match;\n  let index;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const pureKey = isKeyMatched(context, key);\n    match = matchGlob(pureKey, newRequest);\n\n    if (match) {\n      const value = modulesField[key];\n\n      if (typeof value !== \"string\") {\n        return value;\n      } else if (/^\\(.+\\)$/.test(pureKey)) {\n        newRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n      } else {\n        index = 1;\n        newRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n      }\n\n      i = -1;\n\n      if (iteration++ > keys.length) {\n        throw new Error(\"Request '\" + request + \"' matches recursively\");\n      }\n    }\n  }\n\n  return newRequest;\n\n  function replaceMatcher(find) {\n    switch (find) {\n      case \"/**\":\n        {\n          const m = match[index++];\n          return m ? \"/\" + m : \"\";\n        }\n\n      case \"**\":\n      case \"*\":\n        return match[index++];\n    }\n  }\n}\n\nfunction matchType(context, configuration, relativePath) {\n  const typesField = getField(context, configuration, \"types\");\n  if (!typesField) return undefined;\n  let type;\n  Object.keys(typesField).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (isGlobMatched(pureKey, relativePath)) {\n      const value = typesField[key];\n      if (!type && /\\/\\*$/.test(value)) throw new Error(\"value ('\" + value + \"') of key '\" + key + \"' contains '*', but there is no previous value defined\");\n      type = value.replace(/\\/\\*$/, \"/\" + type);\n    }\n  });\n  return type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;","map":{"version":3,"names":["globToRegExp","require","parseType","type","items","split","t","shift","features","isTypeMatched","baseType","testedType","every","requiredFeature","indexOf","isResourceTypeMatched","length","i","isResourceTypeSupported","context","supportedResourceTypes","some","supportedType","isEnvironment","env","environments","environment","globCache","getGlobRegExp","glob","regExp","matchGlob","relativePath","exec","isGlobMatched","isConditionMatched","condition","testFn","item","trim","inverted","test","substr","match","value","name","referrer","isKeyMatched","key","getField","configuration","field","Object","keys","forEach","pureKey","getMain","getExtensions","matchModule","request","modulesField","newRequest","iteration","index","replace","replaceMatcher","Error","find","m","matchType","typesField","undefined","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/enhanced-resolve/lib/concord.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n\tconst items = type.split(\"+\");\n\tconst t = items.shift();\n\treturn {\n\t\ttype: t === \"*\" ? null : t,\n\t\tfeatures: items\n\t};\n}\n\nfunction isTypeMatched(baseType, testedType) {\n\tif (typeof baseType === \"string\") baseType = parseType(baseType);\n\tif (typeof testedType === \"string\") testedType = parseType(testedType);\n\tif (testedType.type && testedType.type !== baseType.type) return false;\n\treturn testedType.features.every(requiredFeature => {\n\t\treturn baseType.features.indexOf(requiredFeature) >= 0;\n\t});\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n\tbaseType = baseType.split(\"/\");\n\ttestedType = testedType.split(\"/\");\n\tif (baseType.length !== testedType.length) return false;\n\tfor (let i = 0; i < baseType.length; i++) {\n\t\tif (!isTypeMatched(baseType[i], testedType[i])) return false;\n\t}\n\treturn true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n\treturn (\n\t\tcontext.supportedResourceTypes &&\n\t\tcontext.supportedResourceTypes.some(supportedType => {\n\t\t\treturn isResourceTypeMatched(supportedType, type);\n\t\t})\n\t);\n}\n\nfunction isEnvironment(context, env) {\n\treturn (\n\t\tcontext.environments &&\n\t\tcontext.environments.every(environment => {\n\t\t\treturn isTypeMatched(environment, env);\n\t\t})\n\t);\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n\tconst regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n\treturn regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n\tconst regExp = getGlobRegExp(glob);\n\treturn regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n\treturn !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n\tconst items = condition.split(\"|\");\n\treturn items.some(function testFn(item) {\n\t\titem = item.trim();\n\t\tconst inverted = /^!/.test(item);\n\t\tif (inverted) return !testFn(item.substr(1));\n\t\tif (/^[a-z]+:/.test(item)) {\n\t\t\t// match named condition\n\t\t\tconst match = /^([a-z]+):\\s*/.exec(item);\n\t\t\tconst value = item.substr(match[0].length);\n\t\t\tconst name = match[1];\n\t\t\tswitch (name) {\n\t\t\t\tcase \"referrer\":\n\t\t\t\t\treturn isGlobMatched(value, context.referrer);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (item.indexOf(\"/\") >= 0) {\n\t\t\t// match supported type\n\t\t\treturn isResourceTypeSupported(context, item);\n\t\t} else {\n\t\t\t// match environment\n\t\t\treturn isEnvironment(context, item);\n\t\t}\n\t});\n}\n\nfunction isKeyMatched(context, key) {\n\tfor (;;) {\n\t\tconst match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n\t\tif (!match) return key;\n\t\tkey = key.substr(match[0].length);\n\t\tconst condition = match[1];\n\t\tif (!isConditionMatched(context, condition)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction getField(context, configuration, field) {\n\tlet value;\n\tObject.keys(configuration).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (pureKey === field) {\n\t\t\tvalue = configuration[key];\n\t\t}\n\t});\n\treturn value;\n}\n\nfunction getMain(context, configuration) {\n\treturn getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n\treturn getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n\tconst modulesField = getField(context, configuration, \"modules\");\n\tif (!modulesField) return request;\n\tlet newRequest = request;\n\tconst keys = Object.keys(modulesField);\n\tlet iteration = 0;\n\tlet match;\n\tlet index;\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tmatch = matchGlob(pureKey, newRequest);\n\t\tif (match) {\n\t\t\tconst value = modulesField[key];\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\treturn value;\n\t\t\t} else if (/^\\(.+\\)$/.test(pureKey)) {\n\t\t\t\tnewRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\tnewRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n\t\t\t}\n\t\t\ti = -1;\n\t\t\tif (iteration++ > keys.length) {\n\t\t\t\tthrow new Error(\"Request '\" + request + \"' matches recursively\");\n\t\t\t}\n\t\t}\n\t}\n\treturn newRequest;\n\n\tfunction replaceMatcher(find) {\n\t\tswitch (find) {\n\t\t\tcase \"/**\": {\n\t\t\t\tconst m = match[index++];\n\t\t\t\treturn m ? \"/\" + m : \"\";\n\t\t\t}\n\t\t\tcase \"**\":\n\t\t\tcase \"*\":\n\t\t\t\treturn match[index++];\n\t\t}\n\t}\n}\n\nfunction matchType(context, configuration, relativePath) {\n\tconst typesField = getField(context, configuration, \"types\");\n\tif (!typesField) return undefined;\n\tlet type;\n\tObject.keys(typesField).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (isGlobMatched(pureKey, relativePath)) {\n\t\t\tconst value = typesField[key];\n\t\t\tif (!type && /\\/\\*$/.test(value))\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"value ('\" +\n\t\t\t\t\t\tvalue +\n\t\t\t\t\t\t\"') of key '\" +\n\t\t\t\t\t\tkey +\n\t\t\t\t\t\t\"' contains '*', but there is no previous value defined\"\n\t\t\t\t);\n\t\t\ttype = value.replace(/\\/\\*$/, \"/\" + type);\n\t\t}\n\t});\n\treturn type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}