{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\n\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n\n  if (!match) {\n    return null;\n  }\n\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\n\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n\n  url += '//';\n\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n\n  return url;\n}\n\nexports.urlGenerate = urlGenerate;\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\n\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n\n    path = url.path;\n  }\n\n  var isAbsolute = exports.isAbsolute(path);\n  var parts = path.split(/\\/+/);\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n\n  return path;\n}\n\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\n\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  } // `join(foo, '//www.example.org')`\n\n\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  } // `join('http://', 'www.example.com')`\n\n\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n\n  return joined;\n}\n\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\n\n\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, ''); // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n\n  var level = 0;\n\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n\n    if (index < 0) {\n      return aPath;\n    } // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n\n\n    aRoot = aRoot.slice(0, index);\n\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\n\nexports.relative = relative;\n\nvar supportsNullProto = function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}();\n\nfunction identity(s) {\n  return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\n\n\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\n\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\n\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9\n  /* \"__proto__\".length */\n  ) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 2) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 3) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 4) !== 116\n  /* 't' */\n  || s.charCodeAt(length - 5) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 6) !== 114\n  /* 'r' */\n  || s.charCodeAt(length - 7) !== 112\n  /* 'p' */\n  || s.charCodeAt(length - 8) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 9) !== 95\n  /* '_' */\n  ) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36\n    /* '$' */\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\n\n\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByOriginalPositions = compareByOriginalPositions;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\n\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\n\n\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\n\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\n\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\n\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    } // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n\n\n    sourceURL = sourceRoot + sourceURL;\n  } // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n\n\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\n\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"names":["getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","isAbsolute","parts","split","part","up","i","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","indexOf","index","lastIndexOf","slice","Array","substr","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","charCodeAt","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","strcmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","aStr1","aStr2","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/source-map/lib/util.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}