{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst DependenciesBlockVariable = require(\"./DependenciesBlockVariable\");\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n\n/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nclass DependenciesBlock {\n  constructor() {\n    /** @type {Dependency[]} */\n    this.dependencies = [];\n    /** @type {AsyncDependenciesBlock[]} */\n\n    this.blocks = [];\n    /** @type {DependenciesBlockVariable[]} */\n\n    this.variables = [];\n  }\n  /**\n   * Adds a DependencyBlock to DependencyBlock relationship.\n   * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)\n   *\n   * @param {AsyncDependenciesBlock} block block being added\n   * @returns {void}\n   */\n\n\n  addBlock(block) {\n    this.blocks.push(block);\n    block.parent = this;\n  }\n  /**\n   * @param {string} name name of dependency\n   * @param {string} expression expression string for variable\n   * @param {Dependency[]} dependencies dependency instances tied to variable\n   * @returns {void}\n   */\n\n\n  addVariable(name, expression, dependencies) {\n    for (let v of this.variables) {\n      if (v.name === name && v.expression === expression) {\n        return;\n      }\n    }\n\n    this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));\n  }\n  /**\n   * @param {Dependency} dependency dependency being tied to block.\n   * This is an \"edge\" pointing to another \"node\" on module graph.\n   * @returns {void}\n   */\n\n\n  addDependency(dependency) {\n    this.dependencies.push(dependency);\n  }\n  /**\n   * @param {Dependency} dependency dependency being removed\n   * @returns {void}\n   */\n\n\n  removeDependency(dependency) {\n    const idx = this.dependencies.indexOf(dependency);\n\n    if (idx >= 0) {\n      this.dependencies.splice(idx, 1);\n    }\n  }\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @returns {void}\n   */\n\n\n  updateHash(hash) {\n    for (const dep of this.dependencies) dep.updateHash(hash);\n\n    for (const block of this.blocks) block.updateHash(hash);\n\n    for (const variable of this.variables) variable.updateHash(hash);\n  }\n\n  disconnect() {\n    for (const dep of this.dependencies) dep.disconnect();\n\n    for (const block of this.blocks) block.disconnect();\n\n    for (const variable of this.variables) variable.disconnect();\n  }\n\n  unseal() {\n    for (const block of this.blocks) block.unseal();\n  }\n  /**\n   * @param {DependencyFilterFunction} filter filter function for dependencies, gets passed all dependency ties from current instance\n   * @returns {boolean} returns boolean for filter\n   */\n\n\n  hasDependencies(filter) {\n    if (filter) {\n      for (const dep of this.dependencies) {\n        if (filter(dep)) return true;\n      }\n    } else {\n      if (this.dependencies.length > 0) {\n        return true;\n      }\n    }\n\n    for (const block of this.blocks) {\n      if (block.hasDependencies(filter)) return true;\n    }\n\n    for (const variable of this.variables) {\n      if (variable.hasDependencies(filter)) return true;\n    }\n\n    return false;\n  }\n\n  sortItems() {\n    for (const block of this.blocks) block.sortItems();\n  }\n\n}\n\nmodule.exports = DependenciesBlock;","map":{"version":3,"names":["DependenciesBlockVariable","require","DependenciesBlock","constructor","dependencies","blocks","variables","addBlock","block","push","parent","addVariable","name","expression","v","addDependency","dependency","removeDependency","idx","indexOf","splice","updateHash","hash","dep","variable","disconnect","unseal","hasDependencies","filter","length","sortItems","module","exports"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/webpack/lib/DependenciesBlock.js"],"sourcesContent":["/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst DependenciesBlockVariable = require(\"./DependenciesBlockVariable\");\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\nclass DependenciesBlock {\n\tconstructor() {\n\t\t/** @type {Dependency[]} */\n\t\tthis.dependencies = [];\n\t\t/** @type {AsyncDependenciesBlock[]} */\n\t\tthis.blocks = [];\n\t\t/** @type {DependenciesBlockVariable[]} */\n\t\tthis.variables = [];\n\t}\n\n\t/**\n\t * Adds a DependencyBlock to DependencyBlock relationship.\n\t * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)\n\t *\n\t * @param {AsyncDependenciesBlock} block block being added\n\t * @returns {void}\n\t */\n\taddBlock(block) {\n\t\tthis.blocks.push(block);\n\t\tblock.parent = this;\n\t}\n\n\t/**\n\t * @param {string} name name of dependency\n\t * @param {string} expression expression string for variable\n\t * @param {Dependency[]} dependencies dependency instances tied to variable\n\t * @returns {void}\n\t */\n\taddVariable(name, expression, dependencies) {\n\t\tfor (let v of this.variables) {\n\t\t\tif (v.name === name && v.expression === expression) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.variables.push(\n\t\t\tnew DependenciesBlockVariable(name, expression, dependencies)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Dependency} dependency dependency being tied to block.\n\t * This is an \"edge\" pointing to another \"node\" on module graph.\n\t * @returns {void}\n\t */\n\taddDependency(dependency) {\n\t\tthis.dependencies.push(dependency);\n\t}\n\n\t/**\n\t * @param {Dependency} dependency dependency being removed\n\t * @returns {void}\n\t */\n\tremoveDependency(dependency) {\n\t\tconst idx = this.dependencies.indexOf(dependency);\n\t\tif (idx >= 0) {\n\t\t\tthis.dependencies.splice(idx, 1);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash used to track dependencies\n\t * @returns {void}\n\t */\n\tupdateHash(hash) {\n\t\tfor (const dep of this.dependencies) dep.updateHash(hash);\n\t\tfor (const block of this.blocks) block.updateHash(hash);\n\t\tfor (const variable of this.variables) variable.updateHash(hash);\n\t}\n\n\tdisconnect() {\n\t\tfor (const dep of this.dependencies) dep.disconnect();\n\t\tfor (const block of this.blocks) block.disconnect();\n\t\tfor (const variable of this.variables) variable.disconnect();\n\t}\n\n\tunseal() {\n\t\tfor (const block of this.blocks) block.unseal();\n\t}\n\n\t/**\n\t * @param {DependencyFilterFunction} filter filter function for dependencies, gets passed all dependency ties from current instance\n\t * @returns {boolean} returns boolean for filter\n\t */\n\thasDependencies(filter) {\n\t\tif (filter) {\n\t\t\tfor (const dep of this.dependencies) {\n\t\t\t\tif (filter(dep)) return true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.dependencies.length > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (const block of this.blocks) {\n\t\t\tif (block.hasDependencies(filter)) return true;\n\t\t}\n\t\tfor (const variable of this.variables) {\n\t\t\tif (variable.hasDependencies(filter)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tsortItems() {\n\t\tfor (const block of this.blocks) block.sortItems();\n\t}\n}\n\nmodule.exports = DependenciesBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}