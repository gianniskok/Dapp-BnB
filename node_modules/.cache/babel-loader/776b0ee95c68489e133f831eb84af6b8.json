{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar common = require('./common.js');\n\nvar token = require('./token.js');\n\nvar jump = require('./jump.js');\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\n\nclass Tokeniser {\n  constructor(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n\n  done() {\n    return this.pos >= this.data.length;\n  }\n\n  next() {\n    const byt = this.data[this.pos];\n    let token = jump.quick[byt];\n\n    if (token === undefined) {\n      const decoder = jump.jump[byt];\n\n      if (!decoder) {\n        throw new Error(`${common.decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`);\n      }\n\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n\n    this.pos += token.encodedLength;\n    return token;\n  }\n\n}\n\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\n\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n\n      throw new Error(`${common.decodeErrPrefix} got unexpected break to lengthed array`);\n    }\n\n    if (value === DONE) {\n      throw new Error(`${common.decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);\n    }\n\n    arr[i] = value;\n  }\n\n  return arr;\n}\n\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n\n      throw new Error(`${common.decodeErrPrefix} got unexpected break to lengthed map`);\n    }\n\n    if (key === DONE) {\n      throw new Error(`${common.decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);\n    }\n\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${common.decodeErrPrefix} non-string keys not supported (got ${typeof key})`);\n    }\n\n    const value = tokensToObject(tokeniser, options);\n\n    if (value === DONE) {\n      throw new Error(`${common.decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);\n    }\n\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n\n  return useMaps ? m : obj;\n}\n\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n\n  const token$1 = tokeniser.next();\n\n  if (token$1.type === token.Type.break) {\n    return BREAK;\n  }\n\n  if (token$1.type.terminal) {\n    return token$1.value;\n  }\n\n  if (token$1.type === token.Type.array) {\n    return tokenToArray(token$1, tokeniser, options);\n  }\n\n  if (token$1.type === token.Type.map) {\n    return tokenToMap(token$1, tokeniser, options);\n  }\n\n  if (token$1.type === token.Type.tag) {\n    if (options.tags && typeof options.tags[token$1.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token$1.value](tagged);\n    }\n\n    throw new Error(`${common.decodeErrPrefix} tag not supported (${token$1.value})`);\n  }\n\n  throw new Error('unsupported');\n}\n\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${common.decodeErrPrefix} data to decode must be a Uint8Array`);\n  }\n\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n\n  if (decoded === DONE) {\n    throw new Error(`${common.decodeErrPrefix} did not find any content to decode`);\n  }\n\n  if (decoded === BREAK) {\n    throw new Error(`${common.decodeErrPrefix} got unexpected break`);\n  }\n\n  if (!tokeniser.done()) {\n    throw new Error(`${common.decodeErrPrefix} too many terminals, data makes no sense`);\n  }\n\n  return decoded;\n}\n\nexports.Tokeniser = Tokeniser;\nexports.decode = decode;\nexports.tokensToObject = tokensToObject;","map":{"version":3,"names":["Object","defineProperty","exports","value","common","require","token","jump","defaultDecodeOptions","strict","allowIndefinite","allowUndefined","allowBigInt","Tokeniser","constructor","data","options","pos","done","length","next","byt","quick","undefined","decoder","Error","decodeErrPrefix","toString","padStart","minor","encodedLength","DONE","Symbol","for","BREAK","tokenToArray","tokeniser","arr","i","tokensToObject","Infinity","tokenToMap","useMaps","obj","m","Map","key","set","token$1","type","Type","break","terminal","array","map","tag","tags","tagged","decode","Uint8Array","assign","tokenizer","decoded"],"sources":["/Users/iaonniskokkoros/Documents/OG BrokeBoiz/node_modules/cborg/cjs/lib/decode.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar common = require('./common.js');\nvar token = require('./token.js');\nvar jump = require('./jump.js');\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = jump.quick[byt];\n    if (token === undefined) {\n      const decoder = jump.jump[byt];\n      if (!decoder) {\n        throw new Error(`${ common.decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ common.decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ common.decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ common.decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ common.decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ common.decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ common.decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token$1 = tokeniser.next();\n  if (token$1.type === token.Type.break) {\n    return BREAK;\n  }\n  if (token$1.type.terminal) {\n    return token$1.value;\n  }\n  if (token$1.type === token.Type.array) {\n    return tokenToArray(token$1, tokeniser, options);\n  }\n  if (token$1.type === token.Type.map) {\n    return tokenToMap(token$1, tokeniser, options);\n  }\n  if (token$1.type === token.Type.tag) {\n    if (options.tags && typeof options.tags[token$1.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token$1.value](tagged);\n    }\n    throw new Error(`${ common.decodeErrPrefix } tag not supported (${ token$1.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ common.decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ common.decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ common.decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ common.decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\n\nexports.Tokeniser = Tokeniser;\nexports.decode = decode;\nexports.tokensToObject = tokensToObject;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}